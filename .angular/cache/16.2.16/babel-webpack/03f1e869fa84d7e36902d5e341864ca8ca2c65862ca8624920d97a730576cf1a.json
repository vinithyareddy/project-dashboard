{"ast":null,"code":"/** @license\n\ndhtmlxGantt v.9.0.7 Standard\n\nThis version of dhtmlxGantt is distributed under GPL 2.0 license and can be legally used in GPL projects.\n\nTo use dhtmlxGantt in non-GPL projects (and get Pro version of the product), please obtain Individual, Commercial, Enterprise or Ultimate license on our site https://dhtmlx.com/docs/products/dhtmlxGantt/#licensing or contact us at info@dhtmlx.com\n\n(c) XB Software\n\n*/\nfunction U(t) {\n  var e = 0,\n    n = 0,\n    i = 0,\n    a = 0;\n  if (t.getBoundingClientRect) {\n    var r = t.getBoundingClientRect(),\n      s = document.body,\n      o = document.documentElement || document.body.parentNode || document.body,\n      l = window.pageYOffset || o.scrollTop || s.scrollTop,\n      d = window.pageXOffset || o.scrollLeft || s.scrollLeft,\n      c = o.clientTop || s.clientTop || 0,\n      u = o.clientLeft || s.clientLeft || 0;\n    e = r.top + l - c, n = r.left + d - u, i = document.body.offsetWidth - r.right, a = document.body.offsetHeight - r.bottom;\n  } else {\n    for (; t;) e += parseInt(t.offsetTop, 10), n += parseInt(t.offsetLeft, 10), t = t.offsetParent;\n    i = document.body.offsetWidth - t.offsetWidth - n, a = document.body.offsetHeight - t.offsetHeight - e;\n  }\n  return {\n    y: Math.round(e),\n    x: Math.round(n),\n    width: t.offsetWidth,\n    height: t.offsetHeight,\n    right: Math.round(i),\n    bottom: Math.round(a)\n  };\n}\nfunction An(t) {\n  var e = !1,\n    n = !1;\n  if (window.getComputedStyle) {\n    var i = window.getComputedStyle(t, null);\n    e = i.display, n = i.visibility;\n  } else t.currentStyle && (e = t.currentStyle.display, n = t.currentStyle.visibility);\n  return e != \"none\" && n != \"hidden\";\n}\nfunction In(t) {\n  return !isNaN(t.getAttribute(\"tabindex\")) && 1 * t.getAttribute(\"tabindex\") >= 0;\n}\nfunction Mn(t) {\n  return !{\n    a: !0,\n    area: !0\n  }[t.nodeName.loLowerCase()] || !!t.getAttribute(\"href\");\n}\nfunction Nn(t) {\n  return !{\n    input: !0,\n    select: !0,\n    textarea: !0,\n    button: !0,\n    object: !0\n  }[t.nodeName.toLowerCase()] || !t.hasAttribute(\"disabled\");\n}\nfunction Lt(t) {\n  for (var e = t.querySelectorAll([\"a[href]\", \"area[href]\", \"input\", \"select\", \"textarea\", \"button\", \"iframe\", \"object\", \"embed\", \"[tabindex]\", \"[contenteditable]\"].join(\", \")), n = Array.prototype.slice.call(e, 0), i = 0; i < n.length; i++) n[i].$position = i;\n  for (n.sort(function (r, s) {\n    return r.tabIndex === 0 && s.tabIndex !== 0 ? 1 : r.tabIndex !== 0 && s.tabIndex === 0 ? -1 : r.tabIndex === s.tabIndex ? r.$position - s.$position : r.tabIndex < s.tabIndex ? -1 : 1;\n  }), i = 0; i < n.length; i++) {\n    var a = n[i];\n    (In(a) || Nn(a) || Mn(a)) && An(a) || (n.splice(i, 1), i--);\n  }\n  return n;\n}\nfunction Qe() {\n  var t = document.createElement(\"div\");\n  t.style.cssText = \"visibility:hidden;position:absolute;left:-1000px;width:100px;padding:0px;margin:0px;height:110px;min-height:100px;overflow-y:scroll;\", document.body.appendChild(t);\n  var e = t.offsetWidth - t.clientWidth;\n  return document.body.removeChild(t), Math.max(e, 15);\n}\nfunction X(t) {\n  if (!t) return \"\";\n  var e = t.className || \"\";\n  return e.baseVal && (e = e.baseVal), e.indexOf || (e = \"\"), _e(e);\n}\nfunction wt(t, e) {\n  e && t.className.indexOf(e) === -1 && (t.className += \" \" + e);\n}\nfunction Gt(t, e) {\n  e = e.split(\" \");\n  for (var n = 0; n < e.length; n++) {\n    var i = new RegExp(\"\\\\s?\\\\b\" + e[n] + \"\\\\b(?![-_.])\", \"\");\n    t.className = t.className.replace(i, \"\");\n  }\n}\nfunction we(t) {\n  return typeof t == \"string\" ? document.getElementById(t) || document.querySelector(t) || document.body : t || document.body;\n}\nvar Bt;\nfunction tn(t, e) {\n  Bt || (Bt = document.createElement(\"div\")), Bt.innerHTML = e;\n  var n = Bt.firstChild;\n  return t.appendChild(n), n;\n}\nfunction en(t) {\n  t && t.parentNode && t.parentNode.removeChild(t);\n}\nfunction nn(t, e) {\n  for (var n = t.childNodes, i = n.length, a = [], r = 0; r < i; r++) {\n    var s = n[r];\n    s.className && s.className.indexOf(e) !== -1 && a.push(s);\n  }\n  return a;\n}\nfunction yt(t) {\n  var e;\n  return t.tagName ? e = t : (e = (t = t || window.event).target || t.srcElement).shadowRoot && t.composedPath && (e = t.composedPath()[0]), e;\n}\nfunction et(t, e) {\n  if (e) {\n    for (var n = yt(t); n;) {\n      if (n.getAttribute && n.getAttribute(e)) return n;\n      n = n.parentNode;\n    }\n    return null;\n  }\n}\nfunction _e(t) {\n  return (String.prototype.trim || function () {\n    return this.replace(/^\\s+|\\s+$/g, \"\");\n  }).apply(t);\n}\nfunction pt(t, e, n) {\n  var i = yt(t),\n    a = \"\";\n  for (n === void 0 && (n = !0); i;) {\n    if (a = X(i)) {\n      var r = a.indexOf(e);\n      if (r >= 0) {\n        if (!n) return i;\n        var s = r === 0 || !_e(a.charAt(r - 1)),\n          o = r + e.length >= a.length || !_e(a.charAt(r + e.length));\n        if (s && o) return i;\n      }\n    }\n    i = i.parentNode;\n  }\n  return null;\n}\nfunction rt(t, e) {\n  var n = document.documentElement,\n    i = U(e);\n  return {\n    x: t.clientX + n.scrollLeft - n.clientLeft - i.x + e.scrollLeft,\n    y: t.clientY + n.scrollTop - n.clientTop - i.y + e.scrollTop\n  };\n}\nfunction an(t, e) {\n  const n = U(t),\n    i = U(e);\n  return {\n    x: n.x - i.x,\n    y: n.y - i.y\n  };\n}\nfunction Y(t, e) {\n  if (!t || !e) return !1;\n  for (; t && t != e;) t = t.parentNode;\n  return t === e;\n}\nfunction ct(t, e) {\n  if (t.closest) return t.closest(e);\n  if (t.matches || t.msMatchesSelector || t.webkitMatchesSelector) {\n    var n = t;\n    if (!document.documentElement.contains(n)) return null;\n    do {\n      if ((n.matches || n.msMatchesSelector || n.webkitMatchesSelector).call(n, e)) return n;\n      n = n.parentElement || n.parentNode;\n    } while (n !== null && n.nodeType === 1);\n    return null;\n  }\n  return console.error(\"Your browser is not supported\"), null;\n}\nfunction rn(t) {\n  for (; t;) {\n    if (t.offsetWidth > 0 && t.offsetHeight > 0) return t;\n    t = t.parentElement;\n  }\n  return null;\n}\nfunction sn() {\n  return document.head.createShadowRoot || document.head.attachShadow;\n}\nfunction ge() {\n  var t = document.activeElement;\n  return t.shadowRoot && (t = t.shadowRoot.activeElement), t === document.body && document.getSelection && (t = document.getSelection().focusNode || document.body), t;\n}\nfunction vt(t) {\n  if (!t || !sn()) return document.body;\n  for (; t.parentNode && (t = t.parentNode);) if (t instanceof ShadowRoot) return t.host;\n  return document.body;\n}\nconst on = Object.freeze(Object.defineProperty({\n    __proto__: null,\n    addClassName: wt,\n    closest: ct,\n    getActiveElement: ge,\n    getChildNodes: nn,\n    getClassName: X,\n    getClosestSizedElement: rn,\n    getFocusableNodes: Lt,\n    getNodePosition: U,\n    getRelativeEventPosition: rt,\n    getRelativeNodePosition: an,\n    getRootNode: vt,\n    getScrollSize: Qe,\n    getTargetNode: yt,\n    hasClass: function (t, e) {\n      return \"classList\" in t ? t.classList.contains(e) : new RegExp(\"\\\\b\" + e + \"\\\\b\").test(t.className);\n    },\n    hasShadowParent: function (t) {\n      return !!vt(t);\n    },\n    insertNode: tn,\n    isChildOf: Y,\n    isShadowDomSupported: sn,\n    locateAttribute: et,\n    locateClassName: pt,\n    removeClassName: Gt,\n    removeNode: en,\n    toNode: we\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  dt = typeof window < \"u\" ? window : global;\nlet Ln = class {\n  constructor(t) {\n    this._mouseDown = !1, this._gantt = t, this._domEvents = t._createDomEventScope();\n  }\n  attach(t, e, n) {\n    const i = this._gantt,\n      a = t.getViewPort();\n    this._originPosition = dt.getComputedStyle(a).display, this._restoreOriginPosition = () => {\n      a.style.position = this._originPosition;\n    }, this._originPosition === \"static\" && (a.style.position = \"relative\");\n    const r = i.$services.getService(\"state\");\n    r.registerProvider(\"clickDrag\", () => ({\n      autoscroll: !1\n    }));\n    let s = null;\n    const o = () => {\n      s && (this._mouseDown = !0, t.setStart(i.copy(s)), t.setPosition(i.copy(s)), t.setEnd(i.copy(s)), s = null);\n    };\n    this._domEvents.attach(a, \"mousedown\", d => {\n      s = null;\n      let c = \".gantt_task_line, .gantt_task_link\";\n      n !== void 0 && (c = n instanceof Array ? n.join(\", \") : n), c && i.utils.dom.closest(d.target, c) || (r.registerProvider(\"clickDrag\", () => ({\n        autoscroll: this._mouseDown\n      })), e && d[e] !== !0 || (s = this._getCoordinates(d, t)));\n    });\n    const l = vt(i.$root) || document.body;\n    this._domEvents.attach(l, \"mouseup\", d => {\n      if (s = null, (!e || d[e] === !0) && this._mouseDown === !0) {\n        this._mouseDown = !1;\n        const c = this._getCoordinates(d, t);\n        t.dragEnd(c);\n      }\n    }), this._domEvents.attach(a, \"mousemove\", d => {\n      if (e && d[e] !== !0) return;\n      const c = this._gantt.ext.clickDrag,\n        u = (this._gantt.config.drag_timeline || {}).useKey;\n      if (c && u && !e && d[u]) return;\n      let h = null;\n      if (!this._mouseDown && s) return h = this._getCoordinates(d, t), void (Math.abs(s.relative.left - h.relative.left) > 5 && o());\n      this._mouseDown === !0 && (h = this._getCoordinates(d, t), t.setEnd(h), t.render());\n    });\n  }\n  detach() {\n    const t = this._gantt;\n    this._domEvents.detachAll(), this._restoreOriginPosition && this._restoreOriginPosition(), t.$services.getService(\"state\").unregisterProvider(\"clickDrag\");\n  }\n  destructor() {\n    this.detach();\n  }\n  _getCoordinates(t, e) {\n    const n = e.getViewPort(),\n      i = n.getBoundingClientRect(),\n      {\n        clientX: a,\n        clientY: r\n      } = t;\n    return {\n      absolute: {\n        left: a,\n        top: r\n      },\n      relative: {\n        left: a - i.left + n.scrollLeft,\n        top: r - i.top + n.scrollTop\n      }\n    };\n  }\n};\nvar ln = function () {\n  this._silent_mode = !1, this.listeners = {};\n};\nln.prototype = {\n  _silentStart: function () {\n    this._silent_mode = !0;\n  },\n  _silentEnd: function () {\n    this._silent_mode = !1;\n  }\n};\nvar Pn = function (t) {\n  var e = {},\n    n = 0,\n    i = function () {\n      var a = !0;\n      for (var r in e) {\n        var s = e[r].apply(t, arguments);\n        a = a && s;\n      }\n      return a;\n    };\n  return i.addEvent = function (a, r) {\n    if (typeof a == \"function\") {\n      var s;\n      if (r && r.id ? s = r.id : (s = n, n++), r && r.once) {\n        var o = a;\n        a = function () {\n          o(), i.removeEvent(s);\n        };\n      }\n      return e[s] = a, s;\n    }\n    return !1;\n  }, i.removeEvent = function (a) {\n    delete e[a];\n  }, i.clear = function () {\n    e = {};\n  }, i;\n};\nfunction ot(t) {\n  var e = new ln();\n  t.attachEvent = function (n, i, a) {\n    n = \"ev_\" + n.toLowerCase(), e.listeners[n] || (e.listeners[n] = Pn(this)), a && a.thisObject && (i = i.bind(a.thisObject));\n    var r = n + \":\" + e.listeners[n].addEvent(i, a);\n    return a && a.id && (r = a.id), r;\n  }, t.attachAll = function (n) {\n    this.attachEvent(\"listen_all\", n);\n  }, t.callEvent = function (n, i) {\n    if (e._silent_mode) return !0;\n    var a = \"ev_\" + n.toLowerCase(),\n      r = e.listeners;\n    return r.ev_listen_all && r.ev_listen_all.apply(this, [n].concat(i)), !r[a] || r[a].apply(this, i);\n  }, t.checkEvent = function (n) {\n    return !!e.listeners[\"ev_\" + n.toLowerCase()];\n  }, t.detachEvent = function (n) {\n    if (n) {\n      var i = e.listeners;\n      for (var a in i) i[a].removeEvent(n);\n      var r = n.split(\":\");\n      if (i = e.listeners, r.length === 2) {\n        var s = r[0],\n          o = r[1];\n        i[s] && i[s].removeEvent(o);\n      }\n    }\n  }, t.detachAllEvents = function () {\n    for (var n in e.listeners) e.listeners[n].clear();\n  };\n}\nvar Ce = {\n  second: 1,\n  minute: 60,\n  hour: 3600,\n  day: 86400,\n  week: 604800,\n  month: 2592e3,\n  quarter: 7776e3,\n  year: 31536e3\n};\nfunction Vt(t) {\n  return Ce[t] || Ce.hour;\n}\nfunction kt(t, e) {\n  if (t.forEach) t.forEach(e);else for (var n = t.slice(), i = 0; i < n.length; i++) e(n[i], i);\n}\nfunction Rn(t, e) {\n  if (t.find) return t.find(e);\n  for (var n = 0; n < t.length; n++) if (e(t[n], n)) return t[n];\n}\nfunction zt(t, e) {\n  if (t.includes) return t.includes(e);\n  for (var n = 0; n < t.length; n++) if (t[n] === e) return !0;\n  return !1;\n}\nfunction fe(t) {\n  return Array.isArray ? Array.isArray(t) : t && t.length !== void 0 && t.pop && t.push;\n}\nfunction Z(t) {\n  return !(!t || typeof t != \"object\") && !!(t.getFullYear && t.getMonth && t.getDate);\n}\nfunction bt(t) {\n  return Z(t) && !isNaN(t.getTime());\n}\nfunction De(t, e) {\n  var n,\n    i = function () {\n      i.$cancelTimeout(), i.$pending = !0;\n      var a = Array.prototype.slice.call(arguments);\n      n = setTimeout(function () {\n        t.apply(this, a), i.$pending = !1;\n      }, e);\n    };\n  return i.$pending = !1, i.$cancelTimeout = function () {\n    clearTimeout(n), i.$pending = !1;\n  }, i.$execute = function () {\n    var a = Array.prototype.slice.call(arguments);\n    t.apply(this, a), i.$cancelTimeout();\n  }, i;\n}\nfunction at(t, e) {\n  return Ae(t) && !Ae(e) && (t = \"0\"), t;\n}\nfunction Ae(t) {\n  return t === 0;\n}\nfunction At(t, e) {\n  for (var n, i, a, r = 0, s = t.length - 1; r <= s;) if (i = +t[n = Math.floor((r + s) / 2)], a = +t[n - 1], i < e) r = n + 1;else {\n    if (!(i > e)) {\n      for (; +t[n] == +t[n + 1];) n++;\n      return n;\n    }\n    if (!isNaN(a) && a < e) return n - 1;\n    s = n - 1;\n  }\n  return t.length - 1;\n}\nclass Hn {\n  constructor(e, n, i) {\n    var a;\n    this._el = document.createElement(\"div\"), this.defaultRender = (r, s) => {\n      this._el || (this._el = document.createElement(\"div\"));\n      const o = this._el,\n        l = Math.min(r.relative.top, s.relative.top),\n        d = Math.max(r.relative.top, s.relative.top),\n        c = Math.min(r.relative.left, s.relative.left),\n        u = Math.max(r.relative.left, s.relative.left);\n      if (this._singleRow) {\n        const h = this._getTaskPositionByTop(this._startPoint.relative.top);\n        o.style.height = h.height + \"px\", o.style.top = h.top + \"px\";\n      } else o.style.height = Math.abs(d - l) + \"px\", o.style.top = l + \"px\";\n      return o.style.width = Math.abs(u - c) + \"px\", o.style.left = c + \"px\", o;\n    }, this._gantt = n, this._view = i, this._viewPort = e.viewPort, this._el.classList.add(e.className), typeof e.callback == \"function\" && (this._callback = e.callback), this.render = () => {\n      let r;\n      r = e.render ? e.render(this._startPoint, this._endPoint) : this.defaultRender(this._startPoint, this._endPoint), r !== this._el && (this._el && this._el.parentNode && this._el.parentNode.removeChild(this._el), this._el = r), e.className !== \"\" && this._el.classList.add(e.className), this.draw();\n    }, (a = this._viewPort).attachEvent && a.detachEvent || ot(this._viewPort), this._singleRow = e.singleRow, this._useRequestAnimationFrame = e.useRequestAnimationFrame;\n  }\n  draw() {\n    if (this._useRequestAnimationFrame) return requestAnimationFrame(() => {\n      this._viewPort.appendChild(this.getElement());\n    });\n    this._viewPort.appendChild(this.getElement());\n  }\n  clear() {\n    if (this._useRequestAnimationFrame) return requestAnimationFrame(() => {\n      this._el.parentNode && this._viewPort.removeChild(this._el);\n    });\n    this._el.parentNode && this._viewPort.removeChild(this._el);\n  }\n  getElement() {\n    return this._el;\n  }\n  getViewPort() {\n    return this._viewPort;\n  }\n  setStart(e) {\n    const n = this._gantt;\n    this._startPoint = e, this._startDate = n.dateFromPos(this._startPoint.relative.left), this._viewPort.callEvent(\"onBeforeDrag\", [this._startPoint]);\n  }\n  setEnd(e) {\n    const n = this._gantt;\n    if (this._endPoint = e, this._singleRow) {\n      const i = this._getTaskPositionByTop(this._startPoint.relative.top);\n      this._endPoint.relative.top = i.top;\n    }\n    this._endDate = n.dateFromPos(this._endPoint.relative.left), this._startPoint.relative.left > this._endPoint.relative.left && (this._positionPoint = {\n      relative: {\n        left: this._endPoint.relative.left,\n        top: this._positionPoint.relative.top\n      },\n      absolute: {\n        left: this._endPoint.absolute.left,\n        top: this._positionPoint.absolute.top\n      }\n    }), this._startPoint.relative.top > this._endPoint.relative.top && (this._positionPoint = {\n      relative: {\n        left: this._positionPoint.relative.left,\n        top: this._endPoint.relative.top\n      },\n      absolute: {\n        left: this._positionPoint.absolute.left,\n        top: this._endPoint.absolute.top\n      }\n    }), this._viewPort.callEvent(\"onDrag\", [this._startPoint, this._endPoint]);\n  }\n  setPosition(e) {\n    this._positionPoint = e;\n  }\n  dragEnd(e) {\n    const n = this._gantt;\n    e.relative.left < 0 && (e.relative.left = 0), this._viewPort.callEvent(\"onBeforeDragEnd\", [this._startPoint, e]), this.setEnd(e), this._endDate = this._endDate || n.getState().max_date, this._startDate.valueOf() > this._endDate.valueOf() && ([this._startDate, this._endDate] = [this._endDate, this._startDate]), this.clear();\n    const i = n.getTaskByTime(this._startDate, this._endDate),\n      a = this._getTasksByTop(this._startPoint.relative.top, this._endPoint.relative.top);\n    this._viewPort.callEvent(\"onDragEnd\", [this._startPoint, this._endPoint]), this._callback && this._callback(this._startPoint, this._endPoint, this._startDate, this._endDate, i, a);\n  }\n  getInBounds() {\n    return this._singleRow;\n  }\n  _getTasksByTop(e, n) {\n    const i = this._gantt;\n    let a = e,\n      r = n;\n    e > n && (a = n, r = e);\n    const s = this._getTaskPositionByTop(a).index,\n      o = this._getTaskPositionByTop(r).index,\n      l = [];\n    for (let d = s; d <= o; d++) i.getTaskByIndex(d) && l.push(i.getTaskByIndex(d));\n    return l;\n  }\n  _getTaskPositionByTop(e) {\n    const n = this._gantt,\n      i = this._view,\n      a = i.getItemIndexByTopPosition(e),\n      r = n.getTaskByIndex(a);\n    if (r) {\n      const s = i.getItemHeight(r.id);\n      return {\n        top: i.getItemTop(r.id) || 0,\n        height: s || 0,\n        index: a\n      };\n    }\n    {\n      const s = i.getTotalHeight();\n      return {\n        top: e > s ? s : 0,\n        height: n.config.row_height,\n        index: e > s ? n.getTaskCount() : 0\n      };\n    }\n  }\n}\nlet te = !1;\nclass Yt {\n  constructor(e) {\n    this._mouseDown = !1, this._calculateDirectionVector = () => {\n      if (this._trace.length >= 10) {\n        const n = this._trace.slice(this._trace.length - 10),\n          i = [];\n        for (let r = 1; r < n.length; r++) i.push({\n          x: n[r].x - n[r - 1].x,\n          y: n[r].y - n[r - 1].y\n        });\n        const a = {\n          x: 0,\n          y: 0\n        };\n        return i.forEach(r => {\n          a.x += r.x, a.y += r.y;\n        }), {\n          magnitude: Math.sqrt(a.x * a.x + a.y * a.y),\n          angleDegrees: 180 * Math.atan2(Math.abs(a.y), Math.abs(a.x)) / Math.PI\n        };\n      }\n      return null;\n    }, this._applyDndReadyStyles = () => {\n      this._timeline.$task.classList.add(\"gantt_timeline_move_available\");\n    }, this._clearDndReadyStyles = () => {\n      this._timeline.$task.classList.remove(\"gantt_timeline_move_available\");\n    }, this._getScrollPosition = n => {\n      const i = this._gantt;\n      return {\n        x: i.$ui.getView(n.$config.scrollX).getScrollState().position,\n        y: i.$ui.getView(n.$config.scrollY).getScrollState().position\n      };\n    }, this._countNewScrollPosition = n => {\n      const i = this._calculateDirectionVector();\n      let a = this._startPoint.x - n.x,\n        r = this._startPoint.y - n.y;\n      return i && (i.angleDegrees < 15 ? r = 0 : i.angleDegrees > 75 && (a = 0)), {\n        x: this._scrollState.x + a,\n        y: this._scrollState.y + r\n      };\n    }, this._setScrollPosition = (n, i) => {\n      const a = this._gantt;\n      requestAnimationFrame(() => {\n        a.scrollLayoutCell(n.$id, i.x, i.y);\n      });\n    }, this._stopDrag = n => {\n      const i = this._gantt;\n      if (this._trace = [], i.$root.classList.remove(\"gantt_noselect\"), this._originalReadonly !== void 0 && (i.config.readonly = this._originalReadonly, this._mouseDown && i.config.drag_timeline && i.config.drag_timeline.render && i.render()), this._originAutoscroll !== void 0 && (i.config.autoscroll = this._originAutoscroll), i.config.drag_timeline) {\n        const {\n          useKey: a\n        } = i.config.drag_timeline;\n        if (a && n[a] !== !0) return;\n      }\n      this._mouseDown = !1, te = !1;\n    }, this._startDrag = n => {\n      const i = this._gantt;\n      this._originAutoscroll = i.config.autoscroll, i.config.autoscroll = !1, te = !0, i.$root.classList.add(\"gantt_noselect\"), this._originalReadonly = i.config.readonly, i.config.readonly = !0, i.config.drag_timeline && i.config.drag_timeline.render && i.render(), this._trace = [], this._mouseDown = !0;\n      const {\n        x: a,\n        y: r\n      } = this._getScrollPosition(this._timeline);\n      this._scrollState = {\n        x: a,\n        y: r\n      }, this._startPoint = {\n        x: n.clientX,\n        y: n.clientY\n      }, this._trace.push(this._startPoint);\n    }, this._gantt = e, this._domEvents = e._createDomEventScope(), this._trace = [];\n  }\n  static create(e) {\n    return new Yt(e);\n  }\n  static _isDragInProgress() {\n    return te;\n  }\n  destructor() {\n    this._domEvents.detachAll();\n  }\n  attach(e) {\n    this._timeline = e;\n    const n = this._gantt;\n    this._domEvents.attach(e.$task, \"mousedown\", i => {\n      if (!n.config.drag_timeline) return;\n      const {\n        useKey: a,\n        ignore: r,\n        enabled: s\n      } = n.config.drag_timeline;\n      if (s === !1) return;\n      let o = \".gantt_task_line, .gantt_task_link\";\n      r !== void 0 && (o = r instanceof Array ? r.join(\", \") : r), o && n.utils.dom.closest(i.target, o) || a && i[a] !== !0 || this._startDrag(i);\n    }), this._domEvents.attach(document, \"keydown\", i => {\n      if (!n.config.drag_timeline) return;\n      const {\n        useKey: a\n      } = n.config.drag_timeline;\n      a && i[a] === !0 && this._applyDndReadyStyles();\n    }), this._domEvents.attach(document, \"keyup\", i => {\n      if (!n.config.drag_timeline) return;\n      const {\n        useKey: a\n      } = n.config.drag_timeline;\n      a && i[a] === !1 && (this._clearDndReadyStyles(), this._stopDrag(i));\n    }), this._domEvents.attach(document, \"mouseup\", i => {\n      this._stopDrag(i);\n    }), this._domEvents.attach(n.$root, \"mouseup\", i => {\n      this._stopDrag(i);\n    }), this._domEvents.attach(document, \"mouseleave\", i => {\n      this._stopDrag(i);\n    }), this._domEvents.attach(n.$root, \"mouseleave\", i => {\n      this._stopDrag(i);\n    }), this._domEvents.attach(n.$root, \"mousemove\", i => {\n      if (!n.config.drag_timeline) return;\n      const {\n        useKey: a\n      } = n.config.drag_timeline;\n      if (a && i[a] !== !0) return;\n      const r = this._gantt.ext.clickDrag,\n        s = (this._gantt.config.click_drag || {}).useKey;\n      if ((!r || !s || a || !i[s]) && this._mouseDown === !0) {\n        this._trace.push({\n          x: i.clientX,\n          y: i.clientY\n        });\n        const o = this._countNewScrollPosition({\n          x: i.clientX,\n          y: i.clientY\n        });\n        this._setScrollPosition(e, o), this._scrollState = o, this._startPoint = {\n          x: i.clientX,\n          y: i.clientY\n        };\n      }\n    });\n  }\n}\nfunction On(t) {\n  (function () {\n    var e = [];\n    function n() {\n      return !!e.length;\n    }\n    function i(d) {\n      setTimeout(function () {\n        n() || t.$destroyed || t.focus();\n      }, 1);\n    }\n    function a(d) {\n      t.eventRemove(d, \"keydown\", s), t.event(d, \"keydown\", s), e.push(d);\n    }\n    function r() {\n      var d = e.pop();\n      d && t.eventRemove(d, \"keydown\", s), i();\n    }\n    function s(d) {\n      var c = d.currentTarget;\n      c == e[e.length - 1] && t.$keyboardNavigation.trapFocus(c, d);\n    }\n    function o() {\n      a(t.getLightbox());\n    }\n    t.attachEvent(\"onLightbox\", o), t.attachEvent(\"onAfterLightbox\", r), t.attachEvent(\"onLightboxChange\", function () {\n      r(), o();\n    }), t.attachEvent(\"onAfterQuickInfo\", function () {\n      i();\n    }), t.attachEvent(\"onMessagePopup\", function (d) {\n      l = t.utils.dom.getActiveElement(), a(d);\n    }), t.attachEvent(\"onAfterMessagePopup\", function () {\n      r(), setTimeout(function () {\n        l && (l.focus(), l = null);\n      }, 1);\n    });\n    var l = null;\n    t.$keyboardNavigation.isModal = n;\n  })();\n}\nclass Bn {\n  constructor(e) {\n    this.show = (n, i) => {\n      i === void 0 ? this._showForTask(n) : this._showAtCoordinates(n, i);\n    }, this.hide = n => {\n      const i = this._gantt,\n        a = this._quickInfoBox;\n      this._quickInfoBoxId = 0;\n      const r = this._quickInfoTask;\n      if (this._quickInfoTask = null, a && a.parentNode) {\n        if (i.config.quick_info_detached) return i.callEvent(\"onAfterQuickInfo\", [r]), a.parentNode.removeChild(a);\n        a.className += \" gantt_qi_hidden\", a.style.right === \"auto\" ? a.style.left = \"-350px\" : a.style.right = \"-350px\", n && (a.style.left = a.style.right = \"\", a.parentNode.removeChild(a)), i.callEvent(\"onAfterQuickInfo\", [r]);\n      }\n    }, this.getNode = () => this._quickInfoBox ? this._quickInfoBox : null, this.setContainer = n => {\n      n && (this._container = typeof n == \"string\" ? document.getElementById(n) : n);\n    }, this.setContent = n => {\n      const i = this._gantt,\n        a = {\n          taskId: null,\n          header: {\n            title: \"\",\n            date: \"\"\n          },\n          content: \"\",\n          buttons: i.config.quickinfo_buttons\n        };\n      n || (n = a), n.taskId || (n.taskId = a.taskId), n.header || (n.header = a.header), n.header.title || (n.header.title = a.header.title), n.header.date || (n.header.date = a.header.date), n.content || (n.content = a.content), n.buttons || (n.buttons = a.buttons);\n      let r = this.getNode();\n      r || (r = this._createQuickInfoElement()), n.taskId && (this._quickInfoBoxId = n.taskId);\n      const s = r.querySelector(\".gantt_cal_qi_title\"),\n        o = s.querySelector(\".gantt_cal_qi_tcontent\"),\n        l = s.querySelector(\".gantt_cal_qi_tdate\"),\n        d = r.querySelector(\".gantt_cal_qi_content\"),\n        c = r.querySelector(\".gantt_cal_qi_controls\");\n      i._waiAria.quickInfoHeader(r, [n.header.title, n.header.date].join(\" \")), o.innerHTML = n.header.title, l.innerHTML = n.header.date, n.header.title || n.header.date ? s.style.display = \"\" : s.style.display = \"none\", d.innerHTML = n.content;\n      const u = n.buttons;\n      u.length ? c.style.display = \"\" : c.style.display = \"none\";\n      let h = \"\";\n      for (let g = 0; g < u.length; g++) {\n        const f = i._waiAria.quickInfoButtonAttrString(i.locale.labels[u[g]]);\n        h += `<div class=\"gantt_qi_big_icon ${u[g]} dhx_gantt_${u[g]}\" title=\"${i.locale.labels[u[g]]}\" ${f}>\n            <div class='dhx_menu_icon dhx_gantt_icon ${u[g]} gantt_menu_icon dhx_gantt_${u[g]}'></div>\n            <div>${i.locale.labels[u[g]]}</div>\n         </div>`;\n      }\n      c.innerHTML = h, i.eventRemove(r, \"click\", this._qiButtonClickHandler), i.eventRemove(r, \"keypress\", this._qiKeyPressHandler), i.event(r, \"click\", this._qiButtonClickHandler), i.event(r, \"keypress\", this._qiKeyPressHandler);\n    }, this._qiButtonClickHandler = n => {\n      this._qi_button_click(n.target);\n    }, this._qiKeyPressHandler = n => {\n      const i = n.which;\n      i !== 13 && i !== 32 || setTimeout(() => {\n        this._qi_button_click(n.target);\n      }, 1);\n    }, this._gantt = e;\n  }\n  _showAtCoordinates(e, n) {\n    this.hide(!0), this._quickInfoBoxId = 0, this._quickInfoTask = null, this._quickInfoBox || (this._createQuickInfoElement(), this.setContent()), this._appendAtCoordinates(e, n), this._gantt.callEvent(\"onQuickInfo\", [null]);\n  }\n  _showForTask(e) {\n    const n = this._gantt;\n    if (e === this._quickInfoBoxId && n.utils.dom.isChildOf(this._quickInfoBox, document.body) || !n.config.show_quick_info) return;\n    this.hide(!0);\n    const i = this._getContainer(),\n      a = this._get_event_counter_part(e, 6, i.xViewport, i.yViewport);\n    a && (this._quickInfoBox = this._init_quick_info(e), this._quickInfoTask = e, this._quickInfoBox.className = this._prepare_quick_info_classname(e), this._fill_quick_data(e), this._show_quick_info(a, 6), n.callEvent(\"onQuickInfo\", [e]));\n  }\n  _get_event_counter_part(e, n, i, a) {\n    const r = this._gantt;\n    let s = r.getTaskNode(e);\n    if (!s && (s = r.getTaskRowNode(e), !s)) return null;\n    let o = 0;\n    const l = n + s.offsetTop + s.offsetHeight;\n    let d = s;\n    if (r.utils.dom.isChildOf(d, i)) for (; d && d !== i;) o += d.offsetLeft, d = d.offsetParent;\n    const c = r.getScrollState();\n    return d ? {\n      left: o,\n      top: l,\n      dx: o + s.offsetWidth / 2 - c.x > i.offsetWidth / 2 ? 1 : 0,\n      dy: l + s.offsetHeight / 2 - c.y > a.offsetHeight / 2 ? 1 : 0,\n      width: s.offsetWidth,\n      height: s.offsetHeight\n    } : null;\n  }\n  _createQuickInfoElement() {\n    const e = this._gantt,\n      n = document.createElement(\"div\");\n    n.className += \"gantt_cal_quick_info\", e._waiAria.quickInfoAttr(n);\n    var i = `\n\t\t<div class=\"gantt_cal_qi_tcontrols\">\n\t\t\t<a class=\"gantt_cal_qi_close_btn dhx_gantt_icon dhx_gantt_icon_close\"></a>\n\t\t</div>\n\t\t<div class=\"gantt_cal_qi_title\" ${e._waiAria.quickInfoHeaderAttrString()}>\n\t\t\t\t\n\t\t\t\t<div class=\"gantt_cal_qi_tcontent\"></div>\n\t\t\t\t<div class=\"gantt_cal_qi_tdate\"></div>\n\t\t\t</div>\n\t\t\t<div class=\"gantt_cal_qi_content\"></div>`;\n    if (i += '<div class=\"gantt_cal_qi_controls\">', i += \"</div>\", n.innerHTML = i, e.config.quick_info_detached) {\n      const a = this._getContainer();\n      e.event(a.parent, \"scroll\", () => {\n        this.hide();\n      });\n    }\n    return this._quickInfoBox = n, n;\n  }\n  _init_quick_info(e) {\n    const n = this._gantt,\n      i = n.getTask(e);\n    return typeof this._quickInfoReadonly == \"boolean\" && n.isReadonly(i) !== this._quickInfoReadonly && (this.hide(!0), this._quickInfoBox = null), this._quickInfoReadonly = n.isReadonly(i), this._quickInfoBox || (this._quickInfoBox = this._createQuickInfoElement()), this._quickInfoBox;\n  }\n  _prepare_quick_info_classname(e) {\n    const n = this._gantt,\n      i = n.getTask(e);\n    let a = `gantt_cal_quick_info gantt_${n.getTaskType(i)}`;\n    const r = n.templates.quick_info_class(i.start_date, i.end_date, i);\n    return r && (a += \" \" + r), a;\n  }\n  _fill_quick_data(e) {\n    const n = this._gantt,\n      i = n.getTask(e);\n    this._quickInfoBoxId = e;\n    let a = [];\n    if (this._quickInfoReadonly) {\n      const r = n.config.quickinfo_buttons,\n        s = {\n          icon_delete: !0,\n          icon_edit: !0\n        };\n      for (let o = 0; o < r.length; o++) this._quickInfoReadonly && s[r[o]] || a.push(r[o]);\n    } else a = n.config.quickinfo_buttons;\n    this.setContent({\n      header: {\n        title: n.templates.quick_info_title(i.start_date, i.end_date, i),\n        date: n.templates.quick_info_date(i.start_date, i.end_date, i)\n      },\n      content: n.templates.quick_info_content(i.start_date, i.end_date, i),\n      buttons: a\n    });\n  }\n  _appendAtCoordinates(e, n) {\n    const i = this._quickInfoBox,\n      a = this._getContainer();\n    i.parentNode && i.parentNode.nodeName.toLowerCase() !== \"#document-fragment\" || a.parent.appendChild(i), i.style.left = e + \"px\", i.style.top = n + \"px\";\n  }\n  _show_quick_info(e, n) {\n    const i = this._gantt,\n      a = this._quickInfoBox;\n    if (i.config.quick_info_detached) {\n      const r = this._getContainer();\n      a.parentNode && a.parentNode.nodeName.toLowerCase() !== \"#document-fragment\" || r.parent.appendChild(a);\n      const s = a.offsetWidth,\n        o = a.offsetHeight,\n        l = i.getScrollState(),\n        d = r.xViewport,\n        c = r.yViewport,\n        u = d.offsetWidth + l.x - s,\n        h = e.top - l.y + o;\n      let g = e.top;\n      h > c.offsetHeight / 2 && (g = e.top - (o + e.height + 2 * n), g < l.y && h <= c.offsetHeight && (g = e.top)), g < l.y && (g = l.y);\n      const f = Math.min(Math.max(l.x, e.left - e.dx * (s - e.width)), u),\n        y = g;\n      this._appendAtCoordinates(f, y);\n    } else a.style.top = \"20px\", e.dx === 1 ? (a.style.right = \"auto\", a.style.left = \"-300px\", setTimeout(() => {\n      a.style.left = \"10px\";\n    }, 1)) : (a.style.left = \"auto\", a.style.right = \"-300px\", setTimeout(() => {\n      a.style.right = \"10px\";\n    }, 1)), a.className += \" gantt_qi_\" + (e.dx === 1 ? \"left\" : \"right\"), i.$root.appendChild(a);\n  }\n  _qi_button_click(e) {\n    const n = this._gantt,\n      i = this._quickInfoBox;\n    if (!e || e === i) return;\n    if (e.closest(\".gantt_cal_qi_close_btn\")) return void this.hide();\n    const a = e.className;\n    if (a.indexOf(\"_icon\") !== -1) {\n      const r = this._quickInfoBoxId;\n      n.$click.buttons[a.split(\" \")[1].replace(\"icon_\", \"\")](r);\n    } else this._qi_button_click(e.parentNode);\n  }\n  _getContainer() {\n    const e = this._gantt;\n    let n = this._container ? this._container : e.$task_data;\n    return n && n.offsetHeight && n.offsetWidth ? {\n      parent: n,\n      xViewport: e.$task,\n      yViewport: e.$task_data\n    } : (n = this._container ? this._container : e.$grid_data, n && n.offsetHeight && n.offsetWidth ? {\n      parent: n,\n      xViewport: e.$grid,\n      yViewport: e.$grid_data\n    } : {\n      parent: this._container ? this._container : e.$layout,\n      xViewport: e.$layout,\n      yViewport: e.$layout\n    });\n  }\n}\nvar ee,\n  zn = {}.constructor.toString();\nfunction G(t) {\n  var e, n;\n  if (t && typeof t == \"object\") switch (!0) {\n    case Z(t):\n      n = new Date(t);\n      break;\n    case fe(t):\n      for (n = new Array(t.length), e = 0; e < t.length; e++) n[e] = G(t[e]);\n      break;\n    default:\n      for (e in n = function (i) {\n        return i.constructor.toString() !== zn;\n      }(t) ? Object.create(t) : {}, t) Object.prototype.hasOwnProperty.apply(t, [e]) && (n[e] = G(t[e]));\n  }\n  return n || t;\n}\nfunction L(t, e, n) {\n  for (var i in e) (t[i] === void 0 || n) && (t[i] = e[i]);\n  return t;\n}\nfunction j(t) {\n  return t !== void 0;\n}\nfunction st() {\n  return ee || (ee = /* @__PURE__ */new Date().valueOf()), ++ee;\n}\nfunction R(t, e) {\n  return t.bind ? t.bind(e) : function () {\n    return t.apply(e, arguments);\n  };\n}\nfunction dn(t, e, n, i) {\n  t.addEventListener ? t.addEventListener(e, n, i !== void 0 && i) : t.attachEvent && t.attachEvent(\"on\" + e, n);\n}\nfunction cn(t, e, n, i) {\n  t.removeEventListener ? t.removeEventListener(e, n, i !== void 0 && i) : t.detachEvent && t.detachEvent(\"on\" + e, n);\n}\nconst Wn = Object.freeze(Object.defineProperty({\n  __proto__: null,\n  bind: R,\n  copy: G,\n  defined: j,\n  event: dn,\n  eventRemove: cn,\n  mixin: L,\n  uid: st\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nfunction Se(t, e) {\n  t = t || dn, e = e || cn;\n  var n = [],\n    i = {\n      attach: function (a, r, s, o) {\n        n.push({\n          element: a,\n          event: r,\n          callback: s,\n          capture: o\n        }), t(a, r, s, o);\n      },\n      detach: function (a, r, s, o) {\n        e(a, r, s, o);\n        for (var l = 0; l < n.length; l++) {\n          var d = n[l];\n          d.element === a && d.event === r && d.callback === s && d.capture === o && (n.splice(l, 1), l--);\n        }\n      },\n      detachAll: function () {\n        for (var a = n.slice(), r = 0; r < a.length; r++) {\n          var s = a[r];\n          i.detach(s.element, s.event, s.callback, s.capture), i.detach(s.element, s.event, s.callback, void 0), i.detach(s.element, s.event, s.callback, !1), i.detach(s.element, s.event, s.callback, !0);\n        }\n        n.splice(0, n.length);\n      },\n      extend: function () {\n        return Se(this.event, this.eventRemove);\n      }\n    };\n  return i;\n}\nclass jn {\n  constructor(e) {\n    this._gantt = e;\n  }\n  getNode() {\n    const e = this._gantt;\n    return this._tooltipNode || (this._tooltipNode = document.createElement(\"div\"), this._tooltipNode.className = \"gantt_tooltip\", e._waiAria.tooltipAttr(this._tooltipNode)), this._tooltipNode;\n  }\n  setViewport(e) {\n    return this._root = e, this;\n  }\n  show(e, n) {\n    const i = this._gantt,\n      a = document.body,\n      r = this.getNode();\n    if (Y(r, a) || (this.hide(), r.style.top = r.style.top || \"0px\", r.style.left = r.style.left || \"0px\", a.appendChild(r)), this._isLikeMouseEvent(e)) {\n      const s = this._calculateTooltipPosition(e);\n      n = s.top, e = s.left;\n    }\n    return r.style.top = n + \"px\", r.style.left = e + \"px\", i._waiAria.tooltipVisibleAttr(r), this;\n  }\n  hide() {\n    const e = this._gantt,\n      n = this.getNode();\n    return n && n.parentNode && n.parentNode.removeChild(n), e._waiAria.tooltipHiddenAttr(n), this;\n  }\n  setContent(e) {\n    return this.getNode().innerHTML = e, this;\n  }\n  _isLikeMouseEvent(e) {\n    return !(!e || typeof e != \"object\") && \"clientX\" in e && \"clientY\" in e;\n  }\n  _getViewPort() {\n    return this._root || document.body;\n  }\n  _calculateTooltipPosition(e) {\n    const n = this._gantt,\n      i = this._getViewPortSize(),\n      a = this.getNode(),\n      r = {\n        top: 0,\n        left: 0,\n        width: a.offsetWidth,\n        height: a.offsetHeight,\n        bottom: 0,\n        right: 0\n      },\n      s = n.config.tooltip_offset_x,\n      o = n.config.tooltip_offset_y,\n      l = document.body,\n      d = rt(e, l),\n      c = U(l);\n    d.y += c.y, r.top = d.y, r.left = d.x, r.top += o, r.left += s, r.bottom = r.top + r.height, r.right = r.left + r.width;\n    const u = window.scrollY + l.scrollTop;\n    return r.top < i.top - u ? (r.top = i.top, r.bottom = r.top + r.height) : r.bottom > i.bottom && (r.bottom = i.bottom, r.top = r.bottom - r.height), r.left < i.left ? (r.left = i.left, r.right = i.left + r.width) : r.right > i.right && (r.right = i.right, r.left = r.right - r.width), d.x >= r.left && d.x <= r.right && (r.left = d.x - r.width - s, r.right = r.left + r.width), d.y >= r.top && d.y <= r.bottom && (r.top = d.y - r.height - o, r.bottom = r.top + r.height), r;\n  }\n  _getViewPortSize() {\n    const e = this._gantt,\n      n = this._getViewPort();\n    let i,\n      a = n,\n      r = window.scrollY + document.body.scrollTop,\n      s = window.scrollX + document.body.scrollLeft;\n    return n === e.$task_data ? (a = e.$task, r = 0, s = 0, i = U(e.$task)) : i = U(a), {\n      left: i.x + s,\n      top: i.y + r,\n      width: i.width,\n      height: i.height,\n      bottom: i.y + i.height + r,\n      right: i.x + i.width + s\n    };\n  }\n}\nclass Fn {\n  constructor(e) {\n    this._listeners = {}, this.tooltip = new jn(e), this._gantt = e, this._domEvents = Se(), this._initDelayedFunctions();\n  }\n  destructor() {\n    this.tooltip.hide(), this._domEvents.detachAll();\n  }\n  hideTooltip() {\n    this.delayHide();\n  }\n  attach(e) {\n    let n = document.body;\n    const i = this._gantt;\n    e.global || (n = i.$root);\n    let a = null;\n    const r = s => {\n      const o = yt(s),\n        l = ct(o, e.selector);\n      if (Y(o, this.tooltip.getNode())) return;\n      const d = () => {\n        a = l, e.onmouseenter(s, l);\n      };\n      a ? l && l === a ? e.onmousemove(s, l) : (e.onmouseleave(s, a), a = null, l && l !== a && d()) : l && d();\n    };\n    this.detach(e.selector), this._domEvents.attach(n, \"mousemove\", r), this._listeners[e.selector] = {\n      node: n,\n      handler: r\n    };\n  }\n  detach(e) {\n    const n = this._listeners[e];\n    n && this._domEvents.detach(n.node, \"mousemove\", n.handler);\n  }\n  tooltipFor(e) {\n    const n = i => {\n      let a = i;\n      return document.createEventObject && !document.createEvent && (a = document.createEventObject(i)), a;\n    };\n    this._initDelayedFunctions(), this.attach({\n      selector: e.selector,\n      global: e.global,\n      onmouseenter: (i, a) => {\n        const r = e.html(i, a);\n        r && this.delayShow(n(i), r);\n      },\n      onmousemove: (i, a) => {\n        const r = e.html(i, a);\n        r ? this.delayShow(n(i), r) : (this.delayShow.$cancelTimeout(), this.delayHide());\n      },\n      onmouseleave: () => {\n        this.delayShow.$cancelTimeout(), this.delayHide();\n      }\n    });\n  }\n  _initDelayedFunctions() {\n    const e = this._gantt;\n    this.delayShow && this.delayShow.$cancelTimeout(), this.delayHide && this.delayHide.$cancelTimeout(), this.tooltip.hide(), this.delayShow = De((n, i) => {\n      e.callEvent(\"onBeforeTooltip\", [n]) === !1 ? this.tooltip.hide() : (this.tooltip.setContent(i), this.tooltip.show(n));\n    }, e.config.tooltip_timeout || 1), this.delayHide = De(() => {\n      this.delayShow.$cancelTimeout(), this.tooltip.hide();\n    }, e.config.tooltip_hide_timeout || 1);\n  }\n}\nconst Ie = {\n    onBeforeUndo: \"onAfterUndo\",\n    onBeforeRedo: \"onAfterRedo\"\n  },\n  Me = [\"onTaskDragStart\", \"onAfterTaskUpdate\", \"onAfterParentExpand\", \"onAfterTaskDelete\", \"onBeforeBatchUpdate\"];\nclass Vn {\n  constructor(e, n) {\n    this._batchAction = null, this._batchMode = !1, this._ignore = !1, this._ignoreMoveEvents = !1, this._initialTasks = {}, this._initialLinks = {}, this._nestedTasks = {}, this._nestedLinks = {}, this._undo = e, this._gantt = n, this._attachEvents();\n  }\n  store(e, n, i = !1) {\n    return n === this._gantt.config.undo_types.task ? this._storeTask(e, i) : n === this._gantt.config.undo_types.link && this._storeLink(e, i);\n  }\n  isMoveEventsIgnored() {\n    return this._ignoreMoveEvents;\n  }\n  toggleIgnoreMoveEvents(e) {\n    this._ignoreMoveEvents = e || !1;\n  }\n  startIgnore() {\n    this._ignore = !0;\n  }\n  stopIgnore() {\n    this._ignore = !1;\n  }\n  startBatchAction() {\n    this._timeout || (this._timeout = setTimeout(() => {\n      this.stopBatchAction(), this._timeout = null;\n    }, 10)), this._ignore || this._batchMode || (this._batchMode = !0, this._batchAction = this._undo.action.create());\n  }\n  stopBatchAction() {\n    if (this._ignore) return;\n    const e = this._undo;\n    this._batchAction && e.logAction(this._batchAction), this._batchMode = !1, this._batchAction = null;\n  }\n  onTaskAdded(e) {\n    this._ignore || this._storeTaskCommand(e, this._undo.command.type.add);\n  }\n  onTaskUpdated(e) {\n    this._ignore || this._storeTaskCommand(e, this._undo.command.type.update);\n  }\n  onTaskMoved(e) {\n    this._ignore || (e.$local_index = this._gantt.getTaskIndex(e.id), this._storeEntityCommand(e, this.getInitialTask(e.id), this._undo.command.type.move, this._undo.command.entity.task));\n  }\n  onTaskDeleted(e) {\n    if (!this._ignore) {\n      if (this._storeTaskCommand(e, this._undo.command.type.remove), this._nestedTasks[e.id]) {\n        const n = this._nestedTasks[e.id];\n        for (let i = 0; i < n.length; i++) this._storeTaskCommand(n[i], this._undo.command.type.remove);\n      }\n      if (this._nestedLinks[e.id]) {\n        const n = this._nestedLinks[e.id];\n        for (let i = 0; i < n.length; i++) this._storeLinkCommand(n[i], this._undo.command.type.remove);\n      }\n    }\n  }\n  onLinkAdded(e) {\n    this._ignore || this._storeLinkCommand(e, this._undo.command.type.add);\n  }\n  onLinkUpdated(e) {\n    this._ignore || this._storeLinkCommand(e, this._undo.command.type.update);\n  }\n  onLinkDeleted(e) {\n    this._ignore || this._storeLinkCommand(e, this._undo.command.type.remove);\n  }\n  setNestedTasks(e, n) {\n    const i = this._gantt;\n    let a = null;\n    const r = [];\n    let s = this._getLinks(i.getTask(e));\n    for (let d = 0; d < n.length; d++) a = this.setInitialTask(n[d]), s = s.concat(this._getLinks(a)), r.push(a);\n    const o = {};\n    for (let d = 0; d < s.length; d++) o[s[d]] = !0;\n    const l = [];\n    for (const d in o) l.push(this.setInitialLink(d));\n    this._nestedTasks[e] = r, this._nestedLinks[e] = l;\n  }\n  setInitialTask(e, n) {\n    const i = this._gantt;\n    if (n || !this._initialTasks[e] || !this._batchMode) {\n      const a = i.copy(i.getTask(e));\n      a.$index = i.getGlobalTaskIndex(e), a.$local_index = i.getTaskIndex(e), this.setInitialTaskObject(e, a);\n    }\n    return this._initialTasks[e];\n  }\n  getInitialTask(e) {\n    return this._initialTasks[e];\n  }\n  clearInitialTasks() {\n    this._initialTasks = {};\n  }\n  setInitialTaskObject(e, n) {\n    this._initialTasks[e] = n;\n  }\n  setInitialLink(e, n) {\n    return this._initialLinks[e] && this._batchMode || (this._initialLinks[e] = this._gantt.copy(this._gantt.getLink(e))), this._initialLinks[e];\n  }\n  getInitialLink(e) {\n    return this._initialLinks[e];\n  }\n  clearInitialLinks() {\n    this._initialLinks = {};\n  }\n  _attachEvents() {\n    let e = null;\n    const n = this._gantt,\n      i = () => {\n        e || (e = setTimeout(() => {\n          e = null;\n        }), this.clearInitialTasks(), n.eachTask(l => {\n          this.setInitialTask(l.id);\n        }), this.clearInitialLinks(), n.getLinks().forEach(l => {\n          this.setInitialLink(l.id);\n        }));\n      },\n      a = l => n.copy(n.getTask(l));\n    for (const l in Ie) n.attachEvent(l, () => (this.startIgnore(), !0)), n.attachEvent(Ie[l], () => (this.stopIgnore(), !0));\n    for (let l = 0; l < Me.length; l++) n.attachEvent(Me[l], () => (this.startBatchAction(), !0));\n    n.attachEvent(\"onParse\", () => {\n      this._undo.clearUndoStack(), this._undo.clearRedoStack(), i();\n    }), n.attachEvent(\"onAfterTaskAdd\", (l, d) => {\n      this.setInitialTask(l, !0), this.onTaskAdded(d);\n    }), n.attachEvent(\"onAfterTaskUpdate\", (l, d) => {\n      this.onTaskUpdated(d);\n    }), n.attachEvent(\"onAfterParentExpand\", (l, d) => {\n      this.onTaskUpdated(d);\n    }), n.attachEvent(\"onAfterTaskDelete\", (l, d) => {\n      this.onTaskDeleted(d);\n    }), n.attachEvent(\"onAfterLinkAdd\", (l, d) => {\n      this.setInitialLink(l, !0), this.onLinkAdded(d);\n    }), n.attachEvent(\"onAfterLinkUpdate\", (l, d) => {\n      this.onLinkUpdated(d);\n    }), n.attachEvent(\"onAfterLinkDelete\", (l, d) => {\n      this.onLinkDeleted(d);\n    }), n.attachEvent(\"onRowDragEnd\", (l, d) => (this.onTaskMoved(a(l)), this.toggleIgnoreMoveEvents(), !0)), n.attachEvent(\"onBeforeTaskDelete\", l => {\n      this.store(l, n.config.undo_types.task);\n      const d = [];\n      return i(), n.eachTask(c => {\n        d.push(c.id);\n      }, l), this.setNestedTasks(l, d), !0;\n    });\n    const r = n.getDatastore(\"task\");\n    r.attachEvent(\"onBeforeItemMove\", (l, d, c) => (this.isMoveEventsIgnored() || i(), !0)), r.attachEvent(\"onAfterItemMove\", (l, d, c) => (this.isMoveEventsIgnored() || this.onTaskMoved(a(l)), !0)), n.attachEvent(\"onRowDragStart\", (l, d, c) => (this.toggleIgnoreMoveEvents(!0), i(), !0));\n    let s = null,\n      o = !1;\n    if (n.attachEvent(\"onBeforeTaskDrag\", l => {\n      if (s = n.getState().drag_id, s === l) {\n        const d = n.getTask(l);\n        n.isSummaryTask(d) && n.config.drag_project && (o = !0);\n      }\n      if (n.plugins().multiselect) {\n        const d = n.getSelectedTasks();\n        d.length > 1 && d.forEach(c => {\n          this.store(c, n.config.undo_types.task, !0);\n        });\n      }\n      return this.store(l, n.config.undo_types.task);\n    }), n.attachEvent(\"onAfterTaskDrag\", l => {\n      (o || n.plugins().multiselect && n.getSelectedTasks().length > 1) && s === l && (o = !1, s = null, this.stopBatchAction()), this.store(l, n.config.undo_types.task, !0);\n    }), n.attachEvent(\"onLightbox\", l => this.store(l, n.config.undo_types.task)), n.attachEvent(\"onBeforeTaskAutoSchedule\", l => (this.store(l.id, n.config.undo_types.task, !0), !0)), n.ext.inlineEditors) {\n      let l = null,\n        d = null;\n      n.attachEvent(\"onGanttLayoutReady\", () => {\n        l && n.ext.inlineEditors.detachEvent(l), d && n.ext.inlineEditors.detachEvent(d), d = n.ext.inlineEditors.attachEvent(\"onEditStart\", c => {\n          this.store(c.id, n.config.undo_types.task);\n        }), l = n.ext.inlineEditors.attachEvent(\"onBeforeEditStart\", c => (this.stopBatchAction(), !0));\n      });\n    }\n  }\n  _storeCommand(e) {\n    const n = this._undo;\n    if (n.updateConfigs(), n.undoEnabled) if (this._batchMode) this._batchAction.commands.push(e);else {\n      const i = n.action.create([e]);\n      n.logAction(i);\n    }\n  }\n  _storeEntityCommand(e, n, i, a) {\n    const r = this._undo.command.create(e, n, i, a);\n    this._storeCommand(r);\n  }\n  _storeTaskCommand(e, n) {\n    this._gantt.isTaskExists(e.id) && (e.$local_index = this._gantt.getTaskIndex(e.id)), this._storeEntityCommand(e, this.getInitialTask(e.id), n, this._undo.command.entity.task);\n  }\n  _storeLinkCommand(e, n) {\n    this._storeEntityCommand(e, this.getInitialLink(e.id), n, this._undo.command.entity.link);\n  }\n  _getLinks(e) {\n    return e.$source.concat(e.$target);\n  }\n  _storeTask(e, n = !1) {\n    const i = this._gantt;\n    return this.setInitialTask(e, n), i.eachTask(a => {\n      this.setInitialTask(a.id);\n    }, e), !0;\n  }\n  _storeLink(e, n = !1) {\n    return this.setInitialLink(e, n), !0;\n  }\n}\nclass Un {\n  constructor(e) {\n    this.maxSteps = 100, this.undoEnabled = !0, this.redoEnabled = !0, this.action = {\n      create: n => ({\n        commands: n ? n.slice() : []\n      }),\n      invert: n => {\n        const i = this._gantt.copy(n),\n          a = this.command;\n        for (let r = 0; r < n.commands.length; r++) {\n          const s = i.commands[r] = a.invert(i.commands[r]);\n          s.type !== a.type.update && s.type !== a.type.move || ([s.value, s.oldValue] = [s.oldValue, s.value]);\n        }\n        return i;\n      }\n    }, this.command = {\n      entity: null,\n      type: null,\n      create: (n, i, a, r) => {\n        const s = this._gantt;\n        return {\n          entity: r,\n          type: a,\n          value: s.copy(n),\n          oldValue: s.copy(i || n)\n        };\n      },\n      invert: n => {\n        const i = this._gantt.copy(n);\n        return i.type = this.command.inverseCommands(n.type), i;\n      },\n      inverseCommands: n => {\n        const i = this._gantt,\n          a = this.command.type;\n        switch (n) {\n          case a.update:\n            return a.update;\n          case a.remove:\n            return a.add;\n          case a.add:\n            return a.remove;\n          case a.move:\n            return a.move;\n          default:\n            return i.assert(!1, \"Invalid command \" + n), null;\n        }\n      }\n    }, this._undoStack = [], this._redoStack = [], this._gantt = e;\n  }\n  getUndoStack() {\n    return this._undoStack;\n  }\n  setUndoStack(e) {\n    this._undoStack = e;\n  }\n  getRedoStack() {\n    return this._redoStack;\n  }\n  setRedoStack(e) {\n    this._redoStack = e;\n  }\n  clearUndoStack() {\n    this._undoStack = [];\n  }\n  clearRedoStack() {\n    this._redoStack = [];\n  }\n  updateConfigs() {\n    const e = this._gantt;\n    this.maxSteps = e.config.undo_steps || 100, this.command.entity = e.config.undo_types, this.command.type = e.config.undo_actions, this.undoEnabled = !!e.config.undo, this.redoEnabled = !!e.config.redo;\n  }\n  undo() {\n    const e = this._gantt;\n    if (this.updateConfigs(), !this.undoEnabled) return;\n    const n = this._pop(this._undoStack);\n    if (n && this._reorderCommands(n), e.callEvent(\"onBeforeUndo\", [n]) !== !1 && n) return this._applyAction(this.action.invert(n)), this._push(this._redoStack, e.copy(n)), void e.callEvent(\"onAfterUndo\", [n]);\n    e.callEvent(\"onAfterUndo\", [null]);\n  }\n  redo() {\n    const e = this._gantt;\n    if (this.updateConfigs(), !this.redoEnabled) return;\n    const n = this._pop(this._redoStack);\n    if (n && this._reorderCommands(n), e.callEvent(\"onBeforeRedo\", [n]) !== !1 && n) return this._applyAction(n), this._push(this._undoStack, e.copy(n)), void e.callEvent(\"onAfterRedo\", [n]);\n    e.callEvent(\"onAfterRedo\", [null]);\n  }\n  logAction(e) {\n    this._push(this._undoStack, e), this._redoStack = [];\n  }\n  _push(e, n) {\n    const i = this._gantt;\n    if (!n.commands.length) return;\n    const a = e === this._undoStack ? \"onBeforeUndoStack\" : \"onBeforeRedoStack\";\n    if (i.callEvent(a, [n]) !== !1 && n.commands.length) {\n      for (e.push(n); e.length > this.maxSteps;) e.shift();\n      return n;\n    }\n  }\n  _pop(e) {\n    return e.pop();\n  }\n  _reorderCommands(e) {\n    const n = {\n        any: 0,\n        link: 1,\n        task: 2\n      },\n      i = {\n        move: 1,\n        any: 0\n      };\n    e.commands.sort(function (a, r) {\n      if (a.entity === \"task\" && r.entity === \"task\") return a.type !== r.type ? (i[r.type] || 0) - (i[a.type] || 0) : a.type === \"move\" && a.oldValue && r.oldValue && r.oldValue.parent === a.oldValue.parent ? a.oldValue.$index - r.oldValue.$index : 0;\n      {\n        const s = n[a.entity] || n.any;\n        return (n[r.entity] || n.any) - s;\n      }\n    });\n  }\n  _applyAction(e) {\n    let n = null;\n    const i = this.command.entity,\n      a = this.command.type,\n      r = this._gantt,\n      s = {};\n    s[i.task] = {\n      add: \"addTask\",\n      get: \"getTask\",\n      update: \"updateTask\",\n      remove: \"deleteTask\",\n      move: \"moveTask\",\n      isExists: \"isTaskExists\"\n    }, s[i.link] = {\n      add: \"addLink\",\n      get: \"getLink\",\n      update: \"updateLink\",\n      remove: \"deleteLink\",\n      isExists: \"isLinkExists\"\n    }, r.batchUpdate(function () {\n      for (let o = 0; o < e.commands.length; o++) {\n        n = e.commands[o];\n        const l = s[n.entity][n.type],\n          d = s[n.entity].get,\n          c = s[n.entity].isExists;\n        if (n.type === a.add) r[l](n.oldValue, n.oldValue.parent, n.oldValue.$local_index);else if (n.type === a.remove) r[c](n.value.id) && r[l](n.value.id);else if (n.type === a.update) {\n          const u = r[d](n.value.id);\n          for (const h in n.value) {\n            let g = !(h.startsWith(\"$\") || h.startsWith(\"_\"));\n            [\"$open\"].indexOf(h) > -1 && (g = !0), g && (u[h] = n.value[h]);\n          }\n          r[l](n.value.id);\n        } else n.type === a.move && (r[l](n.value.id, n.value.$local_index, n.value.parent), r.callEvent(\"onRowDragEnd\", [n.value.id]));\n      }\n    });\n  }\n}\nconst qn = {\n    click_drag: function (t) {\n      t.ext || (t.ext = {});\n      const e = {\n        className: \"gantt_click_drag_rect\",\n        useRequestAnimationFrame: !0,\n        callback: void 0,\n        singleRow: !1\n      };\n      function n() {\n        const i = {\n          viewPort: t.$task_data,\n          ...e\n        };\n        t.ext.clickDrag && t.ext.clickDrag.destructor(), t.ext.clickDrag = new Ln(t);\n        const a = t.config.click_drag;\n        i.render = a.render || e.render, i.className = a.className || e.className, i.callback = a.callback || e.callback, i.viewPort = a.viewPort || t.$task_data, i.useRequestAnimationFrame = a.useRequestAnimationFrame === void 0 ? e.useRequestAnimationFrame : a.useRequestAnimationFrame, i.singleRow = a.singleRow === void 0 ? e.singleRow : a.singleRow;\n        const r = t.$ui.getView(\"timeline\"),\n          s = new Hn(i, t, r);\n        t.ext.clickDrag.attach(s, a.useKey, a.ignore);\n      }\n      t.attachEvent(\"onGanttReady\", () => {\n        t.config.click_drag && n();\n      }), t.attachEvent(\"onGanttLayoutReady\", function () {\n        t.$container && t.config.click_drag && t.attachEvent(\"onGanttRender\", function () {\n          n();\n        }, {\n          once: !0\n        });\n      }), t.attachEvent(\"onDestroy\", () => {\n        t.ext.clickDrag && t.ext.clickDrag.destructor();\n      });\n    },\n    drag_timeline: function (t) {\n      t.ext || (t.ext = {}), t.ext.dragTimeline = {\n        create: () => Yt.create(t),\n        _isDragInProgress: () => Yt._isDragInProgress\n      }, t.config.drag_timeline = {\n        enabled: !0,\n        render: !1\n      };\n    },\n    fullscreen: function (t) {\n      function e() {\n        const c = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;\n        return !(!c || c !== document.body);\n      }\n      function n() {\n        try {\n          return document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;\n        } catch (c) {\n          console.error(\"Fullscreen is not available:\", c);\n        }\n      }\n      t.$services.getService(\"state\").registerProvider(\"fullscreen\", () => n() ? {\n        fullscreen: e()\n      } : void 0);\n      let i = {\n        overflow: null,\n        padding: null,\n        paddingTop: null,\n        paddingRight: null,\n        paddingBottom: null,\n        paddingLeft: null\n      };\n      const a = {\n        width: null,\n        height: null,\n        top: null,\n        left: null,\n        position: null,\n        zIndex: null,\n        modified: !1\n      };\n      let r = null;\n      function s(c, u) {\n        u.width = c.width, u.height = c.height, u.top = c.top, u.left = c.left, u.position = c.position, u.zIndex = c.zIndex;\n      }\n      let o = !1;\n      function l() {\n        if (!t.$container) return;\n        let c;\n        e() ? o && (c = \"onExpand\", function () {\n          const u = t.ext.fullscreen.getFullscreenElement(),\n            h = document.body;\n          s(u.style, a), i = {\n            overflow: h.style.overflow,\n            padding: h.style.padding ? h.style.padding : null,\n            paddingTop: h.style.paddingTop ? h.style.paddingTop : null,\n            paddingRight: h.style.paddingRight ? h.style.paddingRight : null,\n            paddingBottom: h.style.paddingBottom ? h.style.paddingBottom : null,\n            paddingLeft: h.style.paddingLeft ? h.style.paddingLeft : null\n          }, h.style.padding && (h.style.padding = \"0\"), h.style.paddingTop && (h.style.paddingTop = \"0\"), h.style.paddingRight && (h.style.paddingRight = \"0\"), h.style.paddingBottom && (h.style.paddingBottom = \"0\"), h.style.paddingLeft && (h.style.paddingLeft = \"0\"), h.style.overflow = \"hidden\", u.style.width = \"100vw\", u.style.height = \"100vh\", u.style.top = \"0px\", u.style.left = \"0px\", u.style.position = \"absolute\", u.style.zIndex = 1, a.modified = !0, r = function (g) {\n            let f = g.parentNode;\n            const y = [];\n            for (; f && f.style;) y.push({\n              element: f,\n              originalPositioning: f.style.position\n            }), f.style.position = \"static\", f = f.parentNode;\n            return y;\n          }(u);\n        }()) : o && (o = !1, c = \"onCollapse\", function () {\n          const u = t.ext.fullscreen.getFullscreenElement(),\n            h = document.body;\n          a.modified && (i.padding && (h.style.padding = i.padding), i.paddingTop && (h.style.paddingTop = i.paddingTop), i.paddingRight && (h.style.paddingRight = i.paddingRight), i.paddingBottom && (h.style.paddingBottom = i.paddingBottom), i.paddingLeft && (h.style.paddingLeft = i.paddingLeft), h.style.overflow = i.overflow, i = {\n            overflow: null,\n            padding: null,\n            paddingTop: null,\n            paddingRight: null,\n            paddingBottom: null,\n            paddingLeft: null\n          }, s(a, u.style), a.modified = !1), r.forEach(g => {\n            g.element.style.position = g.originalPositioning;\n          }), r = null;\n        }()), setTimeout(() => {\n          t.render();\n        }), setTimeout(() => {\n          t.callEvent(c, [t.ext.fullscreen.getFullscreenElement()]);\n        });\n      }\n      function d() {\n        return !t.$container || !t.ext.fullscreen.getFullscreenElement() ? !0 : n() ? !1 : ((console.warning || console.log)(\"The `fullscreen` feature not being allowed, or full-screen mode not being supported\"), !0);\n      }\n      t.ext.fullscreen = {\n        expand() {\n          if (d() || e() || !t.callEvent(\"onBeforeExpand\", [this.getFullscreenElement()])) return;\n          o = !0;\n          const c = document.body,\n            u = c.webkitRequestFullscreen ? [Element.ALLOW_KEYBOARD_INPUT] : [],\n            h = c.msRequestFullscreen || c.mozRequestFullScreen || c.webkitRequestFullscreen || c.requestFullscreen;\n          h && h.apply(c, u);\n        },\n        collapse() {\n          if (d() || !e() || !t.callEvent(\"onBeforeCollapse\", [this.getFullscreenElement()])) return;\n          const c = document.msExitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen || document.exitFullscreen;\n          c && c.apply(document);\n        },\n        toggle() {\n          d() || (e() ? this.collapse() : this.expand());\n        },\n        getFullscreenElement: () => t.$root\n      }, t.expand = function () {\n        t.ext.fullscreen.expand();\n      }, t.collapse = function () {\n        t.ext.fullscreen.collapse();\n      }, t.attachEvent(\"onGanttReady\", function () {\n        t.event(document, \"webkitfullscreenchange\", l), t.event(document, \"mozfullscreenchange\", l), t.event(document, \"MSFullscreenChange\", l), t.event(document, \"fullscreenChange\", l), t.event(document, \"fullscreenchange\", l);\n      });\n    },\n    keyboard_navigation: function (t) {\n      (function (e) {\n        e.config.keyboard_navigation = !0, e.config.keyboard_navigation_cells = !1, e.$keyboardNavigation = {}, e._compose = function () {\n          for (var n = Array.prototype.slice.call(arguments, 0), i = {}, a = 0; a < n.length; a++) {\n            var r = n[a];\n            for (var s in typeof r == \"function\" && (r = new r()), r) i[s] = r[s];\n          }\n          return i;\n        }, function (n) {\n          n.$keyboardNavigation.shortcuts = {\n            createCommand: function () {\n              return {\n                modifiers: {\n                  shift: !1,\n                  alt: !1,\n                  ctrl: !1,\n                  meta: !1\n                },\n                keyCode: null\n              };\n            },\n            parse: function (i) {\n              for (var a = [], r = this.getExpressions(this.trim(i)), s = 0; s < r.length; s++) {\n                for (var o = this.getWords(r[s]), l = this.createCommand(), d = 0; d < o.length; d++) this.commandKeys[o[d]] ? l.modifiers[o[d]] = !0 : this.specialKeys[o[d]] ? l.keyCode = this.specialKeys[o[d]] : l.keyCode = o[d].charCodeAt(0);\n                a.push(l);\n              }\n              return a;\n            },\n            getCommandFromEvent: function (i) {\n              var a = this.createCommand();\n              a.modifiers.shift = !!i.shiftKey, a.modifiers.alt = !!i.altKey, a.modifiers.ctrl = !!i.ctrlKey, a.modifiers.meta = !!i.metaKey, a.keyCode = i.which || i.keyCode, a.keyCode >= 96 && a.keyCode <= 105 && (a.keyCode -= 48);\n              var r = String.fromCharCode(a.keyCode);\n              return r && (a.keyCode = r.toLowerCase().charCodeAt(0)), a;\n            },\n            getHashFromEvent: function (i) {\n              return this.getHash(this.getCommandFromEvent(i));\n            },\n            getHash: function (i) {\n              var a = [];\n              for (var r in i.modifiers) i.modifiers[r] && a.push(r);\n              return a.push(i.keyCode), a.join(this.junctionChar);\n            },\n            getExpressions: function (i) {\n              return i.split(this.junctionChar);\n            },\n            getWords: function (i) {\n              return i.split(this.combinationChar);\n            },\n            trim: function (i) {\n              return i.replace(/\\s/g, \"\");\n            },\n            junctionChar: \",\",\n            combinationChar: \"+\",\n            commandKeys: {\n              shift: 16,\n              alt: 18,\n              ctrl: 17,\n              meta: !0\n            },\n            specialKeys: {\n              backspace: 8,\n              tab: 9,\n              enter: 13,\n              esc: 27,\n              space: 32,\n              up: 38,\n              down: 40,\n              left: 37,\n              right: 39,\n              home: 36,\n              end: 35,\n              pageup: 33,\n              pagedown: 34,\n              delete: 46,\n              insert: 45,\n              plus: 107,\n              f1: 112,\n              f2: 113,\n              f3: 114,\n              f4: 115,\n              f5: 116,\n              f6: 117,\n              f7: 118,\n              f8: 119,\n              f9: 120,\n              f10: 121,\n              f11: 122,\n              f12: 123\n            }\n          };\n        }(e), function (n) {\n          n.$keyboardNavigation.EventHandler = {\n            _handlers: null,\n            findHandler: function (i) {\n              this._handlers || (this._handlers = {});\n              var a = n.$keyboardNavigation.shortcuts.getHash(i);\n              return this._handlers[a];\n            },\n            doAction: function (i, a) {\n              var r = this.findHandler(i);\n              if (r) {\n                if (n.$keyboardNavigation.facade.callEvent(\"onBeforeAction\", [i, a]) === !1) return;\n                r.call(this, a), a.preventDefault ? a.preventDefault() : a.returnValue = !1;\n              }\n            },\n            bind: function (i, a) {\n              this._handlers || (this._handlers = {});\n              for (var r = n.$keyboardNavigation.shortcuts, s = r.parse(i), o = 0; o < s.length; o++) this._handlers[r.getHash(s[o])] = a;\n            },\n            unbind: function (i) {\n              for (var a = n.$keyboardNavigation.shortcuts, r = a.parse(i), s = 0; s < r.length; s++) this._handlers[a.getHash(r[s])] && delete this._handlers[a.getHash(r[s])];\n            },\n            bindAll: function (i) {\n              for (var a in i) this.bind(a, i[a]);\n            },\n            initKeys: function () {\n              this._handlers || (this._handlers = {}), this.keys && this.bindAll(this.keys);\n            }\n          };\n        }(e), function (n) {\n          n.$keyboardNavigation.getFocusableNodes = Lt, n.$keyboardNavigation.trapFocus = function (i, a) {\n            if (a.keyCode != 9) return !1;\n            for (var r = n.$keyboardNavigation.getFocusableNodes(i), s = ge(), o = -1, l = 0; l < r.length; l++) if (r[l] == s) {\n              o = l;\n              break;\n            }\n            if (a.shiftKey) {\n              if (o <= 0) {\n                var d = r[r.length - 1];\n                if (d) return d.focus(), a.preventDefault(), !0;\n              }\n            } else if (o >= r.length - 1) {\n              var c = r[0];\n              if (c) return c.focus(), a.preventDefault(), !0;\n            }\n            return !1;\n          };\n        }(e), function (n) {\n          n.$keyboardNavigation.GanttNode = function () {}, n.$keyboardNavigation.GanttNode.prototype = n._compose(n.$keyboardNavigation.EventHandler, {\n            focus: function () {\n              n.focus();\n            },\n            blur: function () {},\n            isEnabled: function () {\n              return n.$container.hasAttribute(\"tabindex\");\n            },\n            scrollHorizontal: function (i) {\n              var a = n.dateFromPos(n.getScrollState().x),\n                r = n.getScale(),\n                s = i < 0 ? -r.step : r.step;\n              a = n.date.add(a, s, r.unit), n.scrollTo(n.posFromDate(a));\n            },\n            scrollVertical: function (i) {\n              var a = n.getScrollState().y,\n                r = n.config.row_height;\n              n.scrollTo(null, a + (i < 0 ? -1 : 1) * r);\n            },\n            keys: {\n              \"alt+left\": function (i) {\n                this.scrollHorizontal(-1);\n              },\n              \"alt+right\": function (i) {\n                this.scrollHorizontal(1);\n              },\n              \"alt+up\": function (i) {\n                this.scrollVertical(-1);\n              },\n              \"alt+down\": function (i) {\n                this.scrollVertical(1);\n              },\n              \"ctrl+z\": function () {\n                n.undo && n.undo();\n              },\n              \"ctrl+r\": function () {\n                n.redo && n.redo();\n              }\n            }\n          }), n.$keyboardNavigation.GanttNode.prototype.bindAll(n.$keyboardNavigation.GanttNode.prototype.keys);\n        }(e), function (n) {\n          n.$keyboardNavigation.KeyNavNode = function () {}, n.$keyboardNavigation.KeyNavNode.prototype = n._compose(n.$keyboardNavigation.EventHandler, {\n            isValid: function () {\n              return !0;\n            },\n            fallback: function () {\n              return null;\n            },\n            moveTo: function (i) {\n              n.$keyboardNavigation.dispatcher.setActiveNode(i);\n            },\n            compareTo: function (i) {\n              if (!i) return !1;\n              for (var a in this) {\n                if (!!this[a] != !!i[a]) return !1;\n                var r = !(!this[a] || !this[a].toString),\n                  s = !(!i[a] || !i[a].toString);\n                if (s != r) return !1;\n                if (s && r) {\n                  if (i[a].toString() != this[a].toString()) return !1;\n                } else if (i[a] != this[a]) return !1;\n              }\n              return !0;\n            },\n            getNode: function () {},\n            focus: function () {\n              var i = this.getNode();\n              if (i) {\n                var a = n.$keyboardNavigation.facade;\n                a.callEvent(\"onBeforeFocus\", [i]) !== !1 && i && (i.setAttribute(\"tabindex\", \"-1\"), i.$eventAttached || (i.$eventAttached = !0, n.event(i, \"focus\", function (r) {\n                  return r.preventDefault(), !1;\n                }, !1)), n.utils.dom.isChildOf(document.activeElement, i) && (i = document.activeElement), i.focus && i.focus(), a.callEvent(\"onFocus\", [this.getNode()]));\n              }\n            },\n            blur: function () {\n              var i = this.getNode();\n              i && (n.$keyboardNavigation.facade.callEvent(\"onBlur\", [i]), i.setAttribute(\"tabindex\", \"-1\"));\n            }\n          });\n        }(e), function (n) {\n          n.$keyboardNavigation.HeaderCell = function (i) {\n            this.index = i || 0;\n          }, n.$keyboardNavigation.HeaderCell.prototype = n._compose(n.$keyboardNavigation.KeyNavNode, {\n            _handlers: null,\n            isValid: function () {\n              return !(!n.config.show_grid && n.getVisibleTaskCount() || !n.getGridColumns()[this.index] && n.getVisibleTaskCount());\n            },\n            fallback: function () {\n              if (!n.config.show_grid) return n.getVisibleTaskCount() ? new n.$keyboardNavigation.TaskRow() : null;\n              for (var i = n.getGridColumns(), a = this.index; a >= 0 && !i[a];) a--;\n              return i[a] ? new n.$keyboardNavigation.HeaderCell(a) : null;\n            },\n            fromDomElement: function (i) {\n              var a = pt(i, \"gantt_grid_head_cell\");\n              if (a) {\n                for (var r = 0; a && a.previousSibling;) a = a.previousSibling, r += 1;\n                return new n.$keyboardNavigation.HeaderCell(r);\n              }\n              return null;\n            },\n            getNode: function () {\n              const i = n.$grid_scale;\n              return i ? i.childNodes[this.index] : null;\n            },\n            keys: {\n              left: function () {\n                this.index > 0 && this.moveTo(new n.$keyboardNavigation.HeaderCell(this.index - 1));\n              },\n              right: function () {\n                var i = n.getGridColumns();\n                this.index < i.length - 1 && this.moveTo(new n.$keyboardNavigation.HeaderCell(this.index + 1));\n              },\n              down: function () {\n                var i,\n                  a = n.getChildren(n.config.root_id);\n                n.isTaskExists(a[0]) && (i = a[0]), i && (n.config.keyboard_navigation_cells ? this.moveTo(new n.$keyboardNavigation.TaskCell(i, this.index)) : this.moveTo(new n.$keyboardNavigation.TaskRow(i)));\n              },\n              end: function () {\n                var i = n.getGridColumns();\n                this.moveTo(new n.$keyboardNavigation.HeaderCell(i.length - 1));\n              },\n              home: function () {\n                this.moveTo(new n.$keyboardNavigation.HeaderCell(0));\n              },\n              \"enter, space\": function () {\n                ge().click();\n              },\n              \"ctrl+enter\": function () {\n                n.isReadonly(this) || n.createTask({}, this.taskId);\n              }\n            }\n          }), n.$keyboardNavigation.HeaderCell.prototype.bindAll(n.$keyboardNavigation.HeaderCell.prototype.keys);\n        }(e), function (n) {\n          n.$keyboardNavigation.TaskRow = function (i) {\n            if (!i) {\n              var a = n.getChildren(n.config.root_id);\n              a[0] && (i = a[0]);\n            }\n            this.taskId = i, n.isTaskExists(this.taskId) && (this.index = n.getTaskIndex(this.taskId), this.globalIndex = n.getGlobalTaskIndex(this.taskId), this.splitItem = !!n.getTask(this.taskId).$split_subtask, this.parentId = n.getParent(this.taskId));\n          }, n.$keyboardNavigation.TaskRow.prototype = n._compose(n.$keyboardNavigation.KeyNavNode, {\n            _handlers: null,\n            isValid: function () {\n              return n.isTaskExists(this.taskId) && n.getTaskIndex(this.taskId) > -1;\n            },\n            fallback: function () {\n              if (!n.getVisibleTaskCount()) {\n                var i = new n.$keyboardNavigation.HeaderCell();\n                return i.isValid() ? i : null;\n              }\n              if (this.splitItem) return new n.$keyboardNavigation.TaskRow(this.parentId);\n              var a = -1;\n              if (n.getTaskByIndex(this.globalIndex - 1)) a = this.globalIndex - 1;else if (n.getTaskByIndex(this.globalIndex + 1)) a = this.globalIndex + 1;else for (var r = this.globalIndex; r >= 0;) {\n                if (n.getTaskByIndex(r)) {\n                  a = r;\n                  break;\n                }\n                r--;\n              }\n              return a > -1 ? new n.$keyboardNavigation.TaskRow(n.getTaskByIndex(a).id) : void 0;\n            },\n            fromDomElement: function (i) {\n              if (n.config.keyboard_navigation_cells) return null;\n              var a = n.locate(i);\n              return n.isTaskExists(a) ? new n.$keyboardNavigation.TaskRow(a) : null;\n            },\n            getNode: function () {\n              if (n.isTaskExists(this.taskId) && n.isTaskVisible(this.taskId)) return n.config.show_grid ? n.$grid.querySelector(`.gantt_row[${n.config.task_attribute}=\"${String(this.taskId).replaceAll('\"', '\\\\\"')}\"]`) : n.getTaskNode(this.taskId);\n            },\n            focus: function (i) {\n              if (!i) {\n                const a = n.getTaskPosition(n.getTask(this.taskId)),\n                  r = n.getTaskHeight(this.taskId),\n                  s = n.getScrollState();\n                let o, l;\n                o = n.$task ? n.$task.offsetWidth : s.inner_width, l = n.$grid_data || n.$task_data ? (n.$grid_data || n.$task_data).offsetHeight : s.inner_height;\n                const d = n.config.show_chart && n.$ui.getView(\"timeline\");\n                a.top < s.y || a.top + r > s.y + l ? n.scrollTo(null, a.top - 20) : n.config.scroll_on_click && d && (a.left > s.x + o ? n.scrollTo(a.left - n.config.task_scroll_offset) : a.left + a.width < s.x && n.scrollTo(a.left + a.width - n.config.task_scroll_offset));\n              }\n              n.$keyboardNavigation.KeyNavNode.prototype.focus.apply(this, [i]), function () {\n                var a = n.$ui.getView(\"grid\");\n                if (a && a.$grid_data) {\n                  var r = parseInt(a.$grid.scrollLeft),\n                    s = parseInt(a.$grid_data.scrollTop),\n                    o = a.$config.scrollX;\n                  if (o && a.$config.scrollable) {\n                    var l = n.$ui.getView(o);\n                    l && l.scrollTo(r, s);\n                  }\n                  var d = a.$config.scrollY;\n                  if (d) {\n                    var c = n.$ui.getView(d);\n                    c && c.scrollTo(r, s);\n                  }\n                }\n              }();\n            },\n            keys: {\n              pagedown: function () {\n                n.getVisibleTaskCount() && this.moveTo(new n.$keyboardNavigation.TaskRow(n.getTaskByIndex(n.getVisibleTaskCount() - 1).id));\n              },\n              pageup: function () {\n                n.getVisibleTaskCount() && this.moveTo(new n.$keyboardNavigation.TaskRow(n.getTaskByIndex(0).id));\n              },\n              up: function () {\n                var i = null,\n                  a = n.getPrev(this.taskId);\n                i = n.isTaskExists(a) ? new n.$keyboardNavigation.TaskRow(a) : new n.$keyboardNavigation.HeaderCell(), this.moveTo(i);\n              },\n              down: function () {\n                var i = n.getNext(this.taskId);\n                n.isTaskExists(i) && this.moveTo(new n.$keyboardNavigation.TaskRow(i));\n              },\n              \"shift+down\": function () {\n                n.hasChild(this.taskId) && !n.getTask(this.taskId).$open && n.open(this.taskId);\n              },\n              \"shift+up\": function () {\n                n.hasChild(this.taskId) && n.getTask(this.taskId).$open && n.close(this.taskId);\n              },\n              \"shift+right\": function () {\n                if (!n.isReadonly(this)) {\n                  var i = n.getPrevSibling(this.taskId);\n                  n.isTaskExists(i) && !n.isChildOf(this.taskId, i) && (n.getTask(i).$open = !0, n.moveTask(this.taskId, -1, i) !== !1 && n.updateTask(this.taskId));\n                }\n              },\n              \"shift+left\": function () {\n                if (!n.isReadonly(this)) {\n                  var i = n.getParent(this.taskId);\n                  n.isTaskExists(i) && n.moveTask(this.taskId, n.getTaskIndex(i) + 1, n.getParent(i)) !== !1 && n.updateTask(this.taskId);\n                }\n              },\n              space: function (i) {\n                n.isSelectedTask(this.taskId) ? n.unselectTask(this.taskId) : n.selectTask(this.taskId);\n              },\n              \"ctrl+left\": function (i) {\n                n.close(this.taskId);\n              },\n              \"ctrl+right\": function (i) {\n                n.open(this.taskId);\n              },\n              delete: function (i) {\n                n.isReadonly(this) || n.$click.buttons.delete(this.taskId);\n              },\n              enter: function () {\n                n.isReadonly(this) || n.showLightbox(this.taskId);\n              },\n              \"ctrl+enter\": function () {\n                n.isReadonly(this) || n.createTask({}, this.taskId);\n              }\n            }\n          }), n.$keyboardNavigation.TaskRow.prototype.bindAll(n.$keyboardNavigation.TaskRow.prototype.keys);\n        }(e), function (n) {\n          n.$keyboardNavigation.TaskCell = function (i, a) {\n            if (!(i = at(i, n.config.root_id))) {\n              var r = n.getChildren(n.config.root_id);\n              r[0] && (i = r[0]);\n            }\n            this.taskId = i, this.columnIndex = a || 0, n.isTaskExists(this.taskId) && (this.index = n.getTaskIndex(this.taskId), this.globalIndex = n.getGlobalTaskIndex(this.taskId));\n          }, n.$keyboardNavigation.TaskCell.prototype = n._compose(n.$keyboardNavigation.TaskRow, {\n            _handlers: null,\n            isValid: function () {\n              return n.$keyboardNavigation.TaskRow.prototype.isValid.call(this) && !!n.getGridColumns()[this.columnIndex];\n            },\n            fallback: function () {\n              var i = n.$keyboardNavigation.TaskRow.prototype.fallback.call(this),\n                a = i;\n              if (i instanceof n.$keyboardNavigation.TaskRow) {\n                for (var r = n.getGridColumns(), s = this.columnIndex; s >= 0 && !r[s];) s--;\n                r[s] && (a = new n.$keyboardNavigation.TaskCell(i.taskId, s));\n              }\n              return a;\n            },\n            fromDomElement: function (i) {\n              if (!n.config.keyboard_navigation_cells) return null;\n              var a = n.locate(i);\n              if (n.isTaskExists(a)) {\n                var r = 0,\n                  s = et(i, \"data-column-index\");\n                return s && (r = 1 * s.getAttribute(\"data-column-index\")), new n.$keyboardNavigation.TaskCell(a, r);\n              }\n              return null;\n            },\n            getNode: function () {\n              if (n.isTaskExists(this.taskId) && (n.isTaskVisible(this.taskId) || n.config.show_tasks_outside_timescale)) {\n                if (n.config.show_grid && n.$grid) {\n                  var i = n.$grid.querySelector(\".gantt_row[\" + n.config.task_attribute + \"='\" + this.taskId + \"']\");\n                  return i ? i.querySelector(\"[data-column-index='\" + this.columnIndex + \"']\") : null;\n                }\n                return n.getTaskNode(this.taskId);\n              }\n            },\n            keys: {\n              up: function () {\n                var i = null,\n                  a = n.getPrev(this.taskId);\n                i = n.isTaskExists(a) ? new n.$keyboardNavigation.TaskCell(a, this.columnIndex) : new n.$keyboardNavigation.HeaderCell(this.columnIndex), this.moveTo(i);\n              },\n              down: function () {\n                var i = n.getNext(this.taskId);\n                n.isTaskExists(i) && this.moveTo(new n.$keyboardNavigation.TaskCell(i, this.columnIndex));\n              },\n              left: function () {\n                this.columnIndex > 0 && this.moveTo(new n.$keyboardNavigation.TaskCell(this.taskId, this.columnIndex - 1));\n              },\n              right: function () {\n                var i = n.getGridColumns();\n                this.columnIndex < i.length - 1 && this.moveTo(new n.$keyboardNavigation.TaskCell(this.taskId, this.columnIndex + 1));\n              },\n              end: function () {\n                var i = n.getGridColumns();\n                this.moveTo(new n.$keyboardNavigation.TaskCell(this.taskId, i.length - 1));\n              },\n              home: function () {\n                this.moveTo(new n.$keyboardNavigation.TaskCell(this.taskId, 0));\n              },\n              pagedown: function () {\n                n.getVisibleTaskCount() && this.moveTo(new n.$keyboardNavigation.TaskCell(n.getTaskByIndex(n.getVisibleTaskCount() - 1).id, this.columnIndex));\n              },\n              pageup: function () {\n                n.getVisibleTaskCount() && this.moveTo(new n.$keyboardNavigation.TaskCell(n.getTaskByIndex(0).id, this.columnIndex));\n              }\n            }\n          }), n.$keyboardNavigation.TaskCell.prototype.bindAll(n.$keyboardNavigation.TaskRow.prototype.keys), n.$keyboardNavigation.TaskCell.prototype.bindAll(n.$keyboardNavigation.TaskCell.prototype.keys);\n        }(e), On(e), function (n) {\n          n.$keyboardNavigation.dispatcher = {\n            isActive: !1,\n            activeNode: null,\n            globalNode: new n.$keyboardNavigation.GanttNode(),\n            enable: function () {\n              this.isActive = !0, this.setActiveNode(this.getActiveNode());\n            },\n            disable: function () {\n              this.isActive = !1;\n            },\n            isEnabled: function () {\n              return !!this.isActive;\n            },\n            getDefaultNode: function () {\n              var i;\n              return (i = n.config.keyboard_navigation_cells ? new n.$keyboardNavigation.TaskCell() : new n.$keyboardNavigation.TaskRow()).isValid() || (i = i.fallback()), i;\n            },\n            setDefaultNode: function () {\n              this.setActiveNode(this.getDefaultNode());\n            },\n            getActiveNode: function () {\n              var i = this.activeNode;\n              return i && !i.isValid() && (i = i.fallback()), i;\n            },\n            fromDomElement: function (i) {\n              for (var a = [n.$keyboardNavigation.TaskRow, n.$keyboardNavigation.TaskCell, n.$keyboardNavigation.HeaderCell], r = 0; r < a.length; r++) if (a[r].prototype.fromDomElement) {\n                var s = a[r].prototype.fromDomElement(i);\n                if (s) return s;\n              }\n              return null;\n            },\n            focusGlobalNode: function () {\n              this.blurNode(this.globalNode), this.focusNode(this.globalNode);\n            },\n            setActiveNode: function (i) {\n              var a = !0;\n              this.activeNode && this.activeNode.compareTo(i) && (a = !1), this.isEnabled() && (a && this.blurNode(this.activeNode), this.activeNode = i, this.focusNode(this.activeNode, !a));\n            },\n            focusNode: function (i, a) {\n              i && i.focus && i.focus(a);\n            },\n            blurNode: function (i) {\n              i && i.blur && i.blur();\n            },\n            keyDownHandler: function (i) {\n              if (!n.$keyboardNavigation.isModal() && this.isEnabled() && !i.defaultPrevented) {\n                var a = this.globalNode,\n                  r = n.$keyboardNavigation.shortcuts.getCommandFromEvent(i),\n                  s = this.getActiveNode();\n                n.$keyboardNavigation.facade.callEvent(\"onKeyDown\", [r, i]) !== !1 && (s ? s.findHandler(r) ? s.doAction(r, i) : a.findHandler(r) && a.doAction(r, i) : this.setDefaultNode());\n              }\n            },\n            _timeout: null,\n            awaitsFocus: function () {\n              return this._timeout !== null;\n            },\n            delay: function (i, a) {\n              clearTimeout(this._timeout), this._timeout = setTimeout(n.bind(function () {\n                this._timeout = null, i();\n              }, this), a || 1);\n            },\n            clearDelay: function () {\n              clearTimeout(this._timeout);\n            }\n          };\n        }(e), function () {\n          var n = e.$keyboardNavigation.dispatcher;\n          n.isTaskFocused = function (v) {\n            var b = n.activeNode;\n            return (b instanceof e.$keyboardNavigation.TaskRow || b instanceof e.$keyboardNavigation.TaskCell) && b.taskId == v;\n          };\n          var i = function (v) {\n              if (e.config.keyboard_navigation && (e.config.keyboard_navigation_cells || !s(v)) && !o(v) && !function (b) {\n                return !!ct(b.target, \".gantt_cal_light\");\n              }(v)) return n.keyDownHandler(v);\n            },\n            a = function (v) {\n              if (n.$preventDefault) return v.preventDefault(), e.$container.blur(), !1;\n              n.awaitsFocus() || n.focusGlobalNode();\n            },\n            r = function () {\n              if (!n.isEnabled()) return;\n              const v = !Y(document.activeElement, e.$container) && document.activeElement.localName != \"body\";\n              var b = n.getActiveNode();\n              if (b && !v) {\n                var _,\n                  m,\n                  p = b.getNode();\n                p && p.parentNode && (_ = p.parentNode.scrollTop, m = p.parentNode.scrollLeft), b.focus(!0), p && p.parentNode && (p.parentNode.scrollTop = _, p.parentNode.scrollLeft = m);\n              }\n            };\n          function s(v) {\n            return !!ct(v.target, \".gantt_grid_editor_placeholder\");\n          }\n          function o(v) {\n            return !!ct(v.target, \".no_keyboard_navigation\");\n          }\n          function l(v) {\n            if (!e.config.keyboard_navigation || !e.config.keyboard_navigation_cells && s(v)) return !0;\n            if (!o(v)) {\n              var b,\n                _ = n.fromDomElement(v);\n              if (_ && (n.activeNode instanceof e.$keyboardNavigation.TaskCell && Y(v.target, e.$task) && (_ = new e.$keyboardNavigation.TaskCell(_.taskId, n.activeNode.columnIndex)), b = _, e.config.show_grid && e.$ui.getView(\"grid\") && e.config.keyboard_navigation_cells)) {\n                const m = v.target.classList.contains(\"gantt_row\"),\n                  p = v.target.closest(\".gantt_task_line\"),\n                  k = e.utils.dom.getNodePosition(e.$grid).x,\n                  x = k + e.$grid.offsetWidth,\n                  $ = e.utils.dom.getNodePosition(document.activeElement).x;\n                if (m || p && ($ < k || x < $)) {\n                  let w = e.$grid.scrollLeft;\n                  const S = w + e.$grid.offsetWidth;\n                  let T = 0;\n                  m && (w = e.utils.dom.getRelativeEventPosition(v, e.$grid).x);\n                  for (let E = 0; E < e.config.columns.length; E++) {\n                    const C = e.config.columns[E];\n                    if (!C.hide && (T += C.width, w < T)) {\n                      S < T && (T -= C.width), b.columnIndex = E;\n                      break;\n                    }\n                  }\n                }\n              }\n              b ? n.isEnabled() ? n.delay(function () {\n                n.setActiveNode(b);\n              }) : n.activeNode = b : (n.$preventDefault = !0, setTimeout(function () {\n                n.$preventDefault = !1;\n              }, 300));\n            }\n          }\n          e.attachEvent(\"onDataRender\", function () {\n            e.config.keyboard_navigation && r();\n          }), e.attachEvent(\"onGanttRender\", function () {\n            e.$root && (e.eventRemove(e.$root, \"keydown\", i), e.eventRemove(e.$container, \"focus\", a), e.eventRemove(e.$container, \"mousedown\", l), e.config.keyboard_navigation ? (e.event(e.$root, \"keydown\", i), e.event(e.$container, \"focus\", a), e.event(e.$container, \"mousedown\", l), e.$container.setAttribute(\"tabindex\", \"0\")) : e.$container.removeAttribute(\"tabindex\"));\n          });\n          var d = e.attachEvent(\"onGanttReady\", function () {\n            if (e.detachEvent(d), e.$data.tasksStore.attachEvent(\"onStoreUpdated\", function (b) {\n              if (e.config.keyboard_navigation && n.isEnabled()) {\n                const _ = n.getActiveNode(),\n                  m = e.$ui.getView(\"grid\");\n                if (!m || !m.$grid_data) return;\n                const p = m.getItemTop(b),\n                  k = m.$grid_data.scrollTop,\n                  x = k + m.$grid_data.getBoundingClientRect().height;\n                _ && _.taskId == b && k <= p && x >= p && r();\n              }\n            }), e._smart_render) {\n              var v = e._smart_render._redrawTasks;\n              e._smart_render._redrawTasks = function (b, _) {\n                if (e.config.keyboard_navigation && n.isEnabled()) {\n                  var m = n.getActiveNode();\n                  if (m && m.taskId !== void 0) {\n                    for (var p = !1, k = 0; k < _.length; k++) if (_[k].id == m.taskId && _[k].start_date) {\n                      p = !0;\n                      break;\n                    }\n                    p || _.push(e.getTask(m.taskId));\n                  }\n                }\n                return v.apply(this, arguments);\n              };\n            }\n          });\n          let c = null,\n            u = !1;\n          e.attachEvent(\"onTaskCreated\", function (v) {\n            return c = v.id, !0;\n          }), e.attachEvent(\"onAfterTaskAdd\", function (v, b) {\n            if (!e.config.keyboard_navigation) return !0;\n            if (n.isEnabled()) {\n              if (v == c && (u = !0, setTimeout(() => {\n                u = !1, c = null;\n              })), u && b.type == e.config.types.placeholder) return;\n              var _ = 0,\n                m = n.activeNode;\n              m instanceof e.$keyboardNavigation.TaskCell && (_ = m.columnIndex);\n              var p = e.config.keyboard_navigation_cells ? e.$keyboardNavigation.TaskCell : e.$keyboardNavigation.TaskRow;\n              b.type == e.config.types.placeholder && e.config.placeholder_task.focusOnCreate === !1 || n.setActiveNode(new p(v, _));\n            }\n          }), e.attachEvent(\"onTaskIdChange\", function (v, b) {\n            if (!e.config.keyboard_navigation) return !0;\n            var _ = n.activeNode;\n            return n.isTaskFocused(v) && (_.taskId = b), !0;\n          });\n          var h = setInterval(function () {\n            e.config.keyboard_navigation && (n.isEnabled() || n.enable());\n          }, 500);\n          function g(v) {\n            var b = {\n              gantt: e.$keyboardNavigation.GanttNode,\n              headerCell: e.$keyboardNavigation.HeaderCell,\n              taskRow: e.$keyboardNavigation.TaskRow,\n              taskCell: e.$keyboardNavigation.TaskCell\n            };\n            return b[v] || b.gantt;\n          }\n          function f(v) {\n            for (var b = e.getGridColumns(), _ = 0; _ < b.length; _++) if (b[_].name == v) return _;\n            return 0;\n          }\n          e.attachEvent(\"onDestroy\", function () {\n            clearInterval(h);\n          });\n          var y = {};\n          ot(y), e.mixin(y, {\n            addShortcut: function (v, b, _) {\n              var m = g(_);\n              m && m.prototype.bind(v, b);\n            },\n            getShortcutHandler: function (v, b) {\n              var _ = e.$keyboardNavigation.shortcuts.parse(v);\n              if (_.length) return y.getCommandHandler(_[0], b);\n            },\n            getCommandHandler: function (v, b) {\n              var _ = g(b);\n              if (_ && v) return _.prototype.findHandler(v);\n            },\n            removeShortcut: function (v, b) {\n              var _ = g(b);\n              _ && _.prototype.unbind(v);\n            },\n            focus: function (v) {\n              var b,\n                _ = v ? v.type : null,\n                m = g(_);\n              switch (_) {\n                case \"taskCell\":\n                  b = new m(v.id, f(v.column));\n                  break;\n                case \"taskRow\":\n                  b = new m(v.id);\n                  break;\n                case \"headerCell\":\n                  b = new m(f(v.column));\n              }\n              n.delay(function () {\n                b ? n.setActiveNode(b) : (n.enable(), n.getActiveNode() ? n.awaitsFocus() || n.enable() : n.setDefaultNode());\n              });\n            },\n            getActiveNode: function () {\n              if (n.isEnabled()) {\n                var v = n.getActiveNode(),\n                  b = (m = v) instanceof e.$keyboardNavigation.GanttNode ? \"gantt\" : m instanceof e.$keyboardNavigation.HeaderCell ? \"headerCell\" : m instanceof e.$keyboardNavigation.TaskRow ? \"taskRow\" : m instanceof e.$keyboardNavigation.TaskCell ? \"taskCell\" : null,\n                  _ = e.getGridColumns();\n                switch (b) {\n                  case \"taskCell\":\n                    return {\n                      type: \"taskCell\",\n                      id: v.taskId,\n                      column: _[v.columnIndex].name\n                    };\n                  case \"taskRow\":\n                    return {\n                      type: \"taskRow\",\n                      id: v.taskId\n                    };\n                  case \"headerCell\":\n                    return {\n                      type: \"headerCell\",\n                      column: _[v.index].name\n                    };\n                }\n              }\n              var m;\n              return null;\n            }\n          }), e.$keyboardNavigation.facade = y, e.ext.keyboardNavigation = y, e.focus = function () {\n            y.focus();\n          }, e.addShortcut = y.addShortcut, e.getShortcutHandler = y.getShortcutHandler, e.removeShortcut = y.removeShortcut;\n        }();\n      })(t);\n    },\n    quick_info: function (t) {\n      t.ext || (t.ext = {}), t.ext.quickInfo = new Bn(t), t.config.quickinfo_buttons = [\"icon_edit\", \"icon_delete\"], t.config.quick_info_detached = !0, t.config.show_quick_info = !0, t.templates.quick_info_title = function (a, r, s) {\n        return s.text.substr(0, 50);\n      }, t.templates.quick_info_content = function (a, r, s) {\n        return s.details || s.text;\n      }, t.templates.quick_info_date = function (a, r, s) {\n        return t.templates.task_time(a, r, s);\n      }, t.templates.quick_info_class = function (a, r, s) {\n        return \"\";\n      }, t.attachEvent(\"onTaskClick\", function (a, r) {\n        return t.utils.dom.closest(r.target, \".gantt_add\") || setTimeout(function () {\n          t.ext.quickInfo.show(a);\n        }, 0), !0;\n      });\n      const e = [\"onViewChange\", \"onLightbox\", \"onBeforeTaskDelete\", \"onBeforeDrag\"],\n        n = function () {\n          return t.ext.quickInfo.hide(), !0;\n        };\n      for (let a = 0; a < e.length; a++) t.attachEvent(e[a], n);\n      function i() {\n        return t.ext.quickInfo.hide(), t.ext.quickInfo._quickInfoBox = null, !0;\n      }\n      t.attachEvent(\"onEmptyClick\", function (a) {\n        let r = !0;\n        const s = document.querySelector(\".gantt_cal_quick_info\");\n        s && t.utils.dom.isChildOf(a.target, s) && (r = !1), r && n();\n      }), t.attachEvent(\"onGanttReady\", i), t.attachEvent(\"onDestroy\", i), t.event(window, \"keydown\", function (a) {\n        a.keyCode === 27 && t.ext.quickInfo.hide();\n      }), t.showQuickInfo = function () {\n        t.ext.quickInfo.show.apply(t.ext.quickInfo, arguments);\n      }, t.hideQuickInfo = function () {\n        t.ext.quickInfo.hide.apply(t.ext.quickInfo, arguments);\n      };\n    },\n    tooltip: function (t) {\n      t.config.tooltip_timeout = 30, t.config.tooltip_offset_y = 20, t.config.tooltip_offset_x = 10, t.config.tooltip_hide_timeout = 30;\n      const e = new Fn(t);\n      t.ext.tooltips = e, t.attachEvent(\"onGanttReady\", function () {\n        t.$root && e.tooltipFor({\n          selector: \"[\" + t.config.task_attribute + \"]:not(.gantt_task_row)\",\n          html: n => {\n            if (t.config.touch && !t.config.touch_tooltip) return;\n            const i = t.locate(n);\n            if (t.isTaskExists(i)) {\n              const a = t.getTask(i);\n              return t.templates.tooltip_text(a.start_date, a.end_date, a);\n            }\n            return null;\n          },\n          global: !1\n        });\n      }), t.attachEvent(\"onDestroy\", function () {\n        e.destructor();\n      }), t.attachEvent(\"onLightbox\", function () {\n        e.hideTooltip();\n      }), t.attachEvent(\"onBeforeTooltip\", function () {\n        if (t.getState().link_source_id) return !1;\n      }), t.attachEvent(\"onGanttScroll\", function () {\n        e.hideTooltip();\n      });\n    },\n    undo: function (t) {\n      const e = new Un(t),\n        n = new Vn(e, t);\n      function i(c, u) {\n        return String(c) === String(u);\n      }\n      function a(c, u, h) {\n        c && (i(c.id, u) && (c.id = h), i(c.parent, u) && (c.parent = h));\n      }\n      function r(c, u, h) {\n        a(c.value, u, h), a(c.oldValue, u, h);\n      }\n      function s(c, u, h) {\n        c && (i(c.source, u) && (c.source = h), i(c.target, u) && (c.target = h));\n      }\n      function o(c, u, h) {\n        s(c.value, u, h), s(c.oldValue, u, h);\n      }\n      function l(c, u, h) {\n        const g = e;\n        for (let f = 0; f < c.length; f++) {\n          const y = c[f];\n          for (let v = 0; v < y.commands.length; v++) y.commands[v].entity === g.command.entity.task ? r(y.commands[v], u, h) : y.commands[v].entity === g.command.entity.link && o(y.commands[v], u, h);\n        }\n      }\n      function d(c, u, h) {\n        const g = e;\n        for (let f = 0; f < c.length; f++) {\n          const y = c[f];\n          for (let v = 0; v < y.commands.length; v++) {\n            const b = y.commands[v];\n            b.entity === g.command.entity.link && (b.value && b.value.id === u && (b.value.id = h), b.oldValue && b.oldValue.id === u && (b.oldValue.id = h));\n          }\n        }\n      }\n      t.config.undo = !0, t.config.redo = !0, t.config.undo_types = {\n        link: \"link\",\n        task: \"task\"\n      }, t.config.undo_actions = {\n        update: \"update\",\n        remove: \"remove\",\n        add: \"add\",\n        move: \"move\"\n      }, t.ext || (t.ext = {}), t.ext.undo = {\n        undo: () => e.undo(),\n        redo: () => e.redo(),\n        getUndoStack: () => e.getUndoStack(),\n        setUndoStack: c => e.setUndoStack(c),\n        getRedoStack: () => e.getRedoStack(),\n        setRedoStack: c => e.setRedoStack(c),\n        clearUndoStack: () => e.clearUndoStack(),\n        clearRedoStack: () => e.clearRedoStack(),\n        saveState: (c, u) => n.store(c, u, !0),\n        getInitialState: (c, u) => u === t.config.undo_types.link ? n.getInitialLink(c) : n.getInitialTask(c)\n      }, t.undo = t.ext.undo.undo, t.redo = t.ext.undo.redo, t.getUndoStack = t.ext.undo.getUndoStack, t.getRedoStack = t.ext.undo.getRedoStack, t.clearUndoStack = t.ext.undo.clearUndoStack, t.clearRedoStack = t.ext.undo.clearRedoStack, t.attachEvent(\"onTaskIdChange\", (c, u) => {\n        const h = e;\n        l(h.getUndoStack(), c, u), l(h.getRedoStack(), c, u);\n      }), t.attachEvent(\"onLinkIdChange\", (c, u) => {\n        const h = e;\n        d(h.getUndoStack(), c, u), d(h.getRedoStack(), c, u);\n      }), t.attachEvent(\"onGanttReady\", () => {\n        e.updateConfigs();\n      });\n    },\n    marker: function (t) {\n      function e(i) {\n        if (!t.config.show_markers || !i.start_date) return !1;\n        var a = t.getState();\n        if (+i.start_date > +a.max_date || (!i.end_date || +i.end_date < +a.min_date) && +i.start_date < +a.min_date) return;\n        var r = document.createElement(\"div\");\n        r.setAttribute(\"data-marker-id\", i.id);\n        var s = \"gantt_marker\";\n        t.templates.marker_class && (s += \" \" + t.templates.marker_class(i)), i.css && (s += \" \" + i.css), t.templates.marker_class && (s += \" \" + t.templates.marker_class(i)), i.title && (r.title = i.title), r.className = s;\n        var o = t.posFromDate(i.start_date);\n        r.style.left = o + \"px\";\n        let l = Math.max(t.getRowTop(t.getVisibleTaskCount()), 0) + \"px\";\n        if (t.config.timeline_placeholder && t.$task_data && (l = t.$task_data.scrollHeight + \"px\"), r.style.height = l, i.end_date) {\n          var d = t.posFromDate(i.end_date);\n          r.style.width = Math.max(d - o, 0) + \"px\";\n        }\n        return i.text && (r.innerHTML = \"<div class='gantt_marker_content' >\" + i.text + \"</div>\"), r;\n      }\n      function n() {\n        if (t.$task_data && t.$root.contains(t.$task_data)) {\n          if (!t.$marker_area || !t.$task_data.contains(t.$marker_area)) {\n            var i = document.createElement(\"div\");\n            i.className = \"gantt_marker_area\", t.$task_data.appendChild(i), t.$marker_area = i;\n          }\n        } else t.$marker_area = null;\n      }\n      t._markers || (t._markers = t.createDatastore({\n        name: \"marker\",\n        initItem: function (i) {\n          return i.id = i.id || t.uid(), i;\n        }\n      })), t.config.show_markers = !0, t.attachEvent(\"onBeforeGanttRender\", function () {\n        t.$marker_area || n();\n      }), t.attachEvent(\"onDataRender\", function () {\n        t.$marker_area || (n(), t.renderMarkers());\n      }), t.attachEvent(\"onGanttLayoutReady\", function () {\n        t.attachEvent(\"onBeforeGanttRender\", function () {\n          t.$marker_area && (t.$marker_area.innerHTML = \"\"), n(), t.$services.getService(\"layers\").createDataRender({\n            name: \"marker\",\n            defaultContainer: function () {\n              return t.$marker_area;\n            }\n          }).addLayer(e);\n        }, {\n          once: !0\n        });\n      }), t.getMarker = function (i) {\n        return this._markers ? this._markers.getItem(i) : null;\n      }, t.addMarker = function (i) {\n        return this._markers.addItem(i);\n      }, t.deleteMarker = function (i) {\n        return !!this._markers.exists(i) && (this._markers.removeItem(i), !0);\n      }, t.updateMarker = function (i) {\n        this._markers.refresh(i);\n      }, t._getMarkers = function () {\n        return this._markers.getItems();\n      }, t.renderMarkers = function () {\n        this._markers.refresh();\n      };\n    },\n    multiselect: function (t) {\n      t.config.multiselect = !0, t.config.multiselect_one_level = !1, t._multiselect = {\n        _selected: {},\n        _one_level: !1,\n        _active: !0,\n        _first_selected_when_shift: null,\n        getDefaultSelected: function () {\n          var e = this.getSelected();\n          return e.length ? e[e.length - 1] : null;\n        },\n        setFirstSelected: function (e) {\n          this._first_selected_when_shift = e;\n        },\n        getFirstSelected: function () {\n          return this._first_selected_when_shift;\n        },\n        isActive: function () {\n          return this.updateState(), this._active;\n        },\n        updateState: function () {\n          this._one_level = t.config.multiselect_one_level;\n          var e = this._active;\n          this._active = t.config.select_task, this._active != e && this.reset();\n        },\n        reset: function () {\n          this._selected = {};\n        },\n        setLastSelected: function (e) {\n          t.$data.tasksStore.silent(function () {\n            var n = t.$data.tasksStore;\n            e ? n.select(e + \"\") : n.unselect(null);\n          });\n        },\n        getLastSelected: function () {\n          var e = t.$data.tasksStore.getSelectedId();\n          return e && t.isTaskExists(e) ? e : null;\n        },\n        select: function (e, n) {\n          return !!(e && t.callEvent(\"onBeforeTaskMultiSelect\", [e, !0, n]) && t.callEvent(\"onBeforeTaskSelected\", [e])) && (this._selected[e] = !0, this.setLastSelected(e), this.afterSelect(e), t.callEvent(\"onTaskMultiSelect\", [e, !0, n]), t.callEvent(\"onTaskSelected\", [e]), !0);\n        },\n        toggle: function (e, n) {\n          this._selected[e] ? this.unselect(e, n) : this.select(e, n);\n        },\n        unselect: function (e, n) {\n          e && t.callEvent(\"onBeforeTaskMultiSelect\", [e, !1, n]) && (this._selected[e] = !1, this.getLastSelected() == e && this.setLastSelected(this.getDefaultSelected()), this.afterSelect(e), t.callEvent(\"onTaskMultiSelect\", [e, !1, n]), t.callEvent(\"onTaskUnselected\", [e]));\n        },\n        isSelected: function (e) {\n          return !(!t.isTaskExists(e) || !this._selected[e]);\n        },\n        getSelected: function () {\n          var e = [];\n          for (var n in this._selected) this._selected[n] && t.isTaskExists(n) ? e.push(n) : this._selected[n] = !1;\n          return e.sort(function (i, a) {\n            return t.getGlobalTaskIndex(i) > t.getGlobalTaskIndex(a) ? 1 : -1;\n          }), e;\n        },\n        forSelected: function (e) {\n          for (var n = this.getSelected(), i = 0; i < n.length; i++) e(n[i]);\n        },\n        isSameLevel: function (e) {\n          if (!this._one_level) return !0;\n          var n = this.getLastSelected();\n          return !n || !t.isTaskExists(n) || !t.isTaskExists(e) || t.calculateTaskLevel(t.getTask(n)) == t.calculateTaskLevel(t.getTask(e));\n        },\n        afterSelect: function (e) {\n          t.isTaskExists(e) && t._quickRefresh(function () {\n            t.refreshTask(e);\n          });\n        },\n        doSelection: function (e) {\n          if (!this.isActive() || t._is_icon_open_click(e)) return !1;\n          var n = t.locate(e);\n          if (!n || !t.callEvent(\"onBeforeMultiSelect\", [e])) return !1;\n          var i = this.getSelected(),\n            a = this.getFirstSelected(),\n            r = !1,\n            s = this.getLastSelected(),\n            o = t.config.multiselect,\n            l = function () {\n              const c = t.ext.inlineEditors;\n              if (c && c.getState) {\n                const h = c.getState(),\n                  g = c.locateCell(e.target);\n                t.config.inline_editors_multiselect_open && g && c.getEditorConfig(g.columnName) && (c.isVisible() && h.id == g.id && h.columnName == g.columnName || c.startEdit(g.id, g.columnName));\n              }\n              this.setFirstSelected(n), this.isSelected(n) || this.select(n, e), i = this.getSelected();\n              for (var u = 0; u < i.length; u++) i[u] !== n && this.unselect(i[u], e);\n            }.bind(this),\n            d = function () {\n              if (s) {\n                if (n) {\n                  var c = t.getGlobalTaskIndex(this.getFirstSelected()),\n                    u = t.getGlobalTaskIndex(n),\n                    h = t.getGlobalTaskIndex(s);\n                  c != -1 && h != -1 || (c = u, this.reset());\n                  for (var g = s; t.getGlobalTaskIndex(g) !== c;) this.unselect(g, e), g = c > h ? t.getNext(g) : t.getPrev(g);\n                  for (g = n; t.getGlobalTaskIndex(g) !== c;) this.select(g, e) && !r && (r = !0, a = g), g = c > u ? t.getNext(g) : t.getPrev(g);\n                }\n              } else s = n;\n            }.bind(this);\n          return o && (e.ctrlKey || e.metaKey) ? (this.isSelected(n) || this.setFirstSelected(n), n && this.toggle(n, e)) : o && e.shiftKey ? (t.isTaskExists(this.getFirstSelected()) && this.getFirstSelected() !== null || this.setFirstSelected(n), i.length ? d() : l()) : l(), this.isSelected(n) ? this.setLastSelected(n) : a ? n == s && this.setLastSelected(e.shiftKey ? a : this.getDefaultSelected()) : this.setLastSelected(null), this.getSelected().length || this.setLastSelected(null), this.getLastSelected() && this.isSelected(this.getFirstSelected()) || this.setFirstSelected(this.getLastSelected()), !0;\n        }\n      }, function () {\n        var e = t.selectTask;\n        t.selectTask = function (i) {\n          if (!(i = at(i, this.config.root_id))) return !1;\n          var a = t._multiselect,\n            r = i;\n          return a.isActive() ? (a.select(i, null) && a.setLastSelected(i), a.setFirstSelected(a.getLastSelected())) : r = e.call(this, i), r;\n        };\n        var n = t.unselectTask;\n        t.unselectTask = function (i) {\n          var a = t._multiselect,\n            r = a.isActive();\n          (i = i || a.getLastSelected()) && r && (a.unselect(i, null), i == a.getLastSelected() && a.setLastSelected(null), t.refreshTask(i), a.setFirstSelected(a.getLastSelected()));\n          var s = i;\n          return r || (s = n.call(this, i)), s;\n        }, t.toggleTaskSelection = function (i) {\n          var a = t._multiselect;\n          i && a.isActive() && (a.toggle(i), a.setFirstSelected(a.getLastSelected()));\n        }, t.getSelectedTasks = function () {\n          var i = t._multiselect;\n          return i.isActive(), i.getSelected();\n        }, t.eachSelectedTask = function (i) {\n          return this._multiselect.forSelected(i);\n        }, t.isSelectedTask = function (i) {\n          return this._multiselect.isSelected(i);\n        }, t.getLastSelectedTask = function () {\n          return this._multiselect.getLastSelected();\n        }, t.attachEvent(\"onGanttReady\", function () {\n          var i = t.$data.tasksStore.isSelected;\n          t.$data.tasksStore.isSelected = function (a) {\n            return t._multiselect.isActive() ? t._multiselect.isSelected(a) : i.call(this, a);\n          };\n        });\n      }(), t.attachEvent(\"onTaskIdChange\", function (e, n) {\n        var i = t._multiselect;\n        if (!i.isActive()) return !0;\n        t.isSelectedTask(e) && (i.unselect(e, null), i.select(n, null));\n      }), t.attachEvent(\"onAfterTaskDelete\", function (e, n) {\n        var i = t._multiselect;\n        if (!i.isActive()) return !0;\n        i._selected[e] && (i._selected[e] = !1, i.setLastSelected(i.getDefaultSelected())), i.forSelected(function (a) {\n          t.isTaskExists(a) || i.unselect(a, null);\n        });\n      }), t.attachEvent(\"onBeforeTaskMultiSelect\", function (e, n, i) {\n        const a = t._multiselect;\n        if (n && a.isActive()) {\n          let r = t.getSelectedId(),\n            s = null;\n          r && (s = t.getTask(r));\n          let o = t.getTask(e),\n            l = !1;\n          if (s && s.$level != o.$level && (l = !0), t.config.multiselect_one_level && l && !i.ctrlKey && !i.shiftKey) return !0;\n          if (a._one_level) return a.isSameLevel(e);\n        }\n        return !0;\n      }), t.attachEvent(\"onTaskClick\", function (e, n) {\n        return t._multiselect.doSelection(n) && t.callEvent(\"onMultiSelect\", [n]), !0;\n      });\n    },\n    export_api: function (t) {\n      return t.ext = t.ext || {}, t.ext.export_api = t.ext.export_api || {\n        _apiUrl: \"https://export.dhtmlx.com/gantt\",\n        _preparePDFConfigRaw(e, n) {\n          let i = null;\n          e.start && e.end && (i = {\n            start_date: t.config.start_date,\n            end_date: t.config.end_date\n          }, t.config.start_date = t.date.str_to_date(t.config.date_format)(e.start), t.config.end_date = t.date.str_to_date(t.config.date_format)(e.end)), e = t.mixin(e, {\n            name: \"gantt.\" + n,\n            data: t.ext.export_api._serializeHtml()\n          }), i && (t.config.start_date = i.start_date, t.config.end_date = i.end_date);\n        },\n        _prepareConfigPDF: (e, n) => (e = t.mixin(e || {}, {\n          name: \"gantt.\" + n,\n          data: t.ext.export_api._serializeAll(),\n          config: t.config\n        }), t.ext.export_api._fixColumns(e.config.columns), e),\n        _pdfExportRouter(e, n) {\n          e && e.raw ? t.ext.export_api._preparePDFConfigRaw(e, n) : e = t.ext.export_api._prepareConfigPDF(e, n), e.version = t.version, t.ext.export_api._sendToExport(e, n);\n        },\n        exportToPDF(e) {\n          t.ext.export_api._pdfExportRouter(e, \"pdf\");\n        },\n        exportToPNG(e) {\n          t.ext.export_api._pdfExportRouter(e, \"png\");\n        },\n        exportToICal(e) {\n          e = t.mixin(e || {}, {\n            name: \"gantt.ical\",\n            data: t.ext.export_api._serializePlain().data,\n            version: t.version\n          }), t.ext.export_api._sendToExport(e, \"ical\");\n        },\n        exportToExcel(e) {\n          let n, i, a, r;\n          e = e || {};\n          const s = t.config.smart_rendering;\n          if (e.visual === \"base-colors\" && (t.config.smart_rendering = !1), e.start || e.end) {\n            a = t.getState(), i = [t.config.start_date, t.config.end_date], r = t.getScrollState();\n            const o = t.date.str_to_date(t.config.date_format);\n            n = t.eachTask, e.start && (t.config.start_date = o(e.start)), e.end && (t.config.end_date = o(e.end)), t.render(), t.config.smart_rendering = s, t.eachTask = t.ext.export_api._eachTaskTimed(t.config.start_date, t.config.end_date);\n          } else e.visual === \"base-colors\" && (t.render(), t.config.smart_rendering = s);\n          t._no_progress_colors = e.visual === \"base-colors\", (e = t.mixin(e, {\n            name: \"gantt.xlsx\",\n            title: \"Tasks\",\n            data: t.ext.export_api._serializeTimeline(e).data,\n            columns: t.ext.export_api._serializeGrid({\n              rawDates: !0\n            }),\n            version: t.version\n          })).visual && (e.scales = t.ext.export_api._serializeScales(e)), t.ext.export_api._sendToExport(e, \"excel\"), (e.start || e.end) && (t.config.start_date = a.min_date, t.config.end_date = a.max_date, t.eachTask = n, t.render(), t.scrollTo(r.x, r.y), t.config.start_date = i[0], t.config.end_date = i[1]);\n        },\n        exportToJSON(e) {\n          e = t.mixin(e || {}, {\n            name: \"gantt.json\",\n            data: t.ext.export_api._serializeAll(),\n            config: t.config,\n            columns: t.ext.export_api._serializeGrid(),\n            worktime: t.ext.export_api._getWorktimeSettings(),\n            version: t.version\n          }), t.ext.export_api._sendToExport(e, \"json\");\n        },\n        importFromExcel(e) {\n          try {\n            const n = e.data;\n            if (n instanceof File) {\n              const i = new FormData();\n              i.append(\"file\", n), e.data = i;\n            }\n          } catch {}\n          t.ext.export_api._sendImportAjaxExcel(e);\n        },\n        importFromMSProject(e) {\n          const n = e.data;\n          try {\n            if (n instanceof File) {\n              const i = new FormData();\n              i.append(\"file\", n), e.data = i;\n            }\n          } catch {}\n          t.ext.export_api._sendImportAjaxMSP(e);\n        },\n        importFromPrimaveraP6: e => (e.type = \"primaveraP6-parse\", t.importFromMSProject(e)),\n        exportToMSProject(e) {\n          (e = e || {}).skip_circular_links = e.skip_circular_links === void 0 || !!e.skip_circular_links;\n          const n = t.templates.xml_format,\n            i = t.templates.format_date,\n            a = t.config.xml_date,\n            r = t.config.date_format,\n            s = \"%d-%m-%Y %H:%i:%s\";\n          t.config.xml_date = s, t.config.date_format = s, t.templates.xml_format = t.date.date_to_str(s), t.templates.format_date = t.date.date_to_str(s);\n          const o = t.ext.export_api._serializeAll();\n          t.ext.export_api._customProjectProperties(o, e), t.ext.export_api._customTaskProperties(o, e), e.skip_circular_links && t.ext.export_api._clearRecLinks(o), e = t.ext.export_api._exportConfig(o, e), t.ext.export_api._sendToExport(e, e.type || \"msproject\"), t.config.xml_date = a, t.config.date_format = r, t.templates.xml_format = n, t.templates.format_date = i, t.config.$custom_data = null, t.config.custom = null;\n        },\n        exportToPrimaveraP6: e => ((e = e || {}).type = \"primaveraP6\", t.exportToMSProject(e)),\n        _fixColumns(e) {\n          for (let n = 0; n < e.length; n++) e[n].label = e[n].label || t.locale.labels[\"column_\" + e[n].name], typeof e[n].width == \"string\" && (e[n].width = 1 * e[n].width);\n        },\n        _xdr(e, n, i) {\n          t.ajax.post(e, n, i);\n        },\n        _markColumns(e) {\n          const n = e.config.columns;\n          if (n) for (let i = 0; i < n.length; i++) n[i].template && (n[i].$template = !0);\n        },\n        _sendImportAjaxExcel(e) {\n          const n = e.server || t.ext.export_api._apiUrl,\n            i = e.store || 0,\n            a = e.data,\n            r = e.callback;\n          a.append(\"type\", \"excel-parse\"), a.append(\"data\", JSON.stringify({\n            sheet: e.sheet || 0\n          })), i && a.append(\"store\", i);\n          const s = new XMLHttpRequest();\n          s.onreadystatechange = function (o) {\n            s.readyState === 4 && s.status === 0 && r && r(null);\n          }, s.onload = function () {\n            let o = null;\n            if (!(s.status > 400)) try {\n              o = JSON.parse(s.responseText);\n            } catch {}\n            r && r(o);\n          }, s.open(\"POST\", n, !0), s.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"), s.send(a);\n        },\n        _ajaxToExport(e, n, i) {\n          delete e.callback;\n          const a = e.server || t.ext.export_api._apiUrl,\n            r = \"type=\" + n + \"&store=1&data=\" + encodeURIComponent(JSON.stringify(e));\n          t.ext.export_api._xdr(a, r, function (s) {\n            const o = s.xmlDoc || s;\n            let l = null;\n            if (!(o.status > 400)) try {\n              l = JSON.parse(o.responseText);\n            } catch {}\n            i(l);\n          });\n        },\n        _serializableGanttConfig(e) {\n          const n = t.mixin({}, e);\n          return n.columns && (n.columns = n.columns.map(function (i) {\n            const a = t.mixin({}, i);\n            return delete a.editor, a;\n          })), delete n.editor_types, n;\n        },\n        _sendToExport(e, n) {\n          const i = t.date.date_to_str(t.config.date_format || t.config.xml_date);\n          if (e.skin || (e.skin = t.skin), e.config && (e.config = t.copy(t.ext.export_api._serializableGanttConfig(e.config)), t.ext.export_api._markColumns(e, n), e.config.start_date && e.config.end_date && (e.config.start_date instanceof Date && (e.config.start_date = i(e.config.start_date)), e.config.end_date instanceof Date && (e.config.end_date = i(e.config.end_date)))), e.callback) return t.ext.export_api._ajaxToExport(e, n, e.callback);\n          const a = t.ext.export_api._createHiddenForm();\n          a.firstChild.action = e.server || t.ext.export_api._apiUrl, a.firstChild.childNodes[0].value = JSON.stringify(e), a.firstChild.childNodes[1].value = n, a.firstChild.submit();\n        },\n        _createHiddenForm() {\n          if (!t.ext.export_api._hidden_export_form) {\n            const e = t.ext.export_api._hidden_export_form = document.createElement(\"div\");\n            e.style.display = \"none\", e.innerHTML = \"<form method='POST' target='_blank'><textarea name='data' style='width:0px; height:0px;' readonly='true'></textarea><input type='hidden' name='type' value=''></form>\", document.body.appendChild(e);\n          }\n          return t.ext.export_api._hidden_export_form;\n        },\n        _copyObjectBase(e) {\n          const n = {\n            start_date: void 0,\n            end_date: void 0,\n            constraint_date: void 0,\n            deadline: void 0\n          };\n          for (const a in e) a.charAt(0) !== \"$\" && a !== \"baselines\" && (n[a] = e[a]);\n          const i = t.templates.xml_format || t.templates.format_date;\n          return n.start_date = i(n.start_date), n.end_date && (n.end_date = i(n.end_date)), n.constraint_date && (n.constraint_date = i(n.constraint_date)), n.deadline && (n.deadline = i(n.deadline)), n;\n        },\n        _color_box: null,\n        _color_hash: {},\n        _getStyles(e) {\n          if (t.ext.export_api._color_box || (t.ext.export_api._color_box = document.createElement(\"DIV\"), t.ext.export_api._color_box.style.cssText = \"position:absolute; display:none;\", document.body.appendChild(t.ext.export_api._color_box)), t.ext.export_api._color_hash[e]) return t.ext.export_api._color_hash[e];\n          t.ext.export_api._color_box.className = e;\n          const n = t.ext.export_api._getColor(t.ext.export_api._color_box, \"color\"),\n            i = t.ext.export_api._getColor(t.ext.export_api._color_box, \"backgroundColor\");\n          return t.ext.export_api._color_hash[e] = n + \";\" + i;\n        },\n        _getMinutesWorktimeSettings(e) {\n          const n = [];\n          return e.forEach(function (i) {\n            n.push(i.startMinute), n.push(i.endMinute);\n          }), n;\n        },\n        _getWorktimeSettings() {\n          const e = {\n            hours: [0, 24],\n            minutes: null,\n            dates: {\n              0: !0,\n              1: !0,\n              2: !0,\n              3: !0,\n              4: !0,\n              5: !0,\n              6: !0\n            }\n          };\n          let n;\n          if (t.config.work_time) {\n            const i = t._working_time_helper;\n            if (i && i.get_calendar) n = i.get_calendar();else if (i) n = {\n              hours: i.hours,\n              minutes: null,\n              dates: i.dates\n            };else if (t.config.worktimes && t.config.worktimes.global) {\n              const a = t.config.worktimes.global;\n              if (a.parsed) {\n                n = {\n                  hours: null,\n                  minutes: t.ext.export_api._getMinutesWorktimeSettings(a.parsed.hours),\n                  dates: {}\n                };\n                for (const r in a.parsed.dates) Array.isArray(a.parsed.dates[r]) ? n.dates[r] = t.ext.export_api._getMinutesWorktimeSettings(a.parsed.dates[r]) : n.dates[r] = a.parsed.dates[r];\n              } else n = {\n                hours: a.hours,\n                minutes: null,\n                dates: a.dates\n              };\n            } else n = e;\n          } else n = e;\n          return n;\n        },\n        _eachTaskTimed: (e, n) => function (i, a, r) {\n          a = a || t.config.root_id, r = r || t;\n          const s = t.getChildren(a);\n          if (s) for (let o = 0; o < s.length; o++) {\n            const l = t._pull[s[o]];\n            (!e || l.end_date > e) && (!n || l.start_date < n) && i.call(r, l), t.hasChild(l.id) && t.eachTask(i, l.id, r);\n          }\n        },\n        _originalCopyObject: t.json._copyObject,\n        _copyObjectPlain(e) {\n          const n = t.templates.task_text(e.start_date, e.end_date, e),\n            i = t.ext.export_api._copyObjectBase(e);\n          return i.text = n || i.text, i;\n        },\n        _getColor(e, n) {\n          const i = e.currentStyle ? e.currentStyle[n] : getComputedStyle(e, null)[n],\n            a = i.replace(/\\s/g, \"\").match(/^rgba?\\((\\d+),(\\d+),(\\d+)/i);\n          return (a && a.length === 4 ? (\"0\" + parseInt(a[1], 10).toString(16)).slice(-2) + (\"0\" + parseInt(a[2], 10).toString(16)).slice(-2) + (\"0\" + parseInt(a[3], 10).toString(16)).slice(-2) : i).replace(\"#\", \"\");\n        },\n        _copyObjectTable(e) {\n          const n = t.date.date_to_str(\"%Y-%m-%dT%H:%i:%s.000Z\"),\n            i = t.ext.export_api._copyObjectColumns(e, t.ext.export_api._copyObjectPlain(e));\n          i.start_date && (i.start_date = n(e.start_date)), i.end_date && (i.end_date = n(e.end_date));\n          const a = t._day_index_by_date ? t._day_index_by_date : t.columnIndexByDate;\n          i.$start = a.call(t, e.start_date), i.$end = a.call(t, e.end_date);\n          let r = 0;\n          const s = t.getScale().width;\n          if (s.indexOf(0) > -1) {\n            let l = 0;\n            for (; l < i.$start; l++) s[l] || r++;\n            for (i.$start -= r; l < i.$end; l++) s[l] || r++;\n            i.$end -= r;\n          }\n          i.$level = e.$level, i.$type = e.$rendered_type;\n          const o = t.templates;\n          return i.$text = o.task_text(e.start, e.end_date, e), i.$left = o.leftside_text ? o.leftside_text(e.start, e.end_date, e) : \"\", i.$right = o.rightside_text ? o.rightside_text(e.start, e.end_date, e) : \"\", i;\n        },\n        _copyObjectColors(e) {\n          const n = t.ext.export_api._copyObjectTable(e),\n            i = t.getTaskNode(e.id);\n          if (i && i.firstChild) {\n            let a = t.ext.export_api._getColor(t._no_progress_colors ? i : i.firstChild, \"backgroundColor\");\n            a === \"363636\" && (a = t.ext.export_api._getColor(i, \"backgroundColor\")), n.$color = a;\n          } else e.color && (n.$color = e.color);\n          return n;\n        },\n        _copyObjectColumns(e, n) {\n          for (let i = 0; i < t.config.columns.length; i++) {\n            const a = t.config.columns[i].template;\n            if (a) {\n              let r = a(e);\n              r instanceof Date && (r = t.templates.date_grid(r, e)), n[\"_\" + i] = r;\n            }\n          }\n          return n;\n        },\n        _copyObjectAll(e) {\n          const n = t.ext.export_api._copyObjectBase(e),\n            i = [\"leftside_text\", \"rightside_text\", \"task_text\", \"progress_text\", \"task_class\"];\n          for (let a = 0; a < i.length; a++) {\n            const r = t.templates[i[a]];\n            r && (n[\"$\" + a] = r(e.start_date, e.end_date, e));\n          }\n          return t.ext.export_api._copyObjectColumns(e, n), n.open = e.$open, n;\n        },\n        _serializeHtml() {\n          const e = t.config.smart_scales,\n            n = t.config.smart_rendering;\n          (e || n) && (t.config.smart_rendering = !1, t.config.smart_scales = !1, t.render());\n          const i = t.$container.parentNode.innerHTML;\n          return (e || n) && (t.config.smart_scales = e, t.config.smart_rendering = n, t.render()), i;\n        },\n        _serializeAll() {\n          t.json._copyObject = t.ext.export_api._copyObjectAll;\n          const e = t.ext.export_api._exportSerialize();\n          return t.json._copyObject = t.ext.export_api._originalCopyObject, e;\n        },\n        _serializePlain() {\n          const e = t.templates.xml_format,\n            n = t.templates.format_date;\n          t.templates.xml_format = t.date.date_to_str(\"%Y%m%dT%H%i%s\", !0), t.templates.format_date = t.date.date_to_str(\"%Y%m%dT%H%i%s\", !0), t.json._copyObject = t.ext.export_api._copyObjectPlain;\n          const i = t.ext.export_api._exportSerialize();\n          return t.templates.xml_format = e, t.templates.format_date = n, t.json._copyObject = t.ext.export_api._originalCopyObject, delete i.links, i;\n        },\n        _getRaw() {\n          if (t._scale_helpers) {\n            const e = t._get_scales(),\n              n = t.config.min_column_width,\n              i = t._get_resize_options().x ? Math.max(t.config.autosize_min_width, 0) : t.config.$task.offsetWidth,\n              a = t.config.config.scale_height - 1;\n            return t._scale_helpers.prepareConfigs(e, n, i, a);\n          }\n          {\n            const e = t.$ui.getView(\"timeline\");\n            if (e) {\n              let n = e.$config.width;\n              t.config.autosize !== \"x\" && t.config.autosize !== \"xy\" || (n = Math.max(t.config.autosize_min_width, 0));\n              const i = t.getState(),\n                a = e._getScales(),\n                r = t.config.min_column_width,\n                s = t.config.scale_height - 1,\n                o = t.config.rtl;\n              return e.$scaleHelper.prepareConfigs(a, r, n, s, i.min_date, i.max_date, o);\n            }\n          }\n        },\n        _serializeTimeline(e) {\n          t.json._copyObject = e.visual ? t.ext.export_api._copyObjectColors : t.ext.export_api._copyObjectTable;\n          const n = t.ext.export_api._exportSerialize();\n          if (t.json._copyObject = t.ext.export_api._originalCopyObject, delete n.links, e.cellColors) {\n            const i = t.templates.timeline_cell_class || t.templates.task_cell_class;\n            if (i) {\n              const a = t.ext.export_api._getRaw();\n              let r = a[0].trace_x;\n              for (let s = 1; s < a.length; s++) a[s].trace_x.length > r.length && (r = a[s].trace_x);\n              for (let s = 0; s < n.data.length; s++) {\n                n.data[s].styles = [];\n                const o = t.getTask(n.data[s].id);\n                for (let l = 0; l < r.length; l++) {\n                  const d = i(o, r[l]);\n                  d && n.data[s].styles.push({\n                    index: l,\n                    styles: t.ext.export_api._getStyles(d)\n                  });\n                }\n              }\n            }\n          }\n          return n;\n        },\n        _serializeScales(e) {\n          const n = [],\n            i = t.ext.export_api._getRaw();\n          let a = 1 / 0,\n            r = 0;\n          for (let s = 0; s < i.length; s++) a = Math.min(a, i[s].col_width);\n          for (let s = 0; s < i.length; s++) {\n            let o = 0,\n              l = 0;\n            const d = [];\n            n.push(d);\n            const c = i[s];\n            r = Math.max(r, c.trace_x.length);\n            const u = c.format || c.template || (c.date ? t.date.date_to_str(c.date) : t.config.date_scale);\n            for (let h = 0; h < c.trace_x.length; h++) {\n              const g = c.trace_x[h];\n              l = o + Math.round(c.width[h] / a);\n              const f = {\n                text: u(g),\n                start: o,\n                end: l,\n                styles: \"\"\n              };\n              if (e.cellColors) {\n                const y = c.css || t.templates.scaleCell_class;\n                if (y) {\n                  const v = y(g);\n                  v && (f.styles = t.ext.export_api._getStyles(v));\n                }\n              }\n              d.push(f), o = l;\n            }\n          }\n          return {\n            width: r,\n            height: n.length,\n            data: n\n          };\n        },\n        _serializeGrid(e) {\n          t.exportMode = !0;\n          const n = [],\n            i = t.config.columns;\n          let a = 0;\n          for (let r = 0; r < i.length; r++) i[r].name !== \"add\" && i[r].name !== \"buttons\" && (n[a] = {\n            id: i[r].template ? \"_\" + r : i[r].name,\n            header: i[r].label || t.locale.labels[\"column_\" + i[r].name],\n            width: i[r].width ? Math.floor(i[r].width / 4) : \"\",\n            tree: i[r].tree || !1\n          }, i[r].name === \"duration\" && (n[a].type = \"number\"), i[r].name !== \"start_date\" && i[r].name !== \"end_date\" || (n[a].type = \"date\", e && e.rawDates && (n[a].id = i[r].name)), a++);\n          return t.exportMode = !1, n;\n        },\n        _exportSerialize() {\n          t.exportMode = !0;\n          const e = t.templates.xml_format,\n            n = t.templates.format_date;\n          t.templates.xml_format = t.templates.format_date = t.date.date_to_str(t.config.date_format || t.config.xml_date);\n          const i = t.serialize();\n          return t.templates.xml_format = e, t.templates.format_date = n, t.exportMode = !1, i;\n        },\n        _setLevel(e) {\n          for (let n = 0; n < e.length; n++) {\n            e[n].parent == 0 && (e[n]._lvl = 1);\n            for (let i = n + 1; i < e.length; i++) e[n].id == e[i].parent && (e[i]._lvl = e[n]._lvl + 1);\n          }\n        },\n        _clearLevel(e) {\n          for (let n = 0; n < e.length; n++) delete e[n]._lvl;\n        },\n        _clearRecLinks(e) {\n          t.ext.export_api._setLevel(e.data);\n          const n = {};\n          for (let r = 0; r < e.data.length; r++) n[e.data[r].id] = e.data[r];\n          const i = {};\n          for (let r = 0; r < e.links.length; r++) {\n            const s = e.links[r];\n            t.isTaskExists(s.source) && t.isTaskExists(s.target) && n[s.source] && n[s.target] && (i[s.id] = s);\n          }\n          for (const r in i) t.ext.export_api._makeLinksSameLevel(i[r], n);\n          const a = {};\n          for (const r in n) t.ext.export_api._clearCircDependencies(n[r], i, n, {}, a, null);\n          Object.keys(i) && t.ext.export_api._clearLinksSameLevel(i, n);\n          for (let r = 0; r < e.links.length; r++) i[e.links[r].id] || (e.links.splice(r, 1), r--);\n          t.ext.export_api._clearLevel(e.data);\n        },\n        _clearCircDependencies(e, n, i, a, r, s) {\n          const o = e.$_source;\n          if (!o) return;\n          a[e.id] && t.ext.export_api._onCircDependencyFind(s, n, a, r), a[e.id] = !0;\n          const l = {};\n          for (let d = 0; d < o.length; d++) {\n            if (r[o[d]]) continue;\n            const c = n[o[d]],\n              u = i[c._target];\n            l[u.id] && t.ext.export_api._onCircDependencyFind(c, n, a, r), l[u.id] = !0, t.ext.export_api._clearCircDependencies(u, n, i, a, r, c);\n          }\n          a[e.id] = !1;\n        },\n        _onCircDependencyFind(e, n, i, a) {\n          e && (t.callEvent(\"onExportCircularDependency\", [e.id, e]) && delete n[e.id], delete i[e._source], delete i[e._target], a[e.id] = !0);\n        },\n        _makeLinksSameLevel(e, n) {\n          let i, a;\n          const r = {\n            target: n[e.target],\n            source: n[e.source]\n          };\n          if (r.target._lvl != r.source._lvl) {\n            r.target._lvl < r.source._lvl ? (i = \"source\", a = r.target._lvl) : (i = \"target\", a = r.source._lvl);\n            do {\n              const l = n[r[i].parent];\n              if (!l) break;\n              r[i] = l;\n            } while (r[i]._lvl < a);\n            let s = n[r.source.parent],\n              o = n[r.target.parent];\n            for (; s && o && s.id != o.id;) r.source = s, r.target = o, s = n[r.source.parent], o = n[r.target.parent];\n          }\n          e._target = r.target.id, e._source = r.source.id, r.target.$_target || (r.target.$_target = []), r.target.$_target.push(e.id), r.source.$_source || (r.source.$_source = []), r.source.$_source.push(e.id);\n        },\n        _clearLinksSameLevel(e, n) {\n          for (const i in e) delete e[i]._target, delete e[i]._source;\n          for (const i in n) delete n[i].$_source, delete n[i].$_target;\n        },\n        _customProjectProperties(e, n) {\n          if (n && n.project) {\n            for (const i in n.project) t.config.$custom_data || (t.config.$custom_data = {}), t.config.$custom_data[i] = typeof n.project[i] == \"function\" ? n.project[i](t.config) : n.project[i];\n            delete n.project;\n          }\n        },\n        _customTaskProperties(e, n) {\n          n && n.tasks && (e.data.forEach(function (i) {\n            for (const a in n.tasks) i.$custom_data || (i.$custom_data = {}), i.$custom_data[a] = typeof n.tasks[a] == \"function\" ? n.tasks[a](i, t.config) : n.tasks[a];\n          }), delete n.tasks);\n        },\n        _exportConfig(e, n) {\n          const i = n.name || \"gantt.xml\";\n          delete n.name, t.config.custom = n;\n          const a = t.ext.export_api._getWorktimeSettings(),\n            r = t.getSubtaskDates();\n          if (r.start_date && r.end_date) {\n            const l = t.templates.format_date || t.templates.xml_format;\n            t.config.start_end = {\n              start_date: l(r.start_date),\n              end_date: l(r.end_date)\n            };\n          }\n          const s = n.auto_scheduling !== void 0 && !!n.auto_scheduling,\n            o = {\n              callback: n.callback || null,\n              config: t.config,\n              data: e,\n              manual: s,\n              name: i,\n              worktime: a\n            };\n          for (const l in n) o[l] = n[l];\n          return o;\n        },\n        _sendImportAjaxMSP(e) {\n          const n = e.server || t.ext.export_api._apiUrl,\n            i = e.store || 0,\n            a = e.data,\n            r = e.callback,\n            s = {\n              durationUnit: e.durationUnit || void 0,\n              projectProperties: e.projectProperties || void 0,\n              taskProperties: e.taskProperties || void 0\n            };\n          a.append(\"type\", e.type || \"msproject-parse\"), a.append(\"data\", JSON.stringify(s)), i && a.append(\"store\", i);\n          const o = new XMLHttpRequest();\n          o.onreadystatechange = function (l) {\n            o.readyState === 4 && o.status === 0 && r && r(null);\n          }, o.onload = function () {\n            let l = null;\n            if (!(o.status > 400)) try {\n              l = JSON.parse(o.responseText);\n            } catch {}\n            r && r(l);\n          }, o.open(\"POST\", n, !0), o.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"), o.send(a);\n        }\n      }, t.exportToPDF = t.ext.export_api.exportToPDF, t.exportToPNG = t.ext.export_api.exportToPNG, t.exportToICal = t.ext.export_api.exportToICal, t.exportToExcel = t.ext.export_api.exportToExcel, t.exportToJSON = t.ext.export_api.exportToJSON, t.importFromExcel = t.ext.export_api.importFromExcel, t.importFromMSProject = t.ext.export_api.importFromMSProject, t.exportToMSProject = t.ext.export_api.exportToMSProject, t.importFromPrimaveraP6 = t.ext.export_api.importFromPrimaveraP6, t.exportToPrimaveraP6 = t.ext.export_api.exportToPrimaveraP6, t.ext.export_api;\n    }\n  },\n  Gn = {\n    KEY_CODES: {\n      UP: 38,\n      DOWN: 40,\n      LEFT: 37,\n      RIGHT: 39,\n      SPACE: 32,\n      ENTER: 13,\n      DELETE: 46,\n      ESC: 27,\n      TAB: 9\n    }\n  };\nclass Yn {\n  constructor(e) {\n    this.addExtension = (n, i) => {\n      this._extensions[n] = i;\n    }, this.getExtension = n => this._extensions[n], this._extensions = {};\n    for (const n in e) this._extensions[n] = e[n];\n  }\n}\nconst Jn = () => ({\n  layout: {\n    css: \"gantt_container\",\n    rows: [{\n      cols: [{\n        view: \"grid\",\n        scrollX: \"scrollHor\",\n        scrollY: \"scrollVer\"\n      }, {\n        resizer: !0,\n        width: 1\n      }, {\n        view: \"timeline\",\n        scrollX: \"scrollHor\",\n        scrollY: \"scrollVer\"\n      }, {\n        view: \"scrollbar\",\n        id: \"scrollVer\"\n      }]\n    }, {\n      view: \"scrollbar\",\n      id: \"scrollHor\",\n      height: 20\n    }]\n  },\n  links: {\n    finish_to_start: \"0\",\n    start_to_start: \"1\",\n    finish_to_finish: \"2\",\n    start_to_finish: \"3\"\n  },\n  types: {\n    task: \"task\",\n    project: \"project\",\n    milestone: \"milestone\"\n  },\n  auto_types: !1,\n  duration_unit: \"day\",\n  work_time: !1,\n  correct_work_time: !1,\n  skip_off_time: !1,\n  cascade_delete: !0,\n  autosize: !1,\n  autosize_min_width: 0,\n  autoscroll: !0,\n  autoscroll_speed: 30,\n  deepcopy_on_parse: !1,\n  show_links: !0,\n  show_task_cells: !0,\n  static_background: !1,\n  static_background_cells: !0,\n  branch_loading: !1,\n  branch_loading_property: \"$has_child\",\n  show_loading: !1,\n  show_chart: !0,\n  show_grid: !0,\n  min_duration: 36e5,\n  date_format: \"%d-%m-%Y %H:%i\",\n  xml_date: void 0,\n  start_on_monday: !0,\n  server_utc: !1,\n  show_progress: !0,\n  fit_tasks: !1,\n  select_task: !0,\n  scroll_on_click: !0,\n  smart_rendering: !0,\n  preserve_scroll: !0,\n  readonly: !1,\n  container_resize_timeout: 20,\n  deadlines: !0,\n  date_grid: \"%Y-%m-%d\",\n  drag_links: !0,\n  drag_progress: !0,\n  drag_resize: !0,\n  drag_project: !1,\n  drag_move: !0,\n  drag_mode: {\n    resize: \"resize\",\n    progress: \"progress\",\n    move: \"move\",\n    ignore: \"ignore\"\n  },\n  round_dnd_dates: !0,\n  link_wrapper_width: 20,\n  link_arrow_size: 12,\n  root_id: 0,\n  autofit: !1,\n  columns: [{\n    name: \"text\",\n    tree: !0,\n    width: \"*\",\n    resize: !0\n  }, {\n    name: \"start_date\",\n    align: \"center\",\n    resize: !0\n  }, {\n    name: \"duration\",\n    align: \"center\"\n  }, {\n    name: \"add\",\n    width: 44\n  }],\n  scale_offset_minimal: !0,\n  inherit_scale_class: !1,\n  scales: [{\n    unit: \"day\",\n    step: 1,\n    date: \"%d %M\"\n  }],\n  time_step: 60,\n  duration_step: 1,\n  task_date: \"%d %F %Y\",\n  time_picker: \"%H:%i\",\n  task_attribute: \"data-task-id\",\n  link_attribute: \"data-link-id\",\n  layer_attribute: \"data-layer\",\n  buttons_left: [\"gantt_save_btn\", \"gantt_cancel_btn\"],\n  _migrate_buttons: {\n    dhx_save_btn: \"gantt_save_btn\",\n    dhx_cancel_btn: \"gantt_cancel_btn\",\n    dhx_delete_btn: \"gantt_delete_btn\"\n  },\n  buttons_right: [\"gantt_delete_btn\"],\n  lightbox: {\n    sections: [{\n      name: \"description\",\n      height: 70,\n      map_to: \"text\",\n      type: \"textarea\",\n      focus: !0\n    }, {\n      name: \"time\",\n      type: \"duration\",\n      map_to: \"auto\"\n    }],\n    project_sections: [{\n      name: \"description\",\n      height: 70,\n      map_to: \"text\",\n      type: \"textarea\",\n      focus: !0\n    }, {\n      name: \"type\",\n      type: \"typeselect\",\n      map_to: \"type\"\n    }, {\n      name: \"time\",\n      type: \"duration\",\n      readonly: !0,\n      map_to: \"auto\"\n    }],\n    milestone_sections: [{\n      name: \"description\",\n      height: 70,\n      map_to: \"text\",\n      type: \"textarea\",\n      focus: !0\n    }, {\n      name: \"type\",\n      type: \"typeselect\",\n      map_to: \"type\"\n    }, {\n      name: \"time\",\n      type: \"duration\",\n      single_date: !0,\n      map_to: \"auto\"\n    }]\n  },\n  drag_lightbox: !0,\n  sort: !1,\n  details_on_create: !0,\n  details_on_dblclick: !0,\n  initial_scroll: !0,\n  task_scroll_offset: 100,\n  order_branch: !1,\n  order_branch_free: !1,\n  task_height: void 0,\n  bar_height: \"full\",\n  bar_height_padding: 9,\n  min_column_width: 70,\n  min_grid_column_width: 70,\n  grid_resizer_column_attribute: \"data-column-index\",\n  keep_grid_width: !1,\n  grid_resize: !1,\n  grid_elastic_columns: !1,\n  show_tasks_outside_timescale: !1,\n  show_unscheduled: !0,\n  resize_rows: !1,\n  task_grid_row_resizer_attribute: \"data-row-index\",\n  min_task_grid_row_height: 30,\n  row_height: 36,\n  readonly_property: \"readonly\",\n  editable_property: \"editable\",\n  calendar_property: \"calendar_id\",\n  resource_calendars: {},\n  dynamic_resource_calendars: !1,\n  inherit_calendar: !1,\n  type_renderers: {},\n  open_tree_initially: !1,\n  optimize_render: !0,\n  prevent_default_scroll: !1,\n  show_errors: !0,\n  wai_aria_attributes: !0,\n  smart_scales: !0,\n  rtl: !1,\n  placeholder_task: !1,\n  horizontal_scroll_key: \"shiftKey\",\n  drag_timeline: {\n    useKey: void 0,\n    ignore: \".gantt_task_line, .gantt_task_link\",\n    render: !1\n  },\n  drag_multiple: !0,\n  csp: \"auto\"\n});\nvar nt = typeof window < \"u\";\nconst mt = {\n  isIE: nt && (navigator.userAgent.indexOf(\"MSIE\") >= 0 || navigator.userAgent.indexOf(\"Trident\") >= 0),\n  isIE6: nt && !XMLHttpRequest && navigator.userAgent.indexOf(\"MSIE\") >= 0,\n  isIE7: nt && navigator.userAgent.indexOf(\"MSIE 7.0\") >= 0 && navigator.userAgent.indexOf(\"Trident\") < 0,\n  isIE8: nt && navigator.userAgent.indexOf(\"MSIE 8.0\") >= 0 && navigator.userAgent.indexOf(\"Trident\") >= 0,\n  isOpera: nt && navigator.userAgent.indexOf(\"Opera\") >= 0,\n  isChrome: nt && navigator.userAgent.indexOf(\"Chrome\") >= 0,\n  isKHTML: nt && (navigator.userAgent.indexOf(\"Safari\") >= 0 || navigator.userAgent.indexOf(\"Konqueror\") >= 0),\n  isFF: nt && navigator.userAgent.indexOf(\"Firefox\") >= 0,\n  isIPad: nt && navigator.userAgent.search(/iPad/gi) >= 0,\n  isEdge: nt && navigator.userAgent.indexOf(\"Edge\") != -1,\n  isNode: !nt || typeof navigator > \"u\" || !1\n};\nfunction Ne(t) {\n  if (typeof t == \"string\" || typeof t == \"number\") return t;\n  let e = \"\";\n  for (const n in t) {\n    let i = \"\";\n    t.hasOwnProperty(n) && (i = typeof t[n] == \"string\" ? encodeURIComponent(t[n]) : typeof t[n] == \"number\" ? String(t[n]) : encodeURIComponent(JSON.stringify(t[n])), i = n + \"=\" + i, e.length && (i = \"&\" + i), e += i);\n  }\n  return e;\n}\nfunction xt(t, e) {\n  var n = {\n    method: t\n  };\n  if (e.length === 0) throw new Error(\"Arguments list of query is wrong.\");\n  if (e.length === 1) return typeof e[0] == \"string\" ? (n.url = e[0], n.async = !0) : (n.url = e[0].url, n.async = e[0].async || !0, n.callback = e[0].callback, n.headers = e[0].headers), e[0].data ? typeof e[0].data != \"string\" ? n.data = Ne(e[0].data) : n.data = e[0].data : n.data = \"\", n;\n  switch (n.url = e[0], t) {\n    case \"GET\":\n    case \"DELETE\":\n      n.callback = e[1], n.headers = e[2];\n      break;\n    case \"POST\":\n    case \"PUT\":\n      e[1] ? typeof e[1] != \"string\" ? n.data = Ne(e[1]) : n.data = e[1] : n.data = \"\", n.callback = e[2], n.headers = e[3];\n  }\n  return n;\n}\nconst Le = {\n    date_to_str: (t, e, n) => {\n      t = t.replace(/%[a-zA-Z]/g, a => {\n        switch (a) {\n          case \"%d\":\n            return `\"+to_fixed(date.get${e ? \"UTC\" : \"\"}Date())+\"`;\n          case \"%m\":\n            return `\"+to_fixed((date.get${e ? \"UTC\" : \"\"}Month()+1))+\"`;\n          case \"%j\":\n            return `\"+date.get${e ? \"UTC\" : \"\"}Date()+\"`;\n          case \"%n\":\n            return `\"+(date.get${e ? \"UTC\" : \"\"}Month()+1)+\"`;\n          case \"%y\":\n            return `\"+to_fixed(date.get${e ? \"UTC\" : \"\"}FullYear()%100)+\"`;\n          case \"%Y\":\n            return `\"+date.get${e ? \"UTC\" : \"\"}FullYear()+\"`;\n          case \"%D\":\n            return `\"+locale.date.day_short[date.get${e ? \"UTC\" : \"\"}Day()]+\"`;\n          case \"%l\":\n            return `\"+locale.date.day_full[date.get${e ? \"UTC\" : \"\"}Day()]+\"`;\n          case \"%M\":\n            return `\"+locale.date.month_short[date.get${e ? \"UTC\" : \"\"}Month()]+\"`;\n          case \"%F\":\n            return `\"+locale.date.month_full[date.get${e ? \"UTC\" : \"\"}Month()]+\"`;\n          case \"%h\":\n            return `\"+to_fixed((date.get${e ? \"UTC\" : \"\"}Hours()+11)%12+1)+\"`;\n          case \"%g\":\n            return `\"+((date.get${e ? \"UTC\" : \"\"}Hours()+11)%12+1)+\"`;\n          case \"%G\":\n            return `\"+date.get${e ? \"UTC\" : \"\"}Hours()+\"`;\n          case \"%H\":\n            return `\"+to_fixed(date.get${e ? \"UTC\" : \"\"}Hours())+\"`;\n          case \"%i\":\n            return `\"+to_fixed(date.get${e ? \"UTC\" : \"\"}Minutes())+\"`;\n          case \"%a\":\n            return `\"+(date.get${e ? \"UTC\" : \"\"}Hours()>11?\"pm\":\"am\")+\"`;\n          case \"%A\":\n            return `\"+(date.get${e ? \"UTC\" : \"\"}Hours()>11?\"PM\":\"AM\")+\"`;\n          case \"%s\":\n            return `\"+to_fixed(date.get${e ? \"UTC\" : \"\"}Seconds())+\"`;\n          case \"%W\":\n            return '\"+to_fixed(getISOWeek(date))+\"';\n          case \"%w\":\n            return '\"+to_fixed(getWeek(date))+\"';\n          default:\n            return a;\n        }\n      });\n      const i = new Function(\"date\", \"to_fixed\", \"locale\", \"getISOWeek\", \"getWeek\", `return \"${t}\";`);\n      return a => i(a, n.date.to_fixed, n.locale, n.date.getISOWeek, n.date.getWeek);\n    },\n    str_to_date: (t, e, n) => {\n      let i = \"var temp=date.match(/[a-zA-Z]+|[0-9]+/g);\";\n      const a = t.match(/%[a-zA-Z]/g);\n      for (let o = 0; o < a.length; o++) switch (a[o]) {\n        case \"%j\":\n        case \"%d\":\n          i += `set[2]=temp[${o}]||1;`;\n          break;\n        case \"%n\":\n        case \"%m\":\n          i += `set[1]=(temp[${o}]||1)-1;`;\n          break;\n        case \"%y\":\n          i += `set[0]=temp[${o}]*1+(temp[${o}]>50?1900:2000);`;\n          break;\n        case \"%g\":\n        case \"%G\":\n        case \"%h\":\n        case \"%H\":\n          i += `set[3]=temp[${o}]||0;`;\n          break;\n        case \"%i\":\n          i += `set[4]=temp[${o}]||0;`;\n          break;\n        case \"%Y\":\n          i += `set[0]=temp[${o}]||0;`;\n          break;\n        case \"%a\":\n        case \"%A\":\n          i += `set[3]=set[3]%12+((temp[${o}]||'').toLowerCase()=='am'?0:12);`;\n          break;\n        case \"%s\":\n          i += `set[5]=temp[${o}]||0;`;\n          break;\n        case \"%M\":\n          i += `set[1]=locale.date.month_short_hash[temp[${o}]]||0;`;\n          break;\n        case \"%F\":\n          i += `set[1]=locale.date.month_full_hash[temp[${o}]]||0;`;\n      }\n      let r = \"set[0],set[1],set[2],set[3],set[4],set[5]\";\n      e && (r = ` Date.UTC(${r})`);\n      const s = new Function(\"date\", \"locale\", `var set=[0,0,1,0,0,0]; ${i} return new Date(${r});`);\n      return o => s(o, n.locale);\n    }\n  },\n  Pe = {\n    date_to_str: (t, e, n) => i => t.replace(/%[a-zA-Z]/g, a => {\n      switch (a) {\n        case \"%d\":\n          return e ? n.date.to_fixed(i.getUTCDate()) : n.date.to_fixed(i.getDate());\n        case \"%m\":\n          return e ? n.date.to_fixed(i.getUTCMonth() + 1) : n.date.to_fixed(i.getMonth() + 1);\n        case \"%j\":\n          return e ? i.getUTCDate() : i.getDate();\n        case \"%n\":\n          return e ? i.getUTCMonth() + 1 : i.getMonth() + 1;\n        case \"%y\":\n          return e ? n.date.to_fixed(i.getUTCFullYear() % 100) : n.date.to_fixed(i.getFullYear() % 100);\n        case \"%Y\":\n          return e ? i.getUTCFullYear() : i.getFullYear();\n        case \"%D\":\n          return e ? n.locale.date.day_short[i.getUTCDay()] : n.locale.date.day_short[i.getDay()];\n        case \"%l\":\n          return e ? n.locale.date.day_full[i.getUTCDay()] : n.locale.date.day_full[i.getDay()];\n        case \"%M\":\n          return e ? n.locale.date.month_short[i.getUTCMonth()] : n.locale.date.month_short[i.getMonth()];\n        case \"%F\":\n          return e ? n.locale.date.month_full[i.getUTCMonth()] : n.locale.date.month_full[i.getMonth()];\n        case \"%h\":\n          return e ? n.date.to_fixed((i.getUTCHours() + 11) % 12 + 1) : n.date.to_fixed((i.getHours() + 11) % 12 + 1);\n        case \"%g\":\n          return e ? (i.getUTCHours() + 11) % 12 + 1 : (i.getHours() + 11) % 12 + 1;\n        case \"%G\":\n          return e ? i.getUTCHours() : i.getHours();\n        case \"%H\":\n          return e ? n.date.to_fixed(i.getUTCHours()) : n.date.to_fixed(i.getHours());\n        case \"%i\":\n          return e ? n.date.to_fixed(i.getUTCMinutes()) : n.date.to_fixed(i.getMinutes());\n        case \"%a\":\n          return e ? i.getUTCHours() > 11 ? \"pm\" : \"am\" : i.getHours() > 11 ? \"pm\" : \"am\";\n        case \"%A\":\n          return e ? i.getUTCHours() > 11 ? \"PM\" : \"AM\" : i.getHours() > 11 ? \"PM\" : \"AM\";\n        case \"%s\":\n          return e ? n.date.to_fixed(i.getUTCSeconds()) : n.date.to_fixed(i.getSeconds());\n        case \"%W\":\n          return e ? n.date.to_fixed(n.date.getUTCISOWeek(i)) : n.date.to_fixed(n.date.getISOWeek(i));\n        default:\n          return a;\n      }\n    }),\n    str_to_date: (t, e, n) => i => {\n      const a = [0, 0, 1, 0, 0, 0],\n        r = i.match(/[a-zA-Z]+|[0-9]+/g),\n        s = t.match(/%[a-zA-Z]/g);\n      for (let o = 0; o < s.length; o++) switch (s[o]) {\n        case \"%j\":\n        case \"%d\":\n          a[2] = r[o] || 1;\n          break;\n        case \"%n\":\n        case \"%m\":\n          a[1] = (r[o] || 1) - 1;\n          break;\n        case \"%y\":\n          a[0] = 1 * r[o] + (r[o] > 50 ? 1900 : 2e3);\n          break;\n        case \"%g\":\n        case \"%G\":\n        case \"%h\":\n        case \"%H\":\n          a[3] = r[o] || 0;\n          break;\n        case \"%i\":\n          a[4] = r[o] || 0;\n          break;\n        case \"%Y\":\n          a[0] = r[o] || 0;\n          break;\n        case \"%a\":\n        case \"%A\":\n          a[3] = a[3] % 12 + ((r[o] || \"\").toLowerCase() === \"am\" ? 0 : 12);\n          break;\n        case \"%s\":\n          a[5] = r[o] || 0;\n          break;\n        case \"%M\":\n          a[1] = n.locale.date.month_short_hash[r[o]] || 0;\n          break;\n        case \"%F\":\n          a[1] = n.locale.date.month_full_hash[r[o]] || 0;\n      }\n      return e ? new Date(Date.UTC(a[0], a[1], a[2], a[3], a[4], a[5])) : new Date(a[0], a[1], a[2], a[3], a[4], a[5]);\n    }\n  };\nfunction Kn(t) {\n  var e = null;\n  function n() {\n    var a = !1;\n    return t.config.csp === \"auto\" ? (e === null && function () {\n      try {\n        new Function(\"canUseCsp = false;\");\n      } catch {\n        e = !0;\n      }\n    }(), a = e) : a = t.config.csp, a;\n  }\n  var i = {\n    init: function () {\n      for (var a = t.locale, r = a.date.month_short, s = a.date.month_short_hash = {}, o = 0; o < r.length; o++) s[r[o]] = o;\n      for (r = a.date.month_full, s = a.date.month_full_hash = {}, o = 0; o < r.length; o++) s[r[o]] = o;\n    },\n    date_part: function (a) {\n      var r = new Date(a);\n      return a.setHours(0), this.hour_start(a), a.getHours() && (a.getDate() < r.getDate() || a.getMonth() < r.getMonth() || a.getFullYear() < r.getFullYear()) && a.setTime(a.getTime() + 36e5 * (24 - a.getHours())), a;\n    },\n    time_part: function (a) {\n      return (a.valueOf() / 1e3 - 60 * a.getTimezoneOffset()) % 86400;\n    },\n    week_start: function (a) {\n      var r = a.getDay();\n      return t.config.start_on_monday && (r === 0 ? r = 6 : r--), this.date_part(this.add(a, -1 * r, \"day\"));\n    },\n    month_start: function (a) {\n      return a.setDate(1), this.date_part(a);\n    },\n    quarter_start: function (a) {\n      this.month_start(a);\n      var r,\n        s = a.getMonth();\n      return r = s >= 9 ? 9 : s >= 6 ? 6 : s >= 3 ? 3 : 0, a.setMonth(r), a;\n    },\n    year_start: function (a) {\n      return a.setMonth(0), this.month_start(a);\n    },\n    day_start: function (a) {\n      return this.date_part(a);\n    },\n    hour_start: function (a) {\n      return a.getMinutes() && a.setMinutes(0), this.minute_start(a), a;\n    },\n    minute_start: function (a) {\n      return a.getSeconds() && a.setSeconds(0), a.getMilliseconds() && a.setMilliseconds(0), a;\n    },\n    _add_days: function (a, r, s) {\n      a.setDate(a.getDate() + r);\n      var o = r >= 0,\n        l = !s.getHours() && a.getHours(),\n        d = a.getDate() <= s.getDate() || a.getMonth() < s.getMonth() || a.getFullYear() < s.getFullYear();\n      return o && l && d && a.setTime(a.getTime() + 36e5 * (24 - a.getHours())), r > 1 && l && a.setHours(0), a;\n    },\n    add: function (a, r, s) {\n      var o = new Date(a.valueOf());\n      switch (s) {\n        case \"day\":\n          o = this._add_days(o, r, a);\n          break;\n        case \"week\":\n          o = this._add_days(o, 7 * r, a);\n          break;\n        case \"month\":\n          o.setMonth(o.getMonth() + r);\n          break;\n        case \"year\":\n          o.setYear(o.getFullYear() + r);\n          break;\n        case \"hour\":\n          o.setTime(o.getTime() + 60 * r * 60 * 1e3);\n          break;\n        case \"minute\":\n          o.setTime(o.getTime() + 60 * r * 1e3);\n          break;\n        default:\n          return this[\"add_\" + s](a, r, s);\n      }\n      return o;\n    },\n    add_quarter: function (a, r) {\n      return this.add(a, 3 * r, \"month\");\n    },\n    to_fixed: function (a) {\n      return a < 10 ? \"0\" + a : a;\n    },\n    copy: function (a) {\n      return new Date(a.valueOf());\n    },\n    date_to_str: function (a, r) {\n      var s = Le;\n      return n() && (s = Pe), s.date_to_str(a, r, t);\n    },\n    str_to_date: function (a, r) {\n      var s = Le;\n      return n() && (s = Pe), s.str_to_date(a, r, t);\n    },\n    getISOWeek: function (a) {\n      return t.date._getWeekNumber(a, !0);\n    },\n    _getWeekNumber: function (a, r) {\n      if (!a) return !1;\n      var s = a.getDay();\n      r && s === 0 && (s = 7);\n      var o = new Date(a.valueOf());\n      o.setDate(a.getDate() + (4 - s));\n      var l = o.getFullYear(),\n        d = Math.round((o.getTime() - new Date(l, 0, 1).getTime()) / 864e5);\n      return 1 + Math.floor(d / 7);\n    },\n    getWeek: function (a) {\n      return t.date._getWeekNumber(a, t.config.start_on_monday);\n    },\n    getUTCISOWeek: function (a) {\n      return t.date.getISOWeek(a);\n    },\n    convert_to_utc: function (a) {\n      return new Date(a.getUTCFullYear(), a.getUTCMonth(), a.getUTCDate(), a.getUTCHours(), a.getUTCMinutes(), a.getUTCSeconds());\n    },\n    parseDate: function (a, r) {\n      return a && !a.getFullYear && (typeof r != \"function\" && (r = typeof r == \"string\" ? r === \"parse_date\" || r === \"xml_date\" ? t.defined(t.templates.xml_date) ? t.templates.xml_date : t.templates.parse_date : t.defined(t.templates[r]) ? t.templates[r] : t.date.str_to_date(r) : t.defined(t.templates.xml_date) ? t.templates.xml_date : t.templates.parse_date), a = a ? r(a) : null), a;\n    }\n  };\n  return i;\n}\nclass Xn {\n  constructor(e) {\n    const {\n      url: n,\n      token: i\n    } = e;\n    this._url = n, this._token = i, this._mode = 1, this._seed = 1, this._queue = [], this.data = {}, this.api = {}, this._events = {};\n  }\n  headers() {\n    return {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n      \"Remote-Token\": this._token\n    };\n  }\n  fetch(e, n) {\n    const i = {\n      credentials: \"include\",\n      headers: this.headers()\n    };\n    return n && (i.method = \"POST\", i.body = n), fetch(e, i).then(a => a.json());\n  }\n  load(e) {\n    return e && (this._url = e), this.fetch(this._url).then(n => this.parse(n));\n  }\n  parse(e) {\n    const {\n      key: n,\n      websocket: i\n    } = e;\n    n && (this._token = e.key);\n    for (const a in e.data) this.data[a] = e.data[a];\n    for (const a in e.api) {\n      const r = this.api[a] = {},\n        s = e.api[a];\n      for (const o in s) r[o] = this._wrapper(a + \".\" + o);\n    }\n    return i && this.connect(), this;\n  }\n  connect() {\n    const e = this._socket;\n    e && (this._socket = null, e.onclose = function () {}, e.close()), this._mode = 2, this._socket = function (n, i, a, r) {\n      let s = i;\n      s[0] === \"/\" && (s = document.location.protocol + \"//\" + document.location.host + i), s = s.replace(/^http(s|):/, \"ws$1:\");\n      const o = s.indexOf(\"?\") != -1 ? \"&\" : \"?\";\n      s = `${s}${o}token=${a}&ws=1`;\n      const l = new WebSocket(s);\n      return l.onclose = () => setTimeout(() => n.connect(), 2e3), l.onmessage = d => {\n        const c = JSON.parse(d.data);\n        switch (c.action) {\n          case \"result\":\n            n.result(c.body, []);\n            break;\n          case \"event\":\n            n.fire(c.body.name, c.body.value);\n            break;\n          case \"start\":\n            r();\n            break;\n          default:\n            n.onError(c.data);\n        }\n      }, l;\n    }(this, this._url, this._token, () => (this._mode = 3, this._send(), this._resubscribe(), this));\n  }\n  _wrapper(e) {\n    return function () {\n      const n = [].slice.call(arguments);\n      let i = null;\n      const a = new Promise((r, s) => {\n        i = {\n          data: {\n            id: this._uid(),\n            name: e,\n            args: n\n          },\n          status: 1,\n          resolve: r,\n          reject: s\n        }, this._queue.push(i);\n      });\n      return this.onCall(i, a), this._mode === 3 ? this._send(i) : setTimeout(() => this._send(), 1), a;\n    }.bind(this);\n  }\n  _uid() {\n    return (this._seed++).toString();\n  }\n  _send(e) {\n    if (this._mode == 2) return void setTimeout(() => this._send(), 100);\n    const n = e ? [e] : this._queue.filter(a => a.status === 1);\n    if (!n.length) return;\n    const i = n.map(a => (a.status = 2, a.data));\n    this._mode !== 3 ? this.fetch(this._url, JSON.stringify(i)).catch(a => this.onError(a)).then(a => this.result(a, i)) : this._socket.send(JSON.stringify({\n      action: \"call\",\n      body: i\n    }));\n  }\n  result(e, n) {\n    const i = {};\n    if (e) for (let a = 0; a < e.length; a++) i[e[a].id] = e[a];else for (let a = 0; a < n.length; a++) i[n[a].id] = {\n      id: n[a].id,\n      error: \"Network Error\",\n      data: null\n    };\n    for (let a = this._queue.length - 1; a >= 0; a--) {\n      const r = this._queue[a],\n        s = i[r.data.id];\n      s && (this.onResponse(r, s), s.error ? r.reject(s.error) : r.resolve(s.data), this._queue.splice(a, 1));\n    }\n  }\n  on(e, n) {\n    const i = this._uid();\n    let a = this._events[e];\n    const r = !!a;\n    return r || (a = this._events[e] = []), a.push({\n      id: i,\n      handler: n\n    }), r || this._mode != 3 || this._socket.send(JSON.stringify({\n      action: \"subscribe\",\n      name: e\n    })), {\n      name: e,\n      id: i\n    };\n  }\n  _resubscribe() {\n    if (this._mode == 3) for (const e in this._events) this._socket.send(JSON.stringify({\n      action: \"subscribe\",\n      name: e\n    }));\n  }\n  detach(e) {\n    if (!e) {\n      if (this._mode == 3) for (const r in this._events) this._socket.send(JSON.stringify({\n        action: \"unsubscribe\",\n        key: r\n      }));\n      return void (this._events = {});\n    }\n    const {\n        id: n,\n        name: i\n      } = e,\n      a = this._events[i];\n    if (a) {\n      const r = a.filter(s => s.id != n);\n      r.length ? this._events[i] = r : (delete this._events[i], this._mode == 3 && this._socket.send(JSON.stringify({\n        action: \"unsubscribe\",\n        name: i\n      })));\n    }\n  }\n  fire(e, n) {\n    const i = this._events[e];\n    if (i) for (let a = 0; a < i.length; a++) i[a].handler(n);\n  }\n  onError(e) {\n    return null;\n  }\n  onCall(e, n) {}\n  onResponse(e, n) {}\n}\nconst Zn = function (t, e) {\n  const n = new Xn({\n    url: t,\n    token: e\n  });\n  n.fetch = function (i, a) {\n    const r = {\n      headers: this.headers()\n    };\n    return a && (r.method = \"POST\", r.body = a), fetch(i, r).then(s => s.json());\n  }, this._ready = n.load().then(i => this._remote = i), this.ready = function () {\n    return this._ready;\n  }, this.on = function (i, a) {\n    this.ready().then(r => {\n      if (typeof i == \"string\") r.on(i, a);else for (const s in i) r.on(s, i[s]);\n    });\n  };\n};\nfunction un(t, e) {\n  if (!e) return !0;\n  if (t._on_timeout) return !1;\n  var n = Math.ceil(1e3 / e);\n  return n < 2 || (setTimeout(function () {\n    delete t._on_timeout;\n  }, n), t._on_timeout = !0), !0;\n}\nvar Qn = function () {\n  var t = {};\n  return {\n    getState: function (e) {\n      if (t[e]) return t[e].method();\n      var n = {};\n      for (var i in t) t[i].internal || L(n, t[i].method(), !0);\n      return n;\n    },\n    registerProvider: function (e, n, i) {\n      t[e] = {\n        method: n,\n        internal: i\n      };\n    },\n    unregisterProvider: function (e) {\n      delete t[e];\n    }\n  };\n};\nconst ti = Promise;\nvar tt = {\n  $create: function (t) {\n    return L(t || [], this);\n  },\n  $removeAt: function (t, e) {\n    t >= 0 && this.splice(t, e || 1);\n  },\n  $remove: function (t) {\n    this.$removeAt(this.$find(t));\n  },\n  $insertAt: function (t, e) {\n    if (e || e === 0) {\n      var n = this.splice(e, this.length - e);\n      this[e] = t, this.push.apply(this, n);\n    } else this.push(t);\n  },\n  $find: function (t) {\n    for (var e = 0; e < this.length; e++) if (t == this[e]) return e;\n    return -1;\n  },\n  $each: function (t, e) {\n    for (var n = 0; n < this.length; n++) t.call(e || this, this[n]);\n  },\n  $map: function (t, e) {\n    for (var n = 0; n < this.length; n++) this[n] = t.call(e || this, this[n]);\n    return this;\n  },\n  $filter: function (t, e) {\n    for (var n = 0; n < this.length; n++) t.call(e || this, this[n]) || (this.splice(n, 1), n--);\n    return this;\n  }\n};\nfunction Rt(t, e, n, i) {\n  return (i = e ? e.config : i) && i.placeholder_task && n.exists(t) ? n.getItem(t).type === i.types.placeholder : !1;\n}\nvar it = function (t) {\n  return this.pull = {}, this.$initItem = t.initItem, this.visibleOrder = tt.$create(), this.fullOrder = tt.$create(), this._skip_refresh = !1, this._filterRule = null, this._searchVisibleOrder = {}, this._indexRangeCache = {}, this._getItemsCache = null, this.$config = t, ot(this), this._attachDataChange(function () {\n    return this._indexRangeCache = {}, this._getItemsCache = null, !0;\n  }), this;\n};\nit.prototype = {\n  _attachDataChange: function (t) {\n    this.attachEvent(\"onClearAll\", t), this.attachEvent(\"onBeforeParse\", t), this.attachEvent(\"onBeforeUpdate\", t), this.attachEvent(\"onBeforeDelete\", t), this.attachEvent(\"onBeforeAdd\", t), this.attachEvent(\"onParse\", t), this.attachEvent(\"onBeforeFilter\", t);\n  },\n  _parseInner: function (t) {\n    for (var e = null, n = [], i = 0, a = t.length; i < a; i++) e = t[i], this.$initItem && (this.$config.copyOnParse() && (e = G(e)), e = this.$initItem(e)), this.callEvent(\"onItemLoading\", [e]) && (this.pull.hasOwnProperty(e.id) || this.fullOrder.push(e.id), n.push(e), this.pull[e.id] = e);\n    return n;\n  },\n  parse: function (t) {\n    this.isSilent() || this.callEvent(\"onBeforeParse\", [t]);\n    var e = this._parseInner(t);\n    this.isSilent() || (this.refresh(), this.callEvent(\"onParse\", [e]));\n  },\n  getItem: function (t) {\n    return this.pull[t];\n  },\n  _updateOrder: function (t) {\n    t.call(this.visibleOrder), t.call(this.fullOrder);\n  },\n  updateItem: function (t, e) {\n    if (j(e) || (e = this.getItem(t)), !this.isSilent() && this.callEvent(\"onBeforeUpdate\", [e.id, e]) === !1) return !1;\n    L(this.pull[t], e, !0), this.isSilent() || (this.callEvent(\"onAfterUpdate\", [e.id, e]), this.callEvent(\"onStoreUpdated\", [e.id, e, \"update\"]));\n  },\n  _removeItemInner: function (t) {\n    this._updateOrder(function () {\n      this.$remove(t);\n    }), delete this.pull[t];\n  },\n  removeItem: function (t) {\n    var e = this.getItem(t);\n    if (!this.isSilent() && this.callEvent(\"onBeforeDelete\", [e.id, e]) === !1) return !1;\n    this.callEvent(\"onAfterDeleteConfirmed\", [e.id, e]), this._removeItemInner(t), this.isSilent() && this.callEvent(\"onAfterSilentDelete\", [e.id, e]), this.isSilent() || (this.filter(), this.callEvent(\"onAfterDelete\", [e.id, e]), this.callEvent(\"onStoreUpdated\", [e.id, e, \"delete\"]));\n  },\n  _addItemInner: function (t, e) {\n    if (this.exists(t.id)) this.silent(function () {\n      this.updateItem(t.id, t);\n    });else {\n      var n = this.visibleOrder,\n        i = n.length;\n      (!j(e) || e < 0) && (e = i), e > i && (e = Math.min(n.length, e));\n    }\n    this.pull[t.id] = t, this._updateOrder(function () {\n      this.$find(t.id) === -1 && this.$insertAt(t.id, e);\n    }), this.filter();\n  },\n  isVisible: function (t) {\n    return this.visibleOrder.$find(t) > -1;\n  },\n  getVisibleItems: function () {\n    return this.getIndexRange();\n  },\n  addItem: function (t, e) {\n    return j(t.id) || (t.id = st()), this.$initItem && (t = this.$initItem(t)), !(!this.isSilent() && this.callEvent(\"onBeforeAdd\", [t.id, t]) === !1) && (this._addItemInner(t, e), this.isSilent() || (this.callEvent(\"onAfterAdd\", [t.id, t]), this.callEvent(\"onStoreUpdated\", [t.id, t, \"add\"])), t.id);\n  },\n  _changeIdInner: function (t, e) {\n    this.pull[t] && (this.pull[e] = this.pull[t]);\n    var n = this._searchVisibleOrder[t];\n    this.pull[e].id = e, this._updateOrder(function () {\n      this[this.$find(t)] = e;\n    }), this._searchVisibleOrder[e] = n, delete this._searchVisibleOrder[t], delete this.pull[t];\n  },\n  changeId: function (t, e) {\n    this._changeIdInner(t, e), this.callEvent(\"onIdChange\", [t, e]);\n  },\n  exists: function (t) {\n    return !!this.pull[t];\n  },\n  _moveInner: function (t, e) {\n    var n = this.getIdByIndex(t);\n    this._updateOrder(function () {\n      this.$removeAt(t), this.$insertAt(n, Math.min(this.length, e));\n    });\n  },\n  move: function (t, e) {\n    var n = this.getIdByIndex(t),\n      i = this.getItem(n);\n    this._moveInner(t, e), this.isSilent() || this.callEvent(\"onStoreUpdated\", [i.id, i, \"move\"]);\n  },\n  clearAll: function () {\n    this.$destroyed || (this.silent(function () {\n      this.unselect();\n    }), this.pull = {}, this.visibleOrder = tt.$create(), this.fullOrder = tt.$create(), this.isSilent() || (this.callEvent(\"onClearAll\", []), this.refresh()));\n  },\n  silent: function (t, e) {\n    var n = !1;\n    this.isSilent() && (n = !0), this._skip_refresh = !0, t.call(e || this), n || (this._skip_refresh = !1);\n  },\n  isSilent: function () {\n    return !!this._skip_refresh;\n  },\n  arraysEqual: function (t, e) {\n    if (t.length !== e.length) return !1;\n    for (var n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;\n    return !0;\n  },\n  refresh: function (t, e) {\n    var n, i;\n    if (!this.isSilent() && (t && (n = this.getItem(t)), i = t ? [t, n, \"paint\"] : [null, null, null], this.callEvent(\"onBeforeStoreUpdate\", i) !== !1)) {\n      var a = this._quick_refresh && !this._mark_recompute;\n      if (this._mark_recompute = !1, t) {\n        if (!e && !a) {\n          var r = this.visibleOrder;\n          this.filter(), this.arraysEqual(r, this.visibleOrder) || (t = void 0);\n        }\n      } else a || this.filter();\n      i = t ? [t, n, \"paint\"] : [null, null, null], this.callEvent(\"onStoreUpdated\", i);\n    }\n  },\n  count: function () {\n    return this.fullOrder.length;\n  },\n  countVisible: function () {\n    return this.visibleOrder.length;\n  },\n  sort: function (t) {},\n  serialize: function () {},\n  eachItem: function (t) {\n    for (var e = 0; e < this.fullOrder.length; e++) {\n      var n = this.getItem(this.fullOrder[e]);\n      t.call(this, n);\n    }\n  },\n  find: function (t) {\n    var e = [];\n    return this.eachItem(function (n) {\n      t(n) && e.push(n);\n    }), e;\n  },\n  filter: function (t) {\n    this.isSilent() || this.callEvent(\"onBeforeFilter\", []), this.callEvent(\"onPreFilter\", []);\n    var e = tt.$create(),\n      n = [];\n    this.eachItem(function (a) {\n      this.callEvent(\"onFilterItem\", [a.id, a]) && (Rt(a.id, null, this, this._ganttConfig) ? n.push(a.id) : e.push(a.id));\n    });\n    for (var i = 0; i < n.length; i++) e.push(n[i]);\n    for (this.visibleOrder = e, this._searchVisibleOrder = {}, i = 0; i < this.visibleOrder.length; i++) this._searchVisibleOrder[this.visibleOrder[i]] = i;\n    this.isSilent() || this.callEvent(\"onFilter\", []);\n  },\n  getIndexRange: function (t, e) {\n    var n = Math.min(e || 1 / 0, this.countVisible() - 1),\n      i = t || 0,\n      a = i + \"-\" + n;\n    if (this._indexRangeCache[a]) return this._indexRangeCache[a].slice();\n    for (var r = [], s = i; s <= n; s++) r.push(this.getItem(this.visibleOrder[s]));\n    return this._indexRangeCache[a] = r.slice(), r;\n  },\n  getItems: function () {\n    if (this._getItemsCache) return this._getItemsCache.slice();\n    var t = [];\n    for (var e in this.pull) t.push(this.pull[e]);\n    return this._getItemsCache = t.slice(), t;\n  },\n  getIdByIndex: function (t) {\n    return this.visibleOrder[t];\n  },\n  getIndexById: function (t) {\n    var e = this._searchVisibleOrder[t];\n    return e === void 0 && (e = -1), e;\n  },\n  _getNullIfUndefined: function (t) {\n    return t === void 0 ? null : t;\n  },\n  getFirst: function () {\n    return this._getNullIfUndefined(this.visibleOrder[0]);\n  },\n  getLast: function () {\n    return this._getNullIfUndefined(this.visibleOrder[this.visibleOrder.length - 1]);\n  },\n  getNext: function (t) {\n    return this._getNullIfUndefined(this.visibleOrder[this.getIndexById(t) + 1]);\n  },\n  getPrev: function (t) {\n    return this._getNullIfUndefined(this.visibleOrder[this.getIndexById(t) - 1]);\n  },\n  destructor: function () {\n    this.callEvent(\"onDestroy\", []), this.detachAllEvents(), this.$destroyed = !0, this.pull = null, this.$initItem = null, this.visibleOrder = null, this.fullOrder = null, this._skip_refresh = null, this._filterRule = null, this._searchVisibleOrder = null, this._indexRangeCache = {};\n  }\n};\nvar hn = function (t) {\n  var e;\n  it.apply(this, [t]), this._branches = {}, this.pull = {}, this.$initItem = function (o) {\n    var l = o;\n    t.initItem && (l = t.initItem(l));\n    var d = this.getItem(o.id);\n    return d && !lt(d.parent, l.parent) && this.move(l.id, l.$index || -1, l.parent || this._ganttConfig.root_id), l;\n  }, this.$parentProperty = t.parentProperty || \"parent\", typeof t.rootId != \"function\" ? this.$getRootId = (e = t.rootId || 0, function () {\n    return e;\n  }) : this.$getRootId = t.rootId, this.$openInitially = t.openInitially, this.visibleOrder = tt.$create(), this.fullOrder = tt.$create(), this._searchVisibleOrder = {}, this._indexRangeCache = {}, this._eachItemMainRangeCache = null, this._getItemsCache = null, this._skip_refresh = !1, this._ganttConfig = null, t.getConfig && (this._ganttConfig = t.getConfig());\n  var n = {},\n    i = {},\n    a = {},\n    r = {},\n    s = !1;\n  return this._attachDataChange(function () {\n    return this._indexRangeCache = {}, this._eachItemMainRangeCache = null, this._getItemsCache = null, !0;\n  }), this.attachEvent(\"onPreFilter\", function () {\n    this._indexRangeCache = {}, this._eachItemMainRangeCache = null, n = {}, i = {}, a = {}, r = {}, s = !1, this.eachItem(function (o) {\n      var l = this.getParent(o.id);\n      o.$open && a[l] !== !1 ? a[o.id] = !0 : a[o.id] = !1, this._isSplitItem(o) && (s = !0, n[o.id] = !0, i[o.id] = !0), s && i[l] && (i[o.id] = !0), a[l] || a[l] === void 0 ? r[o.id] = !0 : r[o.id] = !1;\n    });\n  }), this.attachEvent(\"onFilterItem\", function (o, l) {\n    var d = !1;\n    this._ganttConfig && (d = this._ganttConfig.open_split_tasks);\n    var c = r[l.id];\n    return s && (c && i[l.id] && !n[l.id] && (c = !!d), i[l.id] && !n[l.id] && (l.$split_subtask = !0)), l.$expanded_branch = !!r[l.id], !!c;\n  }), this.attachEvent(\"onFilter\", function () {\n    n = {}, i = {}, a = {}, r = {};\n  }), this;\n};\nfunction lt(t, e) {\n  return String(t) === String(e);\n}\nfunction V(t) {\n  return mt.isNode || !t.$root;\n}\nhn.prototype = L({\n  _buildTree: function (t) {\n    for (var e = null, n = this.$getRootId(), i = 0, a = t.length; i < a; i++) e = t[i], this.setParent(e, at(this.getParent(e), n) || n);\n    for (i = 0, a = t.length; i < a; i++) e = t[i], this._add_branch(e), e.$level = this.calculateItemLevel(e), e.$local_index = this.getBranchIndex(e.id), j(e.$open) || (e.$open = j(e.open) ? e.open : this.$openInitially());\n    this._updateOrder();\n  },\n  _isSplitItem: function (t) {\n    return t.render == \"split\" && this.hasChild(t.id);\n  },\n  parse: function (t) {\n    this._skip_refresh || this.callEvent(\"onBeforeParse\", [t]);\n    var e = this._parseInner(t);\n    this._buildTree(e), this.filter(), this._skip_refresh || this.callEvent(\"onParse\", [e]);\n  },\n  _addItemInner: function (t, e) {\n    var n = this.getParent(t);\n    j(n) || (n = this.$getRootId(), this.setParent(t, n));\n    var i = this.getIndexById(n) + Math.min(Math.max(e, 0), this.visibleOrder.length);\n    1 * i !== i && (i = void 0), it.prototype._addItemInner.call(this, t, i), this.setParent(t, n), t.hasOwnProperty(\"$rendered_parent\") && this._move_branch(t, t.$rendered_parent), this._add_branch(t, e);\n  },\n  _changeIdInner: function (t, e) {\n    var n = this.getChildren(t),\n      i = this._searchVisibleOrder[t];\n    it.prototype._changeIdInner.call(this, t, e);\n    var a = this.getParent(e);\n    this._replace_branch_child(a, t, e), this._branches[t] && (this._branches[e] = this._branches[t]);\n    for (var r = 0; r < n.length; r++) {\n      var s = this.getItem(n[r]);\n      s[this.$parentProperty] = e, s.$rendered_parent = e;\n    }\n    this._searchVisibleOrder[e] = i, delete this._branches[t];\n  },\n  _traverseBranches: function (t, e) {\n    j(e) || (e = this.$getRootId());\n    var n = this._branches[e];\n    if (n) for (var i = 0; i < n.length; i++) {\n      var a = n[i];\n      t.call(this, a), this._branches[a] && this._traverseBranches(t, a);\n    }\n  },\n  _updateOrder: function (t) {\n    this.fullOrder = tt.$create(), this._traverseBranches(function (e) {\n      this.fullOrder.push(e);\n    }), t && it.prototype._updateOrder.call(this, t);\n  },\n  _removeItemInner: function (t) {\n    var e = [];\n    this.eachItem(function (i) {\n      e.push(i);\n    }, t), e.push(this.getItem(t));\n    for (var n = 0; n < e.length; n++) this._move_branch(e[n], this.getParent(e[n]), null), it.prototype._removeItemInner.call(this, e[n].id), this._move_branch(e[n], this.getParent(e[n]), null);\n  },\n  move: function (t, e, n) {\n    var i = arguments[3],\n      a = (this._ganttConfig || {}).root_id || 0;\n    if (i = at(i, a)) {\n      if (i === t) return;\n      n = this.getParent(i), e = this.getBranchIndex(i);\n    }\n    if (!lt(t, n)) {\n      j(n) || (n = this.$getRootId());\n      var r = this.getItem(t),\n        s = this.getParent(r.id),\n        o = this.getChildren(n);\n      if (e == -1 && (e = o.length + 1), lt(s, n) && this.getBranchIndex(t) == e) return;\n      if (this.callEvent(\"onBeforeItemMove\", [t, n, e]) === !1) return !1;\n      for (var l = [], d = 0; d < o.length; d++) Rt(o[d], null, this, this._ganttConfig) && (l.push(o[d]), o.splice(d, 1), d--);\n      this._replace_branch_child(s, t);\n      var c = (o = this.getChildren(n))[e];\n      (c = at(c, a)) ? o = o.slice(0, e).concat([t]).concat(o.slice(e)) : o.push(t), l.length && (o = o.concat(l)), lt(r.$rendered_parent, s) || lt(s, n) || (r.$rendered_parent = s), this.setParent(r, n), this._branches[n] = o;\n      var u = this.calculateItemLevel(r) - r.$level;\n      r.$level += u, this.eachItem(function (h) {\n        h.$level += u;\n      }, r.id, this), this._moveInner(this.getIndexById(t), this.getIndexById(n) + e), this.callEvent(\"onAfterItemMove\", [t, n, e]), this.refresh();\n    }\n  },\n  getBranchIndex: function (t) {\n    var e = this.getChildren(this.getParent(t));\n    let n = e.indexOf(t + \"\");\n    return n == -1 && (n = e.indexOf(+t)), n;\n  },\n  hasChild: function (t) {\n    var e = this._branches[t];\n    return e && e.length;\n  },\n  getChildren: function (t) {\n    var e = this._branches[t];\n    return e || tt.$create();\n  },\n  isChildOf: function (t, e) {\n    if (!this.exists(t)) return !1;\n    if (e === this.$getRootId()) return !0;\n    if (!this.hasChild(e)) return !1;\n    var n = this.getItem(t),\n      i = this.getParent(t);\n    if (this.getItem(e).$level >= n.$level) return !1;\n    for (; n && this.exists(i);) {\n      if ((n = this.getItem(i)) && lt(n.id, e)) return !0;\n      i = this.getParent(n);\n    }\n    return !1;\n  },\n  getSiblings: function (t) {\n    if (!this.exists(t)) return tt.$create();\n    var e = this.getParent(t);\n    return this.getChildren(e);\n  },\n  getNextSibling: function (t) {\n    for (var e = this.getSiblings(t), n = 0, i = e.length; n < i; n++) if (lt(e[n], t)) {\n      var a = e[n + 1];\n      return a === 0 && n > 0 && (a = \"0\"), a || null;\n    }\n    return null;\n  },\n  getPrevSibling: function (t) {\n    for (var e = this.getSiblings(t), n = 0, i = e.length; n < i; n++) if (lt(e[n], t)) {\n      var a = e[n - 1];\n      return a === 0 && n > 0 && (a = \"0\"), a || null;\n    }\n    return null;\n  },\n  getParent: function (t) {\n    var e = null;\n    return (e = t.id !== void 0 ? t : this.getItem(t)) ? e[this.$parentProperty] : this.$getRootId();\n  },\n  clearAll: function () {\n    this._branches = {}, it.prototype.clearAll.call(this);\n  },\n  calculateItemLevel: function (t) {\n    var e = 0;\n    return this.eachParent(function () {\n      e++;\n    }, t), e;\n  },\n  _setParentInner: function (t, e, n) {\n    n || (t.hasOwnProperty(\"$rendered_parent\") ? this._move_branch(t, t.$rendered_parent, e) : this._move_branch(t, t[this.$parentProperty], e));\n  },\n  setParent: function (t, e, n) {\n    this._setParentInner(t, e, n), t[this.$parentProperty] = e;\n  },\n  _eachItemCached: function (t, e) {\n    for (var n = 0, i = e.length; n < i; n++) t.call(this, e[n]);\n  },\n  _eachItemIterate: function (t, e, n) {\n    var i = this.getChildren(e);\n    for (i.length && (i = i.slice().reverse()); i.length;) {\n      var a = i.pop(),\n        r = this.getItem(a);\n      if (t.call(this, r), n && n.push(r), this.hasChild(r.id)) for (var s = this.getChildren(r.id), o = s.length - 1; o >= 0; o--) i.push(s[o]);\n    }\n  },\n  eachItem: function (t, e) {\n    var n = this.$getRootId();\n    j(e) || (e = n);\n    var i = at(e, n) || n,\n      a = !1,\n      r = !1,\n      s = null;\n    i === n && (this._eachItemMainRangeCache ? (a = !0, s = this._eachItemMainRangeCache) : (r = !0, s = this._eachItemMainRangeCache = [])), a ? this._eachItemCached(t, s) : this._eachItemIterate(t, i, r ? s : null);\n  },\n  eachParent: function (t, e) {\n    for (var n = {}, i = e, a = this.getParent(i); this.exists(a);) {\n      if (n[a]) throw new Error(\"Invalid tasks tree. Cyclic reference has been detected on task \" + a);\n      n[a] = !0, i = this.getItem(a), t.call(this, i), a = this.getParent(i);\n    }\n  },\n  _add_branch: function (t, e, n) {\n    var i = n === void 0 ? this.getParent(t) : n;\n    this.hasChild(i) || (this._branches[i] = tt.$create());\n    var a = this.getChildren(i);\n    a.indexOf(t.id + \"\") > -1 || a.indexOf(+t.id) > -1 || (1 * e == e ? a.splice(e, 0, t.id) : a.push(t.id), t.$rendered_parent = i);\n  },\n  _move_branch: function (t, e, n) {\n    this._eachItemMainRangeCache = null, this._replace_branch_child(e, t.id), this.exists(n) || lt(n, this.$getRootId()) ? this._add_branch(t, void 0, n) : delete this._branches[t.id], t.$level = this.calculateItemLevel(t), this.eachItem(function (i) {\n      i.$level = this.calculateItemLevel(i);\n    }, t.id);\n  },\n  _replace_branch_child: function (t, e, n) {\n    var i = this.getChildren(t);\n    if (i && t !== void 0) {\n      var a = tt.$create();\n      let r = i.indexOf(e + \"\");\n      r != -1 || isNaN(+e) || (r = i.indexOf(+e)), r > -1 && (n ? i.splice(r, 1, n) : i.splice(r, 1)), a = i, this._branches[t] = a;\n    }\n  },\n  sort: function (t, e, n) {\n    this.exists(n) || (n = this.$getRootId()), t || (t = \"order\");\n    var i = typeof t == \"string\" ? function (l, d) {\n      return l[t] == d[t] || Z(l[t]) && Z(d[t]) && l[t].valueOf() == d[t].valueOf() ? 0 : l[t] > d[t] ? 1 : -1;\n    } : t;\n    if (e) {\n      var a = i;\n      i = function (l, d) {\n        return a(d, l);\n      };\n    }\n    var r = this.getChildren(n);\n    if (r) {\n      for (var s = [], o = r.length - 1; o >= 0; o--) s[o] = this.getItem(r[o]);\n      for (s.sort(i), o = 0; o < s.length; o++) r[o] = s[o].id, this.sort(t, e, r[o]);\n    }\n  },\n  filter: function (t) {\n    for (let e in this.pull) {\n      const n = this.pull[e].$rendered_parent,\n        i = this.getParent(this.pull[e]);\n      lt(n, i) || this._move_branch(this.pull[e], n, i);\n    }\n    return it.prototype.filter.apply(this, arguments);\n  },\n  open: function (t) {\n    this.exists(t) && (this.getItem(t).$open = !0, this._skipTaskRecalculation = !0, this.callEvent(\"onItemOpen\", [t]));\n  },\n  close: function (t) {\n    this.exists(t) && (this.getItem(t).$open = !1, this._skipTaskRecalculation = !0, this.callEvent(\"onItemClose\", [t]));\n  },\n  destructor: function () {\n    it.prototype.destructor.call(this), this._branches = null, this._indexRangeCache = {}, this._eachItemMainRangeCache = null;\n  }\n}, it.prototype);\nconst ei = function (t, e) {\n  const n = e.getDatastore(t),\n    i = function (o, l) {\n      const d = l.getLayers(),\n        c = n.getItem(o);\n      if (c && n.isVisible(o)) for (let u = 0; u < d.length; u++) d[u].render_item(c);\n    },\n    a = function (o) {\n      const l = o.getLayers();\n      for (let g = 0; g < l.length; g++) l[g].clear();\n      let d = null;\n      const c = {};\n      for (let g = 0; g < l.length; g++) {\n        const f = l[g];\n        let y;\n        if (f.get_visible_range) {\n          var u = f.get_visible_range(n);\n          if (u.start !== void 0 && u.end !== void 0) {\n            var h = u.start + \" - \" + u.end;\n            c[h] ? y = c[h] : (y = n.getIndexRange(u.start, u.end), c[h] = y);\n          } else {\n            if (u.ids === void 0) throw new Error(\"Invalid range returned from 'getVisibleRange' of the layer\");\n            y = u.ids.map(function (v) {\n              return n.getItem(v);\n            });\n          }\n        } else d || (d = n.getVisibleItems()), y = d;\n        f.prepare_data && f.prepare_data(y), l[g].render_items(y);\n      }\n    },\n    r = function (o) {\n      if (o.update_items) {\n        let d = [];\n        if (o.get_visible_range) {\n          var l = o.get_visible_range(n);\n          if (l.start !== void 0 && l.end !== void 0 && (d = n.getIndexRange(l.start, l.end)), l.ids !== void 0) {\n            let c = l.ids.map(function (u) {\n              return n.getItem(u);\n            });\n            c.length > 0 && (c = c.filter(u => u !== void 0), d = d.concat(c));\n          }\n          if ((l.start == null || l.end == null) && l.ids == null) throw new Error(\"Invalid range returned from 'getVisibleRange' of the layer\");\n        } else d = n.getVisibleItems();\n        o.prepare_data && o.prepare_data(d, o), o.update_items(d);\n      }\n    };\n  function s(o) {\n    return !!o.$services.getService(\"state\").getState(\"batchUpdate\").batch_update;\n  }\n  n.attachEvent(\"onStoreUpdated\", function (o, l, d) {\n    if (V(e)) return !0;\n    const c = e.$services.getService(\"layers\").getDataRender(t);\n    c && (c.onUpdateRequest = function (u) {\n      r(u);\n    });\n  }), n.attachEvent(\"onStoreUpdated\", function (o, l, d) {\n    s(e) || (o && d != \"move\" && d != \"delete\" ? (n.callEvent(\"onBeforeRefreshItem\", [l.id]), n.callEvent(\"onAfterRefreshItem\", [l.id])) : (n.callEvent(\"onBeforeRefreshAll\", []), n.callEvent(\"onAfterRefreshAll\", [])));\n  }), n.attachEvent(\"onAfterRefreshAll\", function () {\n    if (V(e)) return !0;\n    const o = e.$services.getService(\"layers\").getDataRender(t);\n    o && !s(e) && a(o);\n  }), n.attachEvent(\"onAfterRefreshItem\", function (o) {\n    if (V(e)) return !0;\n    const l = e.$services.getService(\"layers\").getDataRender(t);\n    l && i(o, l);\n  }), n.attachEvent(\"onItemOpen\", function () {\n    if (V(e)) return !0;\n    e.render();\n  }), n.attachEvent(\"onItemClose\", function () {\n    if (V(e)) return !0;\n    e.render();\n  }), n.attachEvent(\"onIdChange\", function (o, l) {\n    if (V(e)) return !0;\n    if (n.callEvent(\"onBeforeIdChange\", [o, l]), !s(e) && !n.isSilent()) {\n      const d = e.$services.getService(\"layers\").getDataRender(t);\n      d ? (function (c, u, h) {\n        for (let g = 0; g < c.length; g++) c[g].change_id(u, h);\n      }(d.getLayers(), o, l, n.getItem(l)), i(l, d)) : e.render();\n    }\n  });\n};\nfunction ne() {\n  for (var t = this.$services.getService(\"datastores\"), e = [], n = 0; n < t.length; n++) {\n    var i = this.getDatastore(t[n]);\n    i.$destroyed || e.push(i);\n  }\n  return e;\n}\nconst ni = {\n  create: function () {\n    var t = L({}, {\n      createDatastore: function (e) {\n        var n = (e.type || \"\").toLowerCase() == \"treedatastore\" ? hn : it;\n        if (e) {\n          var i = this;\n          e.openInitially = function () {\n            return i.config.open_tree_initially;\n          }, e.copyOnParse = function () {\n            return i.config.deepcopy_on_parse;\n          };\n        }\n        var a = new n(e);\n        if (this.mixin(a, function (o) {\n          var l = null,\n            d = o._removeItemInner;\n          function c(u) {\n            l = null, this.callEvent(\"onAfterUnselect\", [u]);\n          }\n          return o._removeItemInner = function (u) {\n            return l == u && c.call(this, u), l && this.eachItem && this.eachItem(function (h) {\n              h.id == l && c.call(this, h.id);\n            }, u), d.apply(this, arguments);\n          }, o.attachEvent(\"onIdChange\", function (u, h) {\n            o.getSelectedId() == u && o.silent(function () {\n              o.unselect(u), o.select(h);\n            });\n          }), {\n            select: function (u) {\n              if (u) {\n                if (l == u) return l;\n                if (!this._skip_refresh && !this.callEvent(\"onBeforeSelect\", [u])) return !1;\n                this.unselect(), l = u, this._skip_refresh || (this.refresh(u), this.callEvent(\"onAfterSelect\", [u]));\n              }\n              return l;\n            },\n            getSelectedId: function () {\n              return l;\n            },\n            isSelected: function (u) {\n              return u == l;\n            },\n            unselect: function (u) {\n              (u = u || l) && (l = null, this._skip_refresh || (this.refresh(u), c.call(this, u)));\n            }\n          };\n        }(a)), e.name) {\n          var r = \"datastore:\" + e.name;\n          a.attachEvent(\"onDestroy\", function () {\n            this.$services.dropService(r);\n            for (var o = this.$services.getService(\"datastores\"), l = 0; l < o.length; l++) if (o[l] === e.name) {\n              o.splice(l, 1);\n              break;\n            }\n          }.bind(this)), this.$services.dropService(r), this.$services.setService(r, function () {\n            return a;\n          });\n          var s = this.$services.getService(\"datastores\");\n          s ? s.indexOf(e.name) < 0 && s.push(e.name) : (s = [], this.$services.setService(\"datastores\", function () {\n            return s;\n          }), s.push(e.name)), ei(e.name, this);\n        }\n        return a;\n      },\n      getDatastore: function (e) {\n        return this.$services.getService(\"datastore:\" + e);\n      },\n      _getDatastores: ne,\n      refreshData: function () {\n        var e;\n        V(this) || (e = this.getScrollState()), this.callEvent(\"onBeforeDataRender\", []);\n        for (var n = ne.call(this), i = 0; i < n.length; i++) n[i].refresh();\n        this.config.preserve_scroll && !V(this) && (e.x || e.y) && this.scrollTo(e.x, e.y), this.callEvent(\"onDataRender\", []);\n      },\n      isChildOf: function (e, n) {\n        return this.$data.tasksStore.isChildOf(e, n);\n      },\n      refreshTask: function (e, n) {\n        var i = this.getTask(e),\n          a = this;\n        function r() {\n          if (n === void 0 || n) {\n            for (var o = 0; o < i.$source.length; o++) a.refreshLink(i.$source[o]);\n            for (o = 0; o < i.$target.length; o++) a.refreshLink(i.$target[o]);\n          }\n        }\n        if (i && this.isTaskVisible(e)) this.$data.tasksStore.refresh(e, !!this.getState(\"tasksDnd\").drag_id || n === !1), r();else if (this.isTaskExists(e) && this.isTaskExists(this.getParent(e)) && !this._bulk_dnd) {\n          this.refreshTask(this.getParent(e));\n          var s = !1;\n          this.eachParent(function (o) {\n            (s || this.isSplitTask(o)) && (s = !0);\n          }, e), s && r();\n        }\n      },\n      refreshLink: function (e) {\n        this.$data.linksStore.refresh(e, !!this.getState(\"tasksDnd\").drag_id);\n      },\n      silent: function (e) {\n        var n = this;\n        n.$data.tasksStore.silent(function () {\n          n.$data.linksStore.silent(function () {\n            e();\n          });\n        });\n      },\n      clearAll: function () {\n        for (var e = ne.call(this), n = 0; n < e.length; n++) e[n].silent(function () {\n          e[n].clearAll();\n        });\n        for (n = 0; n < e.length; n++) e[n].clearAll();\n        this._update_flags(), this.userdata = {}, this.callEvent(\"onClear\", []), this.render();\n      },\n      _clear_data: function () {\n        this.$data.tasksStore.clearAll(), this.$data.linksStore.clearAll(), this._update_flags(), this.userdata = {};\n      },\n      selectTask: function (e) {\n        var n = this.$data.tasksStore;\n        if (!this.config.select_task) return !1;\n        if (e = at(e, this.config.root_id)) {\n          let i = this.getSelectedId();\n          n._skipResourceRepaint = !0, n.select(e), n._skipResourceRepaint = !1, i && n.pull[i].$split_subtask && i != e && this.refreshTask(i), n.pull[e].$split_subtask && i != e && this.refreshTask(e);\n        }\n        return n.getSelectedId();\n      },\n      unselectTask: function (e) {\n        var n = this.$data.tasksStore;\n        n.unselect(e), e && n.pull[e].$split_subtask && this.refreshTask(e);\n      },\n      isSelectedTask: function (e) {\n        return this.$data.tasksStore.isSelected(e);\n      },\n      getSelectedId: function () {\n        return this.$data.tasksStore.getSelectedId();\n      }\n    });\n    return L(t, {\n      getTask: function (e) {\n        e = at(e, this.config.root_id), this.assert(e, \"Invalid argument for gantt.getTask\");\n        var n = this.$data.tasksStore.getItem(e);\n        return this.assert(n, \"Task not found id=\" + e), n;\n      },\n      getTaskByTime: function (e, n) {\n        var i = this.$data.tasksStore.getItems(),\n          a = [];\n        if (e || n) {\n          e = +e || -1 / 0, n = +n || 1 / 0;\n          for (var r = 0; r < i.length; r++) {\n            var s = i[r];\n            +s.start_date < n && +s.end_date > e && a.push(s);\n          }\n        } else a = i;\n        return a;\n      },\n      isTaskExists: function (e) {\n        return !(!this.$data || !this.$data.tasksStore) && this.$data.tasksStore.exists(e);\n      },\n      updateTask: function (e, n) {\n        j(n) || (n = this.getTask(e)), this.$data.tasksStore.updateItem(e, n), this.isTaskExists(e) && this.refreshTask(e);\n      },\n      addTask: function (e, n, i) {\n        if (j(e.id) || (e.id = st()), this.isTaskExists(e.id) && this.getTask(e.id).$index != e.$index) return e.start_date && typeof e.start_date == \"string\" && (e.start_date = this.date.parseDate(e.start_date, \"parse_date\")), e.end_date && typeof e.end_date == \"string\" && (e.end_date = this.date.parseDate(e.end_date, \"parse_date\")), this.$data.tasksStore.updateItem(e.id, e);\n        if (j(n) || (n = this.getParent(e) || 0), this.isTaskExists(n) || (n = this.config.root_id), this.setParent(e, n), this.getState().lightbox && this.isTaskExists(n)) {\n          var a = this.getTask(n);\n          this.callEvent(\"onAfterParentExpand\", [n, a]);\n        }\n        return this.$data.tasksStore.addItem(e, i, n);\n      },\n      deleteTask: function (e) {\n        return e = at(e, this.config.root_id), this.$data.tasksStore.removeItem(e);\n      },\n      getTaskCount: function () {\n        return this.$data.tasksStore.count();\n      },\n      getVisibleTaskCount: function () {\n        return this.$data.tasksStore.countVisible();\n      },\n      getTaskIndex: function (e) {\n        return this.$data.tasksStore.getBranchIndex(e);\n      },\n      getGlobalTaskIndex: function (e) {\n        return e = at(e, this.config.root_id), this.assert(e, \"Invalid argument\"), this.$data.tasksStore.getIndexById(e);\n      },\n      eachTask: function (e, n, i) {\n        return this.$data.tasksStore.eachItem(R(e, i || this), n);\n      },\n      eachParent: function (e, n, i) {\n        return this.$data.tasksStore.eachParent(R(e, i || this), n);\n      },\n      changeTaskId: function (e, n) {\n        this.$data.tasksStore.changeId(e, n);\n        var i = this.$data.tasksStore.getItem(n),\n          a = [];\n        i.$source && (a = a.concat(i.$source)), i.$target && (a = a.concat(i.$target));\n        for (var r = 0; r < a.length; r++) {\n          var s = this.getLink(a[r]);\n          s.source == e && (s.source = n), s.target == e && (s.target = n);\n        }\n      },\n      calculateTaskLevel: function (e) {\n        return this.$data.tasksStore.calculateItemLevel(e);\n      },\n      getNext: function (e) {\n        return this.$data.tasksStore.getNext(e);\n      },\n      getPrev: function (e) {\n        return this.$data.tasksStore.getPrev(e);\n      },\n      getParent: function (e) {\n        return this.$data.tasksStore.getParent(e);\n      },\n      setParent: function (e, n, i) {\n        return this.$data.tasksStore.setParent(e, n, i);\n      },\n      getSiblings: function (e) {\n        return this.$data.tasksStore.getSiblings(e).slice();\n      },\n      getNextSibling: function (e) {\n        return this.$data.tasksStore.getNextSibling(e);\n      },\n      getPrevSibling: function (e) {\n        return this.$data.tasksStore.getPrevSibling(e);\n      },\n      getTaskByIndex: function (e) {\n        var n = this.$data.tasksStore.getIdByIndex(e);\n        return this.isTaskExists(n) ? this.getTask(n) : null;\n      },\n      getChildren: function (e) {\n        return this.hasChild(e) ? this.$data.tasksStore.getChildren(e).slice() : [];\n      },\n      hasChild: function (e) {\n        return this.$data.tasksStore.hasChild(e);\n      },\n      open: function (e) {\n        this.$data.tasksStore.open(e);\n      },\n      close: function (e) {\n        this.$data.tasksStore.close(e);\n      },\n      moveTask: function (e, n, i) {\n        return i = at(i, this.config.root_id), this.$data.tasksStore.move.apply(this.$data.tasksStore, arguments);\n      },\n      sort: function (e, n, i, a) {\n        var r = !a;\n        this.$data.tasksStore.sort(e, n, i), this.callEvent(\"onAfterSort\", [e, n, i]), r && this.render();\n      }\n    }), L(t, {\n      getLinkCount: function () {\n        return this.$data.linksStore.count();\n      },\n      getLink: function (e) {\n        return this.$data.linksStore.getItem(e);\n      },\n      getLinks: function () {\n        return this.$data.linksStore.getItems();\n      },\n      isLinkExists: function (e) {\n        return this.$data.linksStore.exists(e);\n      },\n      addLink: function (e) {\n        const n = this.$data.linksStore.addItem(e);\n        return this.$data.linksStore.isSilent() && this.$data.linksStore.fullOrder.push(n), n;\n      },\n      updateLink: function (e, n) {\n        j(n) || (n = this.getLink(e)), this.$data.linksStore.updateItem(e, n);\n      },\n      deleteLink: function (e) {\n        return this.$data.linksStore.removeItem(e);\n      },\n      changeLinkId: function (e, n) {\n        return this.$data.linksStore.changeId(e, n);\n      }\n    }), t;\n  }\n};\nfunction pe(t) {\n  var e = t.date,\n    n = t.$services;\n  return {\n    getSum: function (i, a, r) {\n      r === void 0 && (r = i.length - 1), a === void 0 && (a = 0);\n      for (var s = 0, o = a; o <= r; o++) s += i[o];\n      return s;\n    },\n    setSumWidth: function (i, a, r, s) {\n      var o = a.width;\n      s === void 0 && (s = o.length - 1), r === void 0 && (r = 0);\n      var l = s - r + 1;\n      if (!(r > o.length - 1 || l <= 0 || s > o.length - 1)) {\n        var d = i - this.getSum(o, r, s);\n        this.adjustSize(d, o, r, s), this.adjustSize(-d, o, s + 1), a.full_width = this.getSum(o);\n      }\n    },\n    splitSize: function (i, a) {\n      for (var r = [], s = 0; s < a; s++) r[s] = 0;\n      return this.adjustSize(i, r), r;\n    },\n    adjustSize: function (i, a, r, s) {\n      r || (r = 0), s === void 0 && (s = a.length - 1);\n      for (var o = s - r + 1, l = this.getSum(a, r, s), d = r; d <= s; d++) {\n        var c = Math.floor(i * (l ? a[d] / l : 1 / o));\n        l -= a[d], i -= c, o--, a[d] += c;\n      }\n      a[a.length - 1] += i;\n    },\n    sortScales: function (i) {\n      function a(s, o) {\n        var l = new Date(1970, 0, 1);\n        return e.add(l, o, s) - l;\n      }\n      i.sort(function (s, o) {\n        return a(s.unit, s.step) < a(o.unit, o.step) ? 1 : a(s.unit, s.step) > a(o.unit, o.step) ? -1 : 0;\n      });\n      for (var r = 0; r < i.length; r++) i[r].index = r;\n    },\n    _isLegacyMode: function (i) {\n      var a = i || t.config;\n      return a.scale_unit || a.date_scale || a.subscales;\n    },\n    _prepareScaleObject: function (i) {\n      var a = i.format;\n      return a || (a = i.template || i.date || \"%d %M\"), typeof a == \"string\" && (a = t.date.date_to_str(a)), {\n        unit: i.unit || \"day\",\n        step: i.step || 1,\n        format: a,\n        css: i.css\n      };\n    },\n    primaryScale: function (i) {\n      var a,\n        r = n.getService(\"templateLoader\"),\n        s = this._isLegacyMode(i),\n        o = i || t.config;\n      if (s) r.initTemplate(\"date_scale\", void 0, void 0, o, t.config.templates), a = {\n        unit: t.config.scale_unit,\n        step: t.config.step,\n        template: t.templates.date_scale,\n        date: t.config.date_scale,\n        css: t.templates.scale_cell_class\n      };else {\n        var l = o.scales[0];\n        a = {\n          unit: l.unit,\n          step: l.step,\n          template: l.template,\n          format: l.format,\n          date: l.date,\n          css: l.css || t.templates.scale_cell_class\n        };\n      }\n      return this._prepareScaleObject(a);\n    },\n    getSubScales: function (i) {\n      var a,\n        r = this._isLegacyMode(i),\n        s = i || t.config;\n      if (r) {\n        let o = \"https://docs.dhtmlx.com/gantt/migrating.html#:~:text=%3D%20false%3B-,Time%20scale%20settings,-Configuration%20of%20time\";\n        t.env.isFF && (o = \"https://docs.dhtmlx.com/gantt/migrating.html#6162\"), console.warn(`You are using the obsolete scale configuration.\nIt will stop working in the future versions.\nPlease migrate the configuration to the newer version:\n${o}`), a = s.subscales || [];\n      } else a = s.scales.slice(1);\n      return a.map(function (o) {\n        return this._prepareScaleObject(o);\n      }.bind(this));\n    },\n    prepareConfigs: function (i, a, r, s, o, l, d) {\n      for (var c = this.splitSize(s, i.length), u = r, h = [], g = i.length - 1; g >= 0; g--) {\n        var f = g == i.length - 1,\n          y = this.initScaleConfig(i[g], o, l);\n        f && this.processIgnores(y), this.initColSizes(y, a, u, c[g]), this.limitVisibleRange(y), f && (u = y.full_width), h.unshift(y);\n      }\n      for (g = 0; g < h.length - 1; g++) this.alineScaleColumns(h[h.length - 1], h[g]);\n      for (g = 0; g < h.length; g++) d && this.reverseScale(h[g]), this.setPosSettings(h[g]);\n      return h;\n    },\n    reverseScale: function (i) {\n      i.width = i.width.reverse(), i.trace_x = i.trace_x.reverse();\n      var a = i.trace_indexes;\n      i.trace_indexes = {}, i.trace_index_transition = {}, i.rtl = !0;\n      for (var r = 0; r < i.trace_x.length; r++) i.trace_indexes[i.trace_x[r].valueOf()] = r, i.trace_index_transition[a[i.trace_x[r].valueOf()]] = r;\n      return i;\n    },\n    setPosSettings: function (i) {\n      for (var a = 0, r = i.trace_x.length; a < r; a++) i.left.push((i.width[a - 1] || 0) + (i.left[a - 1] || 0));\n    },\n    _ignore_time_config: function (i, a) {\n      if (t.config.skip_off_time) {\n        for (var r = !0, s = i, o = 0; o < a.step; o++) o && (s = e.add(i, o, a.unit)), r = r && !this.isWorkTime(s, a.unit);\n        return r;\n      }\n      return !1;\n    },\n    processIgnores: function (i) {\n      i.ignore_x = {}, i.display_count = i.count;\n    },\n    initColSizes: function (i, a, r, s) {\n      var o = r;\n      i.height = s;\n      var l = i.display_count === void 0 ? i.count : i.display_count;\n      l || (l = 1), i.col_width = Math.floor(o / l), a && i.col_width < a && (i.col_width = a, o = i.col_width * l), i.width = [];\n      for (var d = i.ignore_x || {}, c = 0; c < i.trace_x.length; c++) if (d[i.trace_x[c].valueOf()] || i.display_count == i.count) i.width[c] = 0;else {\n        var u = 1;\n        i.unit == \"month\" && (u = Math.round((e.add(i.trace_x[c], i.step, i.unit) - i.trace_x[c]) / 864e5)), i.width[c] = u;\n      }\n      this.adjustSize(o - this.getSum(i.width), i.width), i.full_width = this.getSum(i.width);\n    },\n    initScaleConfig: function (i, a, r) {\n      var s = L({\n        count: 0,\n        col_width: 0,\n        full_width: 0,\n        height: 0,\n        width: [],\n        left: [],\n        trace_x: [],\n        trace_indexes: {},\n        min_date: new Date(a),\n        max_date: new Date(r)\n      }, i);\n      return this.eachColumn(i.unit, i.step, a, r, function (o) {\n        s.count++, s.trace_x.push(new Date(o)), s.trace_indexes[o.valueOf()] = s.trace_x.length - 1;\n      }), s.trace_x_ascending = s.trace_x.slice(), s;\n    },\n    iterateScales: function (i, a, r, s, o) {\n      for (var l = a.trace_x, d = i.trace_x, c = r || 0, u = s || d.length - 1, h = 0, g = 1; g < l.length; g++) {\n        var f = i.trace_indexes[+l[g]];\n        f !== void 0 && f <= u && (o && o.apply(this, [h, g, c, f]), c = f, h = g);\n      }\n    },\n    alineScaleColumns: function (i, a, r, s) {\n      this.iterateScales(i, a, r, s, function (o, l, d, c) {\n        var u = this.getSum(i.width, d, c - 1);\n        this.getSum(a.width, o, l - 1) != u && this.setSumWidth(u, a, o, l - 1);\n      });\n    },\n    eachColumn: function (i, a, r, s, o) {\n      var l = new Date(r),\n        d = new Date(s);\n      e[i + \"_start\"] && (l = e[i + \"_start\"](l));\n      var c = new Date(l);\n      for (+c >= +d && (d = e.add(c, a, i)); +c < +d;) {\n        o.call(this, new Date(c));\n        var u = c.getTimezoneOffset();\n        c = e.add(c, a, i), c = t._correct_dst_change(c, u, a, i), e[i + \"_start\"] && (c = e[i + \"_start\"](c));\n      }\n    },\n    limitVisibleRange: function (i) {\n      var a = i.trace_x,\n        r = i.width.length - 1,\n        s = 0;\n      if (+a[0] < +i.min_date && r != 0) {\n        var o = Math.floor(i.width[0] * ((a[1] - i.min_date) / (a[1] - a[0])));\n        s += i.width[0] - o, i.width[0] = o, a[0] = new Date(i.min_date);\n      }\n      var l = a.length - 1,\n        d = a[l],\n        c = e.add(d, i.step, i.unit);\n      if (+c > +i.max_date && l > 0 && (o = i.width[l] - Math.floor(i.width[l] * ((c - i.max_date) / (c - d))), s += i.width[l] - o, i.width[l] = o), s) {\n        for (var u = this.getSum(i.width), h = 0, g = 0; g < i.width.length; g++) {\n          var f = Math.floor(s * (i.width[g] / u));\n          i.width[g] += f, h += f;\n        }\n        this.adjustSize(s - h, i.width);\n      }\n    }\n  };\n}\nfunction ii(t) {\n  var e = function (c) {\n      var u = new pe(c).primaryScale(),\n        h = u.unit,\n        g = u.step;\n      if (c.config.scale_offset_minimal) {\n        var f = new pe(c),\n          y = [f.primaryScale()].concat(f.getSubScales());\n        f.sortScales(y), h = y[y.length - 1].unit, g = y[y.length - 1].step || 1;\n      }\n      return {\n        unit: h,\n        step: g\n      };\n    }(t),\n    n = e.unit,\n    i = e.step,\n    a = function (c, u) {\n      var h = {\n        start_date: null,\n        end_date: null\n      };\n      if (u.config.start_date && u.config.end_date) {\n        h.start_date = u.date[c + \"_start\"](new Date(u.config.start_date));\n        var g = new Date(u.config.end_date),\n          f = u.date[c + \"_start\"](new Date(g));\n        g = +g != +f ? u.date.add(f, 1, c) : f, h.end_date = g;\n      }\n      return h;\n    }(n, t);\n  if (!a.start_date || !a.end_date) {\n    for (var r = !0, s = t.getTaskByTime(), o = 0; o < s.length; o++) if (s[o].type !== t.config.types.project) {\n      r = !1;\n      break;\n    }\n    if (s.length && r) {\n      var l = s[0].start_date,\n        d = t.date.add(l, 1, t.config.duration_unit);\n      a = {\n        start_date: new Date(l),\n        end_date: new Date(d)\n      };\n    } else a = t.getSubtaskDates();\n    a.start_date && a.end_date || (a = {\n      start_date: /* @__PURE__ */new Date(),\n      end_date: /* @__PURE__ */new Date()\n    }), t.eachTask(function (c) {\n      t.config.deadlines && c.deadline && ie(a, c.deadline, c.deadline), c.constraint_date && c.constraint_type && t.config.constraint_types && c.constraint_type !== t.config.constraint_types.ASAP && c.constraint_type !== t.config.constraint_types.ALAP && ie(a, c.constraint_date, c.constraint_date), t.config.baselines && c.baselines && c.baselines.forEach(function (u) {\n        ie(a, u.start_date, u.end_date);\n      });\n    }), a.start_date = t.date[n + \"_start\"](a.start_date), a.start_date = t.calculateEndDate({\n      start_date: t.date[n + \"_start\"](a.start_date),\n      duration: -1,\n      unit: n,\n      step: i\n    }), a.end_date = t.date[n + \"_start\"](a.end_date), a.end_date = t.calculateEndDate({\n      start_date: a.end_date,\n      duration: 2,\n      unit: n,\n      step: i\n    });\n  }\n  t._min_date = a.start_date, t._max_date = a.end_date;\n}\nfunction ie(t, e, n) {\n  e < t.start_date && (t.start_date = new Date(e)), n > t.end_date && (t.end_date = new Date(n));\n}\nfunction me(t) {\n  ii(t), function (e) {\n    if (e.config.fit_tasks) {\n      var n = +e._min_date,\n        i = +e._max_date;\n      if (+e._min_date != n || +e._max_date != i) return e.render(), e.callEvent(\"onScaleAdjusted\", []), !0;\n    }\n  }(t);\n}\nfunction Re(t, e, n) {\n  for (var i = 0; i < e.length; i++) t.isLinkExists(e[i]) && (n[e[i]] = t.getLink(e[i]));\n}\nfunction He(t, e, n) {\n  Re(t, e.$source, n), Re(t, e.$target, n);\n}\nconst ve = {\n  getSubtreeLinks: function (t, e) {\n    var n = {};\n    return t.isTaskExists(e) && He(t, t.getTask(e), n), t.eachTask(function (i) {\n      He(t, i, n);\n    }, e), n;\n  },\n  getSubtreeTasks: function (t, e) {\n    var n = {};\n    return t.eachTask(function (i) {\n      n[i.id] = i;\n    }, e), n;\n  }\n};\nclass ai {\n  constructor(e, n) {\n    this.$gantt = e, this.$dp = n, this._dataProcessorHandlers = [];\n  }\n  attach() {\n    const e = this.$dp,\n      n = this.$gantt,\n      i = {},\n      a = o => this.clientSideDelete(o, e, n);\n    this._dataProcessorHandlers.push(n.attachEvent(\"onAfterTaskAdd\", function (o, l) {\n      n.isTaskExists(o) && (e.setGanttMode(\"tasks\"), e.setUpdated(o, !0, \"inserted\"));\n    })), this._dataProcessorHandlers.push(n.attachEvent(\"onAfterTaskUpdate\", function (o, l) {\n      n.isTaskExists(o) && (e.setGanttMode(\"tasks\"), e.setUpdated(o, !0), n._sendTaskOrder && n._sendTaskOrder(o, l));\n    })), this._dataProcessorHandlers.push(n.attachEvent(\"onBeforeTaskDelete\", function (o, l) {\n      return n.config.cascade_delete && (i[o] = {\n        tasks: ve.getSubtreeTasks(n, o),\n        links: ve.getSubtreeLinks(n, o)\n      }), !e.deleteAfterConfirmation || (e.setGanttMode(\"tasks\"), e.setUpdated(o, !0, \"deleted\"), !1);\n    })), this._dataProcessorHandlers.push(n.attachEvent(\"onAfterTaskDelete\", function (o, l) {\n      e.setGanttMode(\"tasks\");\n      const d = !a(o),\n        c = n.config.cascade_delete && i[o];\n      if (d || c) {\n        if (c) {\n          const u = e.updateMode;\n          e.setUpdateMode(\"off\");\n          const h = i[o];\n          for (const g in h.tasks) a(g) || (e.storeItem(h.tasks[g]), e.setUpdated(g, !0, \"deleted\"));\n          e.setGanttMode(\"links\");\n          for (const g in h.links) a(g) || (e.storeItem(h.links[g]), e.setUpdated(g, !0, \"deleted\"));\n          i[o] = null, u !== \"off\" && e.sendAllData(), e.setGanttMode(\"tasks\"), e.setUpdateMode(u);\n        }\n        d && (e.storeItem(l), e.deleteAfterConfirmation || e.setUpdated(o, !0, \"deleted\")), e.updateMode === \"off\" || e._tSend || e.sendAllData();\n      }\n    })), this._dataProcessorHandlers.push(n.attachEvent(\"onAfterLinkUpdate\", function (o, l) {\n      n.isLinkExists(o) && (e.setGanttMode(\"links\"), e.setUpdated(o, !0));\n    })), this._dataProcessorHandlers.push(n.attachEvent(\"onAfterLinkAdd\", function (o, l) {\n      n.isLinkExists(o) && (e.setGanttMode(\"links\"), e.setUpdated(o, !0, \"inserted\"));\n    })), this._dataProcessorHandlers.push(n.attachEvent(\"onAfterLinkDelete\", function (o, l) {\n      e.setGanttMode(\"links\"), !a(o) && (e.storeItem(l), e.setUpdated(o, !0, \"deleted\"));\n    })), this._dataProcessorHandlers.push(n.attachEvent(\"onRowDragEnd\", function (o, l) {\n      n._sendTaskOrder(o, n.getTask(o));\n    }));\n    let r = null,\n      s = null;\n    this._dataProcessorHandlers.push(n.attachEvent(\"onTaskIdChange\", function (o, l) {\n      if (!e._waitMode) return;\n      const d = n.getChildren(l);\n      if (d.length) {\n        r = r || {};\n        for (let u = 0; u < d.length; u++) {\n          const h = this.getTask(d[u]);\n          r[h.id] = h;\n        }\n      }\n      const c = function (u) {\n        let h = [];\n        return u.$source && (h = h.concat(u.$source)), u.$target && (h = h.concat(u.$target)), h;\n      }(this.getTask(l));\n      if (c.length) {\n        s = s || {};\n        for (let u = 0; u < c.length; u++) {\n          const h = this.getLink(c[u]);\n          s[h.id] = h;\n        }\n      }\n    })), e.attachEvent(\"onAfterUpdateFinish\", function () {\n      (r || s) && (n.batchUpdate(function () {\n        for (const o in r) n.updateTask(r[o].id);\n        for (const o in s) n.updateLink(s[o].id);\n        r = null, s = null;\n      }), r ? n._dp.setGanttMode(\"tasks\") : n._dp.setGanttMode(\"links\"));\n    }), e.attachEvent(\"onBeforeDataSending\", function () {\n      if (this._tMode === \"CUSTOM\") return !0;\n      let o = this._serverProcessor;\n      if (this._tMode === \"REST-JSON\" || this._tMode === \"REST\") {\n        const l = this._ganttMode;\n        o = o.substring(0, o.indexOf(\"?\") > -1 ? o.indexOf(\"?\") : o.length), this.serverProcessor = o + (o.slice(-1) === \"/\" ? \"\" : \"/\") + l;\n      } else {\n        const l = this._ganttMode + \"s\";\n        this.serverProcessor = o + n.ajax.urlSeparator(o) + \"gantt_mode=\" + l;\n      }\n      return !0;\n    }), e.attachEvent(\"insertCallback\", function (o, l, d, c) {\n      const u = o.data || n.xml._xmlNodeToJSON(o.firstChild),\n        h = {\n          add: n.addTask,\n          isExist: n.isTaskExists\n        };\n      c === \"links\" && (h.add = n.addLink, h.isExist = n.isLinkExists), h.isExist.call(n, l) || (u.id = l, h.add.call(n, u));\n    }), e.attachEvent(\"updateCallback\", function (o, l) {\n      const d = o.data || n.xml._xmlNodeToJSON(o.firstChild);\n      if (!n.isTaskExists(l)) return;\n      const c = n.getTask(l);\n      for (const u in d) {\n        let h = d[u];\n        switch (u) {\n          case \"id\":\n            continue;\n          case \"start_date\":\n          case \"end_date\":\n            h = n.defined(n.templates.xml_date) ? n.templates.xml_date(h) : n.templates.parse_date(h);\n            break;\n          case \"duration\":\n            c.end_date = n.calculateEndDate({\n              start_date: c.start_date,\n              duration: h,\n              task: c\n            });\n        }\n        c[u] = h;\n      }\n      n.updateTask(l), n.refreshData();\n    }), e.attachEvent(\"deleteCallback\", function (o, l, d, c) {\n      const u = {\n        delete: n.deleteTask,\n        isExist: n.isTaskExists\n      };\n      c === \"links\" ? (u.delete = n.deleteLink, u.isExist = n.isLinkExists) : c === \"assignment\" && (u.delete = function (h) {\n        n.$data.assignmentsStore.remove(h);\n      }, u.isExist = function (h) {\n        return n.$data.assignmentsStore.exists(h);\n      }), u.isExist.call(n, l) && u.delete.call(n, l);\n    }), this.handleResourceCRUD(e, n), this.handleResourceAssignmentCRUD(e, n), this.handleBaselineCRUD(e, n);\n  }\n  clientSideDelete(e, n, i) {\n    const a = n.updatedRows.slice();\n    let r = !1;\n    i.getUserData(e, \"!nativeeditor_status\", n._ganttMode) === \"true_deleted\" && (r = !0, n.setUpdated(e, !1));\n    for (let s = 0; s < a.length && !n._in_progress[e]; s++) a[s] === e && (i.getUserData(e, \"!nativeeditor_status\", n._ganttMode) === \"inserted\" && (r = !0), n.setUpdated(e, !1));\n    return r;\n  }\n  handleResourceAssignmentCRUD(e, n) {\n    if (!n.config.resources || n.config.resources.dataprocessor_assignments !== !0) return;\n    const i = n.getDatastore(n.config.resource_assignment_store),\n      a = {},\n      r = {};\n    function s(o) {\n      const l = o.id;\n      i.exists(l) && (e.setGanttMode(\"assignment\"), e.setUpdated(l, !0, \"inserted\")), delete r[l];\n    }\n    n.attachEvent(\"onBeforeTaskAdd\", function (o, l) {\n      return a[o] = !0, !0;\n    }), n.attachEvent(\"onTaskIdChange\", function (o, l) {\n      delete a[o];\n    }), i.attachEvent(\"onAfterAdd\", (o, l) => {\n      a[l.task_id] ? function (d) {\n        r[d.id] = d, a[d.task_id] = !0;\n      }(l) : s(l);\n    }), i.attachEvent(\"onAfterUpdate\", (o, l) => {\n      i.exists(o) && (r[o] ? s(l) : (e.setGanttMode(\"assignment\"), e.setUpdated(o, !0)));\n    }), i.attachEvent(\"onAfterDelete\", (o, l) => {\n      e.setGanttMode(\"assignment\"), !this.clientSideDelete(o, e, n) && (e.storeItem(l), e.setUpdated(o, !0, \"deleted\"));\n    });\n  }\n  handleResourceCRUD(e, n) {\n    if (!n.config.resources || n.config.resources.dataprocessor_resources !== !0) return;\n    const i = n.getDatastore(n.config.resource_store);\n    i.attachEvent(\"onAfterAdd\", (a, r) => {\n      (function (s) {\n        const o = s.id;\n        i.exists(o) && (e.setGanttMode(\"resource\"), e.setUpdated(o, !0, \"inserted\"));\n      })(r);\n    }), i.attachEvent(\"onAfterUpdate\", (a, r) => {\n      i.exists(a) && (e.setGanttMode(\"resource\"), e.setUpdated(a, !0));\n    }), i.attachEvent(\"onAfterDelete\", (a, r) => {\n      e.setGanttMode(\"resource\"), !this.clientSideDelete(a, e, n) && (e.storeItem(r), e.setUpdated(a, !0, \"deleted\"));\n    });\n  }\n  handleBaselineCRUD(e, n) {\n    if (!n.config.baselines || n.config.baselines.dataprocessor_baselines !== !0) return;\n    const i = n.getDatastore(n.config.baselines.datastore);\n    i.attachEvent(\"onAfterAdd\", (a, r) => {\n      (function (s) {\n        const o = s.id;\n        i.exists(o) && (e.setGanttMode(\"baseline\"), e.setUpdated(o, !0, \"inserted\"));\n      })(r);\n    }), i.attachEvent(\"onAfterUpdate\", (a, r) => {\n      i.exists(a) && (e.setGanttMode(\"baseline\"), e.setUpdated(a, !0));\n    }), i.attachEvent(\"onAfterDelete\", (a, r) => {\n      e.setGanttMode(\"baseline\"), !this.clientSideDelete(a, e, n) && (e.storeItem(r), e.setUpdated(a, !0, \"deleted\"));\n    });\n  }\n  detach() {\n    kt(this._dataProcessorHandlers, e => {\n      this.$gantt.detachEvent(e);\n    }), this._dataProcessorHandlers = [];\n  }\n}\nconst Xt = class Xt {\n  constructor() {\n    this.clear = () => {\n      this._storage = {};\n    }, this.storeItem = e => {\n      this._storage[e.id] = G(e);\n    }, this.getStoredItem = e => this._storage[e] || null, this._storage = {};\n  }\n};\nXt.create = () => new Xt();\nlet Jt = Xt,\n  Oe = class {\n    constructor(t) {\n      this.serverProcessor = t, this.action_param = \"!nativeeditor_status\", this.updatedRows = [], this.autoUpdate = !0, this.updateMode = \"cell\", this._headers = null, this._payload = null, this._postDelim = \"_\", this._routerParametersFormat = \"parameters\", this._waitMode = 0, this._in_progress = {}, this._storage = Jt.create(), this._invalid = {}, this.messages = [], this.styles = {\n        updated: \"font-weight:bold;\",\n        inserted: \"font-weight:bold;\",\n        deleted: \"text-decoration : line-through;\",\n        invalid: \"background-color:FFE0E0;\",\n        invalid_cell: \"border-bottom:2px solid red;\",\n        error: \"color:red;\",\n        clear: \"font-weight:normal;text-decoration:none;\"\n      }, this.enableUTFencoding(!0), ot(this);\n    }\n    setTransactionMode(t, e) {\n      typeof t == \"object\" ? (this._tMode = t.mode || this._tMode, j(t.headers) && (this._headers = t.headers), j(t.payload) && (this._payload = t.payload), this._tSend = !!e) : (this._tMode = t, this._tSend = e), this._tMode === \"REST\" && (this._tSend = !1), this._tMode === \"JSON\" || this._tMode === \"REST-JSON\" ? (this._tSend = !1, this._serializeAsJson = !0, this._headers = this._headers || {}, this._headers[\"Content-Type\"] = \"application/json\") : this._headers && !this._headers[\"Content-Type\"] && (this._headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"), this._tMode === \"CUSTOM\" && (this._tSend = !1, this._router = t.router);\n    }\n    escape(t) {\n      return this._utf ? encodeURIComponent(t) : escape(t);\n    }\n    enableUTFencoding(t) {\n      this._utf = !!t;\n    }\n    getSyncState() {\n      return !this.updatedRows.length;\n    }\n    setUpdateMode(t, e) {\n      this.autoUpdate = t === \"cell\", this.updateMode = t, this.dnd = e;\n    }\n    ignore(t, e) {\n      this._silent_mode = !0, t.call(e || dt), this._silent_mode = !1;\n    }\n    setUpdated(t, e, n) {\n      if (this._silent_mode) return;\n      const i = this.findRow(t);\n      n = n || \"updated\";\n      const a = this.$gantt.getUserData(t, this.action_param, this._ganttMode);\n      a && n === \"updated\" && (n = a), e ? (this.set_invalid(t, !1), this.updatedRows[i] = t, this.$gantt.setUserData(t, this.action_param, n, this._ganttMode), this._in_progress[t] && (this._in_progress[t] = \"wait\")) : this.is_invalid(t) || (this.updatedRows.splice(i, 1), this.$gantt.setUserData(t, this.action_param, \"\", this._ganttMode)), this.markRow(t, e, n), e && this.autoUpdate && this.sendData(t);\n    }\n    markRow(t, e, n) {\n      let i = \"\";\n      const a = this.is_invalid(t);\n      if (a && (i = this.styles[a], e = !0), this.callEvent(\"onRowMark\", [t, e, n, a]) && (i = this.styles[e ? n : \"clear\"] + \" \" + i, this.$gantt[this._methods[0]](t, i), a && a.details)) {\n        i += this.styles[a + \"_cell\"];\n        for (let r = 0; r < a.details.length; r++) a.details[r] && this.$gantt[this._methods[1]](t, r, i);\n      }\n    }\n    getActionByState(t) {\n      return t === \"inserted\" ? \"create\" : t === \"updated\" ? \"update\" : t === \"deleted\" ? \"delete\" : \"update\";\n    }\n    getState(t) {\n      return this.$gantt.getUserData(t, this.action_param, this._ganttMode);\n    }\n    is_invalid(t) {\n      return this._invalid[t];\n    }\n    set_invalid(t, e, n) {\n      n && (e = {\n        value: e,\n        details: n,\n        toString: function () {\n          return this.value.toString();\n        }\n      }), this._invalid[t] = e;\n    }\n    checkBeforeUpdate(t) {\n      return !0;\n    }\n    sendData(t) {\n      if (this.$gantt.editStop && this.$gantt.editStop(), t === void 0 || this._tSend) {\n        const e = [];\n        if (this.modes && [\"task\", \"link\", \"assignment\", \"baseline\"].forEach(n => {\n          this.modes[n] && this.modes[n].updatedRows.length && e.push(n);\n        }), e.length) {\n          for (let n = 0; n < e.length; n++) this.setGanttMode(e[n]), this.sendAllData();\n          return;\n        }\n        return this.sendAllData();\n      }\n      return !this._in_progress[t] && (this.messages = [], !(!this.checkBeforeUpdate(t) && this.callEvent(\"onValidationError\", [t, this.messages])) && void this._beforeSendData(this._getRowData(t), t));\n    }\n    serialize(t, e) {\n      if (this._serializeAsJson) return this._serializeAsJSON(t);\n      if (typeof t == \"string\") return t;\n      if (e !== void 0) return this.serialize_one(t, \"\");\n      {\n        const n = [],\n          i = [];\n        for (const a in t) t.hasOwnProperty(a) && (n.push(this.serialize_one(t[a], a + this._postDelim)), i.push(a));\n        return n.push(\"ids=\" + this.escape(i.join(\",\"))), this.$gantt.security_key && n.push(\"dhx_security=\" + this.$gantt.security_key), n.join(\"&\");\n      }\n    }\n    serialize_one(t, e) {\n      if (typeof t == \"string\") return t;\n      const n = [];\n      let i = \"\";\n      for (const a in t) if (t.hasOwnProperty(a)) {\n        if ((a === \"id\" || a == this.action_param) && this._tMode === \"REST\") continue;\n        i = typeof t[a] == \"string\" || typeof t[a] == \"number\" ? String(t[a]) : JSON.stringify(t[a]), n.push(this.escape((e || \"\") + a) + \"=\" + this.escape(i));\n      }\n      return n.join(\"&\");\n    }\n    sendAllData() {\n      if (!this.updatedRows.length) return;\n      this.messages = [];\n      let t = !0;\n      if (this._forEachUpdatedRow(function (e) {\n        t = t && this.checkBeforeUpdate(e);\n      }), !t && !this.callEvent(\"onValidationError\", [\"\", this.messages])) return !1;\n      this._tSend ? this._sendData(this._getAllData()) : this._forEachUpdatedRow(function (e) {\n        if (!this._in_progress[e]) {\n          if (this.is_invalid(e)) return;\n          this._beforeSendData(this._getRowData(e), e);\n        }\n      });\n    }\n    findRow(t) {\n      let e = 0;\n      for (e = 0; e < this.updatedRows.length && t != this.updatedRows[e]; e++);\n      return e;\n    }\n    defineAction(t, e) {\n      this._uActions || (this._uActions = {}), this._uActions[t] = e;\n    }\n    afterUpdateCallback(t, e, n, i, a) {\n      if (!this.$gantt) return;\n      this.setGanttMode(a);\n      const r = t,\n        s = n !== \"error\" && n !== \"invalid\";\n      if (s || this.set_invalid(t, n), this._uActions && this._uActions[n] && !this._uActions[n](i)) return delete this._in_progress[r];\n      this._in_progress[r] !== \"wait\" && this.setUpdated(t, !1);\n      const o = t;\n      switch (n) {\n        case \"inserted\":\n        case \"insert\":\n          e != t && (this.setUpdated(t, !1), this.$gantt[this._methods[2]](t, e), t = e);\n          break;\n        case \"delete\":\n        case \"deleted\":\n          if (this.deleteAfterConfirmation && this._ganttMode === \"task\") {\n            if (this._ganttMode === \"task\" && this.$gantt.isTaskExists(t)) {\n              this.$gantt.setUserData(t, this.action_param, \"true_deleted\", this._ganttMode);\n              const l = this.$gantt.getTask(t);\n              this.$gantt.silent(() => {\n                this.$gantt.deleteTask(t);\n              }), this.$gantt.callEvent(\"onAfterTaskDelete\", [t, l]), this.$gantt.render(), delete this._in_progress[r];\n            }\n            return this.callEvent(\"onAfterUpdate\", [t, n, e, i]);\n          }\n          return this.$gantt.setUserData(t, this.action_param, \"true_deleted\", this._ganttMode), this.$gantt[this._methods[3]](t), delete this._in_progress[r], this.callEvent(\"onAfterUpdate\", [t, n, e, i]);\n      }\n      this._in_progress[r] !== \"wait\" ? (s && this.$gantt.setUserData(t, this.action_param, \"\", this._ganttMode), delete this._in_progress[r]) : (delete this._in_progress[r], this.setUpdated(e, !0, this.$gantt.getUserData(t, this.action_param, this._ganttMode))), this.callEvent(\"onAfterUpdate\", [o, n, e, i]);\n    }\n    afterUpdate(t, e, n) {\n      let i;\n      i = arguments.length === 3 ? arguments[1] : arguments[4];\n      let a = this.getGanttMode();\n      const r = i.filePath || i.url;\n      a = this._tMode !== \"REST\" && this._tMode !== \"REST-JSON\" ? r.indexOf(\"gantt_mode=links\") !== -1 ? \"link\" : r.indexOf(\"gantt_mode=assignments\") !== -1 ? \"assignment\" : r.indexOf(\"gantt_mode=baselines\") !== -1 ? \"baseline\" : \"task\" : r.indexOf(\"/link\") >= 0 ? \"link\" : r.indexOf(\"/assignment\") >= 0 ? \"assignment\" : r.indexOf(\"/baseline\") >= 0 ? \"baseline\" : \"task\", this.setGanttMode(a);\n      const s = this.$gantt.ajax;\n      let o;\n      try {\n        o = JSON.parse(e.xmlDoc.responseText);\n      } catch {\n        e.xmlDoc.responseText.length || (o = {});\n      }\n      const l = u => {\n        const h = o.action || this.getState(u) || \"updated\",\n          g = o.sid || u[0],\n          f = o.tid || u[0];\n        t.afterUpdateCallback(g, f, h, o, a);\n      };\n      if (o) return Array.isArray(n) && n.length > 1 ? n.forEach(u => l(u)) : l(n), t.finalizeUpdate(), void this.setGanttMode(a);\n      const d = s.xmltop(\"data\", e.xmlDoc);\n      if (!d) return this.cleanUpdate(n);\n      const c = s.xpath(\"//data/action\", d);\n      if (!c.length) return this.cleanUpdate(n);\n      for (let u = 0; u < c.length; u++) {\n        const h = c[u],\n          g = h.getAttribute(\"type\"),\n          f = h.getAttribute(\"sid\"),\n          y = h.getAttribute(\"tid\");\n        t.afterUpdateCallback(f, y, g, h, a);\n      }\n      t.finalizeUpdate();\n    }\n    cleanUpdate(t) {\n      if (t) for (let e = 0; e < t.length; e++) delete this._in_progress[t[e]];\n    }\n    finalizeUpdate() {\n      this._waitMode && this._waitMode--, this.callEvent(\"onAfterUpdateFinish\", []), this.updatedRows.length || this.callEvent(\"onFullSync\", []);\n    }\n    init(t) {\n      if (this._initialized) return;\n      this.$gantt = t, this.$gantt._dp_init && this.$gantt._dp_init(this), this._setDefaultTransactionMode(), this.styles = {\n        updated: \"gantt_updated\",\n        order: \"gantt_updated\",\n        inserted: \"gantt_inserted\",\n        deleted: \"gantt_deleted\",\n        delete_confirmation: \"gantt_deleted\",\n        invalid: \"gantt_invalid\",\n        error: \"gantt_error\",\n        clear: \"\"\n      }, this._methods = [\"_row_style\", \"setCellTextStyle\", \"_change_id\", \"_delete_task\"], function (n, i) {\n        n.getUserData = function (a, r, s) {\n          return this.userdata || (this.userdata = {}), this.userdata[s] = this.userdata[s] || {}, this.userdata[s][a] && this.userdata[s][a][r] ? this.userdata[s][a][r] : \"\";\n        }, n.setUserData = function (a, r, s, o) {\n          this.userdata || (this.userdata = {}), this.userdata[o] = this.userdata[o] || {}, this.userdata[o][a] = this.userdata[o][a] || {}, this.userdata[o][a][r] = s;\n        }, n._change_id = function (a, r) {\n          switch (this._dp._ganttMode) {\n            case \"task\":\n              this.changeTaskId(a, r);\n              break;\n            case \"link\":\n              this.changeLinkId(a, r);\n              break;\n            case \"assignment\":\n              this.$data.assignmentsStore.changeId(a, r);\n              break;\n            case \"resource\":\n              this.$data.resourcesStore.changeId(a, r);\n              break;\n            case \"baseline\":\n              this.$data.baselineStore.changeId(a, r);\n              break;\n            default:\n              throw new Error(`Invalid mode of the dataProcessor after database id is received: ${this._dp._ganttMode}, new id: ${r}`);\n          }\n        }, n._row_style = function (a, r) {\n          this._dp._ganttMode === \"task\" && n.isTaskExists(a) && (n.getTask(a).$dataprocessor_class = r, n.refreshTask(a));\n        }, n._delete_task = function (a, r) {}, n._sendTaskOrder = function (a, r) {\n          r.$drop_target && (this._dp.setGanttMode(\"task\"), this.getTask(a).target = r.$drop_target, this._dp.setUpdated(a, !0, \"order\"), delete this.getTask(a).$drop_target);\n        }, n.setDp = function () {\n          this._dp = i;\n        }, n.setDp();\n      }(this.$gantt, this);\n      const e = new ai(this.$gantt, this);\n      e.attach(), this.attachEvent(\"onDestroy\", function () {\n        delete this.setGanttMode, delete this._getRowData, delete this.$gantt._dp, delete this.$gantt._change_id, delete this.$gantt._row_style, delete this.$gantt._delete_task, delete this.$gantt._sendTaskOrder, delete this.$gantt, e.detach();\n      }), this.$gantt.callEvent(\"onDataProcessorReady\", [this]), this._initialized = !0;\n    }\n    setOnAfterUpdate(t) {\n      this.attachEvent(\"onAfterUpdate\", t);\n    }\n    setOnBeforeUpdateHandler(t) {\n      this.attachEvent(\"onBeforeDataSending\", t);\n    }\n    setAutoUpdate(t, e) {\n      t = t || 2e3, this._user = e || /* @__PURE__ */new Date().valueOf(), this._needUpdate = !1, this._updateBusy = !1, this.attachEvent(\"onAfterUpdate\", this.afterAutoUpdate), this.attachEvent(\"onFullSync\", this.fullSync), setInterval(() => {\n        this.loadUpdate();\n      }, t);\n    }\n    afterAutoUpdate(t, e, n, i) {\n      return e !== \"collision\" || (this._needUpdate = !0, !1);\n    }\n    fullSync() {\n      return this._needUpdate && (this._needUpdate = !1, this.loadUpdate()), !0;\n    }\n    getUpdates(t, e) {\n      const n = this.$gantt.ajax;\n      if (this._updateBusy) return !1;\n      this._updateBusy = !0, n.get(t, e);\n    }\n    loadUpdate() {\n      const t = this.$gantt.ajax,\n        e = this.$gantt.getUserData(0, \"version\", this._ganttMode);\n      let n = this.serverProcessor + t.urlSeparator(this.serverProcessor) + [\"dhx_user=\" + this._user, \"dhx_version=\" + e].join(\"&\");\n      n = n.replace(\"editing=true&\", \"\"), this.getUpdates(n, i => {\n        const a = t.xpath(\"//userdata\", i);\n        this.$gantt.setUserData(0, \"version\", this._getXmlNodeValue(a[0]), this._ganttMode);\n        const r = t.xpath(\"//update\", i);\n        if (r.length) {\n          this._silent_mode = !0;\n          for (let s = 0; s < r.length; s++) {\n            const o = r[s].getAttribute(\"status\"),\n              l = r[s].getAttribute(\"id\"),\n              d = r[s].getAttribute(\"parent\");\n            switch (o) {\n              case \"inserted\":\n                this.callEvent(\"insertCallback\", [r[s], l, d]);\n                break;\n              case \"updated\":\n                this.callEvent(\"updateCallback\", [r[s], l, d]);\n                break;\n              case \"deleted\":\n                this.callEvent(\"deleteCallback\", [r[s], l, d]);\n            }\n          }\n          this._silent_mode = !1;\n        }\n        this._updateBusy = !1;\n      });\n    }\n    destructor() {\n      this.callEvent(\"onDestroy\", []), this.detachAllEvents(), this.updatedRows = [], this._in_progress = {}, this._invalid = {}, this._storage.clear(), this._storage = null, this._headers = null, this._payload = null, delete this._initialized;\n    }\n    setGanttMode(t) {\n      t === \"tasks\" ? t = \"task\" : t === \"links\" && (t = \"link\");\n      const e = this.modes || {},\n        n = this.getGanttMode();\n      n && (e[n] = {\n        _in_progress: this._in_progress,\n        _invalid: this._invalid,\n        _storage: this._storage,\n        updatedRows: this.updatedRows\n      });\n      let i = e[t];\n      i || (i = e[t] = {\n        _in_progress: {},\n        _invalid: {},\n        _storage: Jt.create(),\n        updatedRows: []\n      }), this._in_progress = i._in_progress, this._invalid = i._invalid, this._storage = i._storage, this.updatedRows = i.updatedRows, this.modes = e, this._ganttMode = t;\n    }\n    getGanttMode() {\n      return this._ganttMode;\n    }\n    storeItem(t) {\n      this._storage.storeItem(t);\n    }\n    url(t) {\n      this.serverProcessor = this._serverProcessor = t;\n    }\n    _beforeSendData(t, e) {\n      if (!this.callEvent(\"onBeforeUpdate\", [e, this.getState(e), t])) return !1;\n      this._sendData(t, e);\n    }\n    _serializeAsJSON(t) {\n      if (typeof t == \"string\") return t;\n      const e = G(t);\n      return this._tMode === \"REST-JSON\" && (delete e.id, delete e[this.action_param]), JSON.stringify(e);\n    }\n    _applyPayload(t) {\n      const e = this.$gantt.ajax;\n      if (this._payload) for (const n in this._payload) t = t + e.urlSeparator(t) + this.escape(n) + \"=\" + this.escape(this._payload[n]);\n      return t;\n    }\n    _cleanupArgumentsBeforeSend(t) {\n      let e;\n      if (t[this.action_param] === void 0) {\n        e = {};\n        for (const n in t) e[n] = this._cleanupArgumentsBeforeSend(t[n]);\n      } else e = this._cleanupItemBeforeSend(t);\n      return e;\n    }\n    _cleanupItemBeforeSend(t) {\n      let e = null;\n      return t && (t[this.action_param] === \"deleted\" ? (e = {}, e.id = t.id, e[this.action_param] = t[this.action_param]) : e = t), e;\n    }\n    _sendData(t, e) {\n      if (!t) return;\n      if (!this.callEvent(\"onBeforeDataSending\", e ? [e, this.getState(e), t] : [null, null, t])) return !1;\n      e && (this._in_progress[e] = /* @__PURE__ */new Date().valueOf());\n      const n = this.$gantt.ajax;\n      if (this._tMode === \"CUSTOM\") {\n        const l = this.getState(e),\n          d = this.getActionByState(l),\n          c = this.getGanttMode(),\n          u = g => {\n            let f = l || \"updated\",\n              y = e,\n              v = e;\n            g && (f = g.action || l, y = g.sid || y, v = g.id || g.tid || v), this.afterUpdateCallback(y, v, f, g, c);\n          };\n        let h;\n        if (this._router instanceof Function) {\n          if (this._routerParametersFormat === \"object\") {\n            const g = {\n              entity: c,\n              action: d,\n              data: t,\n              id: e\n            };\n            h = this._router(g);\n          } else h = this._router(c, d, t, e);\n        } else if (this._router[c] instanceof Function) h = this._router[c](d, t, e);else {\n          const g = \"Incorrect configuration of gantt.createDataProcessor\",\n            f = `\nYou need to either add missing properties to the dataProcessor router object or to use a router function.\nSee https://docs.dhtmlx.com/gantt/desktop__server_side.html#customrouting and https://docs.dhtmlx.com/gantt/api__gantt_createdataprocessor.html for details.`;\n          if (!this._router[c]) throw new Error(`${g}: router for the **${c}** entity is not defined. ${f}`);\n          switch (l) {\n            case \"inserted\":\n              if (!this._router[c].create) throw new Error(`${g}: **create** action for the **${c}** entity is not defined. ${f}`);\n              h = this._router[c].create(t);\n              break;\n            case \"deleted\":\n              if (!this._router[c].delete) throw new Error(`${g}: **delete** action for the **${c}** entity is not defined. ${f}`);\n              h = this._router[c].delete(e);\n              break;\n            default:\n              if (!this._router[c].update) throw new Error(`${g}: **update**\" action for the **${c}** entity is not defined. ${f}`);\n              h = this._router[c].update(t, e);\n          }\n        }\n        if (h) {\n          if (!h.then && h.id === void 0 && h.tid === void 0 && h.action === void 0) throw new Error(\"Incorrect router return value. A Promise or a response object is expected\");\n          h.then ? h.then(u).catch(g => {\n            g && g.action ? u(g) : u({\n              action: \"error\",\n              value: g\n            });\n          }) : u(h);\n        } else u(null);\n        return;\n      }\n      let i;\n      i = {\n        callback: l => {\n          const d = [];\n          if (e) d.push(e);else if (t) for (const c in t) d.push(c);\n          return this.afterUpdate(this, l, d);\n        },\n        headers: this._headers\n      };\n      const a = \"dhx_version=\" + this.$gantt.getUserData(0, \"version\", this._ganttMode),\n        r = this.serverProcessor + (this._user ? n.urlSeparator(this.serverProcessor) + [\"dhx_user=\" + this._user, a].join(\"&\") : \"\");\n      let s,\n        o = this._applyPayload(r);\n      switch (this._tMode) {\n        case \"GET\":\n          s = this._cleanupArgumentsBeforeSend(t), i.url = o + n.urlSeparator(o) + this.serialize(s, e), i.method = \"GET\";\n          break;\n        case \"POST\":\n          s = this._cleanupArgumentsBeforeSend(t), i.url = o, i.method = \"POST\", i.data = this.serialize(s, e);\n          break;\n        case \"JSON\":\n          s = {};\n          const l = this._cleanupItemBeforeSend(t);\n          for (const d in l) d !== this.action_param && d !== \"id\" && d !== \"gr_id\" && (s[d] = l[d]);\n          i.url = o, i.method = \"POST\", i.data = JSON.stringify({\n            id: e,\n            action: t[this.action_param],\n            data: s\n          });\n          break;\n        case \"REST\":\n        case \"REST-JSON\":\n          switch (o = r.replace(/(&|\\?)editing=true/, \"\"), s = \"\", this.getState(e)) {\n            case \"inserted\":\n              i.method = \"POST\", i.data = this.serialize(t, e);\n              break;\n            case \"deleted\":\n              i.method = \"DELETE\", o = o + (o.slice(-1) === \"/\" ? \"\" : \"/\") + e;\n              break;\n            default:\n              i.method = \"PUT\", i.data = this.serialize(t, e), o = o + (o.slice(-1) === \"/\" ? \"\" : \"/\") + e;\n          }\n          i.url = this._applyPayload(o);\n      }\n      return this._waitMode++, n.query(i);\n    }\n    _forEachUpdatedRow(t) {\n      const e = this.updatedRows.slice();\n      for (let n = 0; n < e.length; n++) {\n        const i = e[n];\n        this.$gantt.getUserData(i, this.action_param, this._ganttMode) && t.call(this, i);\n      }\n    }\n    _setDefaultTransactionMode() {\n      this.serverProcessor && (this.setTransactionMode(\"POST\", !0), this.serverProcessor += (this.serverProcessor.indexOf(\"?\") !== -1 ? \"&\" : \"?\") + \"editing=true\", this._serverProcessor = this.serverProcessor);\n    }\n    _getXmlNodeValue(t) {\n      return t.firstChild ? t.firstChild.nodeValue : \"\";\n    }\n    _getAllData() {\n      const t = {};\n      let e = !1;\n      return this._forEachUpdatedRow(function (n) {\n        if (this._in_progress[n] || this.is_invalid(n)) return;\n        const i = this._getRowData(n);\n        this.callEvent(\"onBeforeUpdate\", [n, this.getState(n), i]) && (t[n] = i, e = !0, this._in_progress[n] = /* @__PURE__ */new Date().valueOf());\n      }), e ? t : null;\n    }\n    _prepareDate(t) {\n      return this.$gantt.defined(this.$gantt.templates.xml_format) ? this.$gantt.templates.xml_format(t) : this.$gantt.templates.format_date(t);\n    }\n    _prepareArray(t, e) {\n      return e.push(t), t.map(n => Z(n) ? this._prepareDate(n) : Array.isArray(n) && !zt(e, n) ? this._prepareArray(n, e) : n && typeof n == \"object\" && !zt(e, n) ? this._prepareObject(n, e) : n);\n    }\n    _prepareObject(t, e) {\n      const n = {};\n      e.push(t);\n      for (const i in t) {\n        if (i.substr(0, 1) === \"$\") continue;\n        const a = t[i];\n        Z(a) ? n[i] = this._prepareDate(a) : a === null ? n[i] = \"\" : Array.isArray(a) && !zt(e, a) ? n[i] = this._prepareArray(a, e) : a && typeof a == \"object\" && !zt(e, a) ? n[i] = this._prepareObject(a, e) : n[i] = a;\n      }\n      return n;\n    }\n    _prepareDataItem(t) {\n      const e = this._prepareObject(t, []);\n      return e[this.action_param] = this.$gantt.getUserData(t.id, this.action_param, this._ganttMode), e;\n    }\n    getStoredItem(t) {\n      return this._storage.getStoredItem(t);\n    }\n    _getRowData(t) {\n      let e;\n      const n = this.$gantt;\n      return this.getGanttMode() === \"task\" ? n.isTaskExists(t) && (e = this.$gantt.getTask(t)) : this.getGanttMode() === \"assignment\" ? this.$gantt.$data.assignmentsStore.exists(t) && (e = this.$gantt.$data.assignmentsStore.getItem(t)) : this.getGanttMode() === \"baseline\" ? this.$gantt.$data.baselineStore.exists(t) && (e = this.$gantt.$data.baselineStore.getItem(t)) : n.isLinkExists(t) && (e = this.$gantt.getLink(t)), e || (e = this.getStoredItem(t)), e || (e = {\n        id: t\n      }), this._prepareDataItem(e);\n    }\n  };\nconst Be = {\n  DEPRECATED_api: function (t) {\n    return new Oe(t);\n  },\n  createDataProcessor: function (t) {\n    let e, n, i;\n    t instanceof Function ? e = t : t.hasOwnProperty(\"router\") ? e = t.router : t.hasOwnProperty(\"assignment\") || t.hasOwnProperty(\"baseline\") || t.hasOwnProperty(\"link\") || t.hasOwnProperty(\"task\") ? e = t : t.hasOwnProperty(\"headers\") && (i = t.headers), n = e ? \"CUSTOM\" : t.mode || \"REST-JSON\";\n    const a = new Oe(t.url);\n    return a.init(this), a.setTransactionMode({\n      mode: n,\n      router: e,\n      headers: i\n    }, t.batchUpdate), t.deleteAfterConfirmation && (a.deleteAfterConfirmation = t.deleteAfterConfirmation), a;\n  }\n};\nfunction ri(t) {\n  var e = {},\n    n = !1;\n  function i(l, d) {\n    d = typeof d == \"function\" ? d : function () {}, e[l] || (e[l] = this[l], this[l] = d);\n  }\n  function a(l) {\n    e[l] && (this[l] = e[l], e[l] = null);\n  }\n  function r(l) {\n    for (var d in l) i.call(this, d, l[d]);\n  }\n  function s() {\n    for (var l in e) a.call(this, l);\n  }\n  function o(l) {\n    try {\n      l();\n    } catch (d) {\n      dt.console.error(d);\n    }\n  }\n  return t.$services.getService(\"state\").registerProvider(\"batchUpdate\", function () {\n    return {\n      batch_update: n\n    };\n  }, !1), function (l, d) {\n    if (n) o(l);else {\n      var c,\n        u = this._dp && this._dp.updateMode != \"off\";\n      u && (c = this._dp.updateMode, this._dp.setUpdateMode(\"off\"));\n      var h = {},\n        g = {\n          render: !0,\n          refreshData: !0,\n          refreshTask: !0,\n          refreshLink: !0,\n          resetProjectDates: function (y) {\n            h[y.id] = y;\n          }\n        };\n      for (var f in r.call(this, g), n = !0, this.callEvent(\"onBeforeBatchUpdate\", []), o(l), this.callEvent(\"onAfterBatchUpdate\", []), s.call(this), h) this.resetProjectDates(h[f]);\n      n = !1, d || this.render(), u && (this._dp.setUpdateMode(c), this._dp.setGanttMode(\"task\"), this._dp.sendData(), this._dp.setGanttMode(\"link\"), this._dp.sendData());\n    }\n  };\n}\nfunction si(t) {\n  t.batchUpdate = ri(t);\n}\nconst oi = function (t) {\n  return {\n    _needRecalc: !0,\n    reset: function () {\n      this._needRecalc = !0;\n    },\n    _isRecalcNeeded: function () {\n      return !this._isGroupSort() && this._needRecalc;\n    },\n    _isGroupSort: function () {\n      return !!t.getState().group_mode;\n    },\n    _getWBSCode: function (e) {\n      return e ? (this._isRecalcNeeded() && this._calcWBS(), e.$virtual ? \"\" : this._isGroupSort() ? e.$wbs || \"\" : (e.$wbs || (this.reset(), this._calcWBS()), e.$wbs)) : \"\";\n    },\n    _setWBSCode: function (e, n) {\n      e.$wbs = n;\n    },\n    getWBSCode: function (e) {\n      return this._getWBSCode(e);\n    },\n    getByWBSCode: function (e) {\n      let n = e.split(\".\"),\n        i = t.config.root_id;\n      for (let a = 0; a < n.length; a++) {\n        const r = t.getChildren(i);\n        let s = 1 * n[a] - 1;\n        if (!t.isTaskExists(r[s])) return null;\n        i = r[s];\n      }\n      return t.isTaskExists(i) ? t.getTask(i) : null;\n    },\n    _calcWBS: function () {\n      if (!this._isRecalcNeeded()) return;\n      let e = !0;\n      t.eachTask(function (n) {\n        if (n.type == t.config.types.placeholder) return;\n        if (e) return e = !1, void this._setWBSCode(n, \"1\");\n        const i = this._getPrevNonPlaceholderSibling(n.id);\n        if (i !== null) this._increaseWBS(n, i);else {\n          let a = t.getParent(n.id);\n          this._setWBSCode(n, t.getTask(a).$wbs + \".1\");\n        }\n      }, t.config.root_id, this), this._needRecalc = !1;\n    },\n    _increaseWBS: function (e, n) {\n      let i = t.getTask(n).$wbs;\n      i && (i = i.split(\".\"), i[i.length - 1]++, this._setWBSCode(e, i.join(\".\")));\n    },\n    _getPrevNonPlaceholderSibling: function (e) {\n      let n,\n        i = e;\n      do n = t.getPrevSibling(i), i = n; while (n !== null && t.getTask(n).type == t.config.types.placeholder);\n      return n;\n    }\n  };\n};\nfunction li(t) {\n  const e = oi(t);\n  function n() {\n    return e.reset(), !0;\n  }\n  t.getWBSCode = function (i) {\n    return e.getWBSCode(i);\n  }, t.getTaskByWBSCode = function (i) {\n    return e.getByWBSCode(i);\n  }, t.attachEvent(\"onAfterTaskMove\", n), t.attachEvent(\"onBeforeParse\", n), t.attachEvent(\"onAfterTaskDelete\", n), t.attachEvent(\"onAfterTaskAdd\", n), t.attachEvent(\"onAfterSort\", n);\n}\nfunction di(t) {\n  var e = {},\n    n = !1;\n  t.$data.tasksStore.attachEvent(\"onStoreUpdated\", function () {\n    e = {}, n = !1;\n  }), t.attachEvent(\"onBeforeGanttRender\", function () {\n    e = {};\n  });\n  var i = String(Math.random());\n  function a(l) {\n    return l === null ? i + String(l) : String(l);\n  }\n  function r(l, d, c) {\n    return Array.isArray(l) ? l.map(function (u) {\n      return a(u);\n    }).join(\"_\") + `_${d}_${c}` : a(l) + `_${d}_${c}`;\n  }\n  function s(l, d, c) {\n    var u,\n      h = r(d, l, JSON.stringify(c)),\n      g = {};\n    return kt(d, function (f) {\n      g[a(f)] = !0;\n    }), e[h] ? u = e[h] : (u = e[h] = [], t.eachTask(function (f) {\n      if (c) {\n        if (!c[t.getTaskType(f)]) return;\n      } else if (f.type == t.config.types.project) return;\n      l in f && kt(fe(f[l]) ? f[l] : [f[l]], function (y) {\n        var v = y && y.resource_id ? y.resource_id : y;\n        if (g[a(v)]) u.push(f);else if (!n) {\n          var b = r(y, l);\n          e[b] || (e[b] = []), e[b].push(f);\n        }\n      });\n    }), n = !0), u;\n  }\n  function o(l, d, c) {\n    var u = t.config.resource_property,\n      h = [];\n    if (t.getDatastore(\"task\").exists(d)) {\n      var g = t.getTask(d);\n      h = g[u] || [];\n    }\n    Array.isArray(h) || (h = [h]);\n    for (var f = 0; f < h.length; f++) h[f].resource_id == l && c.push({\n      task_id: g.id,\n      resource_id: h[f].resource_id,\n      value: h[f].value\n    });\n  }\n  return {\n    getTaskBy: function (l, d, c) {\n      return typeof l == \"function\" ? (u = l, h = [], t.eachTask(function (g) {\n        u(g) && h.push(g);\n      }), h) : fe(d) ? s(l, d, c) : s(l, [d], c);\n      var u, h;\n    },\n    getResourceAssignments: function (l, d) {\n      var c = [],\n        u = t.config.resource_property;\n      return d !== void 0 ? o(l, d, c) : t.getTaskBy(u, l).forEach(function (h) {\n        o(l, h.id, c);\n      }), c;\n    }\n  };\n}\nfunction ci(t) {\n  var e = di(t);\n  t.ext.resources = /* @__PURE__ */function (a) {\n    const r = {\n      renderEditableLabel: function (s, o, l, d, c) {\n        const u = a.config.readonly ? \"\" : \"contenteditable\";\n        if (s < l.end_date && o > l.start_date) {\n          for (let h = 0; h < c.length; h++) {\n            const g = c[h];\n            return \"<div \" + u + \" data-assignment-cell data-assignment-id='\" + g.id + \"' data-row-id='\" + l.id + \"' data-task='\" + l.$task_id + \"' data-start-date='\" + a.templates.format_date(s) + \"' data-end-date='\" + a.templates.format_date(o) + \"'>\" + g.value + \"</div>\";\n          }\n          return \"<div \" + u + \" data-assignment-cell data-empty  data-row-id='\" + l.id + \"' data-resource-id='\" + l.$resource_id + \"' data-task='\" + l.$task_id + \"' data-start-date='\" + a.templates.format_date(s) + \"''  data-end-date='\" + a.templates.format_date(o) + \"'>-</div>\";\n        }\n        return \"\";\n      },\n      renderSummaryLabel: function (s, o, l, d, c) {\n        let u = c.reduce(function (h, g) {\n          return h + Number(g.value);\n        }, 0);\n        return u % 1 && (u = Math.round(10 * u) / 10), u ? \"<div>\" + u + \"</div>\" : \"\";\n      },\n      editableResourceCellTemplate: function (s, o, l, d, c) {\n        return l.$role === \"task\" ? r.renderEditableLabel(s, o, l, d, c) : r.renderSummaryLabel(s, o, l, d, c);\n      },\n      editableResourceCellClass: function (s, o, l, d, c) {\n        const u = [];\n        u.push(\"resource_marker\"), l.$role === \"task\" ? u.push(\"task_cell\") : u.push(\"resource_cell\");\n        const h = c.reduce(function (f, y) {\n          return f + Number(y.value);\n        }, 0);\n        let g = Number(l.capacity);\n        return isNaN(g) && (g = 8), h <= g ? u.push(\"workday_ok\") : u.push(\"workday_over\"), u.join(\" \");\n      },\n      getSummaryResourceAssignments: function (s) {\n        let o;\n        const l = a.getDatastore(a.config.resource_store),\n          d = l.getItem(s);\n        return d.$role === \"task\" ? o = a.getResourceAssignments(d.$resource_id, d.$task_id) : (o = a.getResourceAssignments(s), l.eachItem && l.eachItem(function (c) {\n          c.$role !== \"task\" && (o = o.concat(a.getResourceAssignments(c.id)));\n        }, s)), o;\n      },\n      initEditableDiagram: function () {\n        a.config.resource_render_empty_cells = !0, function () {\n          let l = null;\n          function d() {\n            return l && cancelAnimationFrame(l), l = requestAnimationFrame(function () {\n              a.$container && Array.prototype.slice.call(a.$container.querySelectorAll(\".resourceTimeline_cell [data-assignment-cell]\")).forEach(function (c) {\n                c.contentEditable = !0;\n              });\n            }), !0;\n          }\n          a.attachEvent(\"onGanttReady\", function () {\n            a.getDatastore(a.config.resource_assignment_store).attachEvent(\"onStoreUpdated\", d), a.getDatastore(a.config.resource_store).attachEvent(\"onStoreUpdated\", d);\n          }, {\n            once: !0\n          }), a.attachEvent(\"onGanttLayoutReady\", function () {\n            a.$layout.getCellsByType(\"viewCell\").forEach(function (c) {\n              c.$config && c.$config.view === \"resourceTimeline\" && c.$content && c.$content.attachEvent(\"onScroll\", d);\n            });\n          });\n        }();\n        let s = null;\n        function o() {\n          setTimeout(function () {\n            const l = Lt(a.$container);\n            s > -1 && l[s + 1].focus();\n          }, 300);\n        }\n        a.attachEvent(\"onGanttReady\", function () {\n          let l = !1;\n          a.event(a.$container, \"keypress\", function (d) {\n            var c = d.target.closest(\".resourceTimeline_cell [data-assignment-cell]\");\n            c && (d.keyCode !== 13 && d.keyCode !== 27 || c.blur());\n          }), a.event(a.$container, \"keydown\", function (d) {\n            d.key === \"Tab\" && (s = Lt(a.$container).indexOf(document.activeElement));\n          }), a.event(a.$container, \"focusout\", function (d) {\n            if (!l) {\n              l = !0, setTimeout(function () {\n                l = !1;\n              }, 300);\n              var c = d.target.closest(\".resourceTimeline_cell [data-assignment-cell]\");\n              if (c) {\n                var u = (c.innerText || \"\").trim();\n                u == \"-\" && (u = \"0\");\n                var h = Number(u),\n                  g = c.getAttribute(\"data-row-id\"),\n                  f = c.getAttribute(\"data-assignment-id\"),\n                  y = c.getAttribute(\"data-task\"),\n                  v = c.getAttribute(\"data-resource-id\"),\n                  b = a.templates.parse_date(c.getAttribute(\"data-start-date\")),\n                  _ = a.templates.parse_date(c.getAttribute(\"data-end-date\")),\n                  m = a.getDatastore(a.config.resource_assignment_store);\n                if (isNaN(h)) a.getDatastore(a.config.resource_store).refresh(g);else {\n                  var p = a.getTask(y);\n                  if (a.plugins().undo && a.ext.undo.saveState(y, \"task\"), f) {\n                    if (h === (x = m.getItem(f)).value) return;\n                    if (x.start_date.valueOf() === b.valueOf() && x.end_date.valueOf() === _.valueOf()) x.value = h, h ? m.updateItem(x.id) : m.removeItem(x.id);else {\n                      if (x.end_date.valueOf() > _.valueOf()) {\n                        var k = a.copy(x);\n                        k.id = a.uid(), k.start_date = _, k.duration = a.calculateDuration({\n                          start_date: k.start_date,\n                          end_date: k.end_date,\n                          task: p\n                        }), k.delay = a.calculateDuration({\n                          start_date: p.start_date,\n                          end_date: k.start_date,\n                          task: p\n                        }), k.mode = x.mode || \"default\", k.duration !== 0 && m.addItem(k);\n                      }\n                      x.start_date.valueOf() < b.valueOf() ? (x.end_date = b, x.duration = a.calculateDuration({\n                        start_date: x.start_date,\n                        end_date: x.end_date,\n                        task: p\n                      }), x.mode = \"fixedDuration\", x.duration === 0 ? m.removeItem(x.id) : m.updateItem(x.id)) : m.removeItem(x.id), h && m.addItem({\n                        task_id: x.task_id,\n                        resource_id: x.resource_id,\n                        value: h,\n                        start_date: b,\n                        end_date: _,\n                        duration: a.calculateDuration({\n                          start_date: b,\n                          end_date: _,\n                          task: p\n                        }),\n                        delay: a.calculateDuration({\n                          start_date: p.start_date,\n                          end_date: b,\n                          task: p\n                        }),\n                        mode: \"fixedDuration\"\n                      });\n                    }\n                    a.updateTaskAssignments(p.id), a.updateTask(p.id), o();\n                  } else if (h) {\n                    var x = {\n                      task_id: y,\n                      resource_id: v,\n                      value: h,\n                      start_date: b,\n                      end_date: _,\n                      duration: a.calculateDuration({\n                        start_date: b,\n                        end_date: _,\n                        task: p\n                      }),\n                      delay: a.calculateDuration({\n                        start_date: p.start_date,\n                        end_date: b,\n                        task: p\n                      }),\n                      mode: \"fixedDuration\"\n                    };\n                    m.addItem(x), a.updateTaskAssignments(p.id), a.updateTask(p.id), o();\n                  }\n                }\n              }\n            }\n          });\n        }, {\n          once: !0\n        });\n      }\n    };\n    return r;\n  }(t), t.config.resources = {\n    dataprocessor_assignments: !1,\n    dataprocessor_resources: !1,\n    editable_resource_diagram: !1,\n    resource_store: {\n      type: \"treeDataStore\",\n      fetchTasks: !1,\n      initItem: function (a) {\n        return a.parent = a.parent || t.config.root_id, a[t.config.resource_property] = a.parent, a.open = !0, a;\n      }\n    },\n    lightbox_resources: function (a) {\n      const r = [],\n        s = t.getDatastore(t.config.resource_store);\n      return a.forEach(function (o) {\n        if (!s.hasChild(o.id)) {\n          const l = t.copy(o);\n          l.key = o.id, l.label = o.text, r.push(l);\n        }\n      }), r;\n    }\n  }, t.attachEvent(\"onBeforeGanttReady\", function () {\n    if (t.getDatastore(t.config.resource_store)) return;\n    const a = t.config.resources ? t.config.resources.resource_store : void 0;\n    let r = a ? a.fetchTasks : void 0;\n    t.config.resources && t.config.resources.editable_resource_diagram && (r = !0);\n    let s = function (l) {\n      return l.parent = l.parent || t.config.root_id, l[t.config.resource_property] = l.parent, l.open = !0, l;\n    };\n    a && a.initItem && (s = a.initItem);\n    const o = a && a.type ? a.type : \"treeDatastore\";\n    t.$resourcesStore = t.createDatastore({\n      name: t.config.resource_store,\n      type: o,\n      fetchTasks: r !== void 0 && r,\n      initItem: s\n    }), t.$data.resourcesStore = t.$resourcesStore, t.$resourcesStore.attachEvent(\"onParse\", function () {\n      let l,\n        d = function (c) {\n          const u = [];\n          return c.forEach(function (h) {\n            const g = t.copy(h);\n            g.key = h.id, g.label = h.text, u.push(g);\n          }), u;\n        };\n      t.config.resources && t.config.resources.lightbox_resources && (d = t.config.resources.lightbox_resources), t.config.resources && t.config.resources.editable_resource_diagram ? l = d(t.$resourcesStore.getItems().filter(c => {\n        let u = t.getResourceAssignments(c.id);\n        if (!t.$resourcesStore.hasChild(c.id) || u && u.length) return !c.$resource_id || !c.$task_id;\n      })) : l = d(t.$resourcesStore.getItems()), t.updateCollection(\"resourceOptions\", l);\n    });\n  }), t.getTaskBy = e.getTaskBy, t.getResourceAssignments = e.getResourceAssignments, t.config.resource_property = \"owner_id\", t.config.resource_store = \"resource\", t.config.resource_render_empty_cells = !1, t.templates.histogram_cell_class = function (a, r, s, o, l) {}, t.templates.histogram_cell_label = function (a, r, s, o, l) {\n    return o.length + \"/3\";\n  }, t.templates.histogram_cell_allocated = function (a, r, s, o, l) {\n    return o.length / 3;\n  }, t.templates.histogram_cell_capacity = function (a, r, s, o, l) {\n    return 0;\n  };\n  const n = function (a, r, s, o, l) {\n      return o.length <= 1 ? \"gantt_resource_marker_ok\" : \"gantt_resource_marker_overtime\";\n    },\n    i = function (a, r, s, o, l) {\n      return 8 * o.length;\n    };\n  t.templates.resource_cell_value = i, t.templates.resource_cell_class = n, t.attachEvent(\"onBeforeGanttReady\", function () {\n    t.config.resources && t.config.resources.editable_resource_diagram && (t.config.resource_render_empty_cells = !0, t.templates.resource_cell_value === i && (t.templates.resource_cell_value = t.ext.resources.editableResourceCellTemplate), t.templates.resource_cell_class === n && (t.templates.resource_cell_class = t.ext.resources.editableResourceCellClass), t.ext.resources.initEditableDiagram(t));\n  });\n}\nfunction ui(t) {\n  var e = \"$resourceAssignments\";\n  t.config.resource_assignment_store = \"resourceAssignments\", t.config.process_resource_assignments = !0;\n  var n = {\n      auto: \"auto\",\n      singleValue: \"singleValue\",\n      valueArray: \"valueArray\",\n      resourceValueArray: \"resourceValueArray\",\n      assignmentsArray: \"assignmentsArray\"\n    },\n    i = n.auto,\n    a = {\n      fixedDates: \"fixedDates\",\n      fixedDuration: \"fixedDuration\",\n      default: \"default\"\n    };\n  function r(f, y) {\n    f.start_date ? f.start_date = t.date.parseDate(f.start_date, \"parse_date\") : f.start_date = null, f.end_date ? f.end_date = t.date.parseDate(f.end_date, \"parse_date\") : f.end_date = null;\n    var v = Number(f.delay),\n      b = !1;\n    if (isNaN(v) ? (f.delay = 0, b = !0) : f.delay = v, t.defined(f.value) || (f.value = null), !f.task_id || !f.resource_id) return !1;\n    if (f.mode = f.mode || a.default, f.mode === a.fixedDuration && (isNaN(Number(f.duration)) && (y = y || t.getTask(f.task_id), f.duration = t.calculateDuration({\n      start_date: f.start_date,\n      end_date: f.end_date,\n      id: y\n    })), b && (y = y || t.getTask(f.task_id), f.delay = t.calculateDuration({\n      start_date: y.start_date,\n      end_date: f.start_date,\n      id: y\n    }))), f.mode !== a.fixedDates && (y || t.isTaskExists(f.task_id))) {\n      var _ = o(f, y = y || t.getTask(f.task_id));\n      f.start_date = _.start_date, f.end_date = _.end_date, f.duration = _.duration;\n    }\n  }\n  var s = t.createDatastore({\n    name: t.config.resource_assignment_store,\n    initItem: function (f) {\n      return f.id || (f.id = t.uid()), r(f), f;\n    }\n  });\n  function o(f, y) {\n    if (f.mode === a.fixedDates) return {\n      start_date: f.start_date,\n      end_date: f.end_date,\n      duration: f.duration\n    };\n    var v,\n      b,\n      _ = f.delay ? t.calculateEndDate({\n        start_date: y.start_date,\n        duration: f.delay,\n        task: y\n      }) : new Date(y.start_date);\n    return f.mode === a.fixedDuration ? (v = t.calculateEndDate({\n      start_date: _,\n      duration: f.duration,\n      task: y\n    }), b = f.duration) : (v = new Date(y.end_date), b = y.duration - f.delay), {\n      start_date: _,\n      end_date: v,\n      duration: b\n    };\n  }\n  function l(f) {\n    const y = t.config.resource_property;\n    let v = f[y];\n    const b = [];\n    let _ = i === n.auto;\n    if (t.defined(v) && v) {\n      Array.isArray(v) || (v = [v], _ && (i = n.singleValue, _ = !1));\n      const m = {};\n      v.forEach(function (p) {\n        p.resource_id || (p = {\n          resource_id: p\n        }, _ && (i = n.valueArray, _ = !1)), _ && (p.id && p.resource_id ? (i = n.assignmentsArray, _ = !1) : (i = n.resourceValueArray, _ = !1));\n        let k,\n          x = a.default;\n        p.mode || (p.start_date && p.end_date || p.start_date && p.duration) && (x = a.fixedDuration), k = p.id || !p.$id || m[p.$id] ? p.id && !m[p.id] ? p.id : t.uid() : p.$id, m[k] = !0;\n        const $ = {\n          id: k,\n          start_date: p.start_date,\n          duration: p.duration,\n          end_date: p.end_date,\n          delay: p.delay,\n          task_id: f.id,\n          resource_id: p.resource_id,\n          value: p.value,\n          mode: p.mode || x\n        };\n        Object.keys(p).forEach(w => {\n          w != \"$id\" && ($[w] = p[w]);\n        }), $.start_date && $.start_date.getMonth && $.end_date && $.end_date.getMonth && typeof $.duration == \"number\" || r($, f), b.push($);\n      });\n    }\n    return b;\n  }\n  function d(f) {\n    if (t.isTaskExists(f)) {\n      var y = t.getTask(f);\n      c(y, t.getTaskAssignments(y.id));\n    }\n  }\n  function c(f, y) {\n    y.sort(function (v, b) {\n      return v.start_date && b.start_date && v.start_date.valueOf() != b.start_date.valueOf() ? v.start_date - b.start_date : 0;\n    }), i == n.assignmentsArray ? f[t.config.resource_property] = y : i == n.resourceValueArray && (f[t.config.resource_property] = y.map(function (v) {\n      return {\n        $id: v.id,\n        start_date: v.start_date,\n        duration: v.duration,\n        end_date: v.end_date,\n        delay: v.delay,\n        resource_id: v.resource_id,\n        value: v.value,\n        mode: v.mode\n      };\n    })), f[e] = y;\n  }\n  function u(f) {\n    var y = l(f);\n    return y.forEach(function (v) {\n      v.id = v.id || t.uid();\n    }), y;\n  }\n  function h(f, y) {\n    var v = function (b, _) {\n      var m = {\n        inBoth: [],\n        inTaskNotInStore: [],\n        inStoreNotInTask: []\n      };\n      if (i == n.singleValue) {\n        var p = b[0],\n          k = p ? p.resource_id : null,\n          x = !1;\n        _.forEach(function (T) {\n          T.resource_id != k ? m.inStoreNotInTask.push(T) : T.resource_id == k && (m.inBoth.push({\n            store: T,\n            task: p\n          }), x = !0);\n        }), !x && p && m.inTaskNotInStore.push(p);\n      } else if (i == n.valueArray) {\n        var $ = {},\n          w = {},\n          S = {};\n        b.forEach(function (T) {\n          $[T.resource_id] = T;\n        }), _.forEach(function (T) {\n          w[T.resource_id] = T;\n        }), b.concat(_).forEach(function (T) {\n          if (!S[T.resource_id]) {\n            S[T.resource_id] = !0;\n            var E = $[T.resource_id],\n              C = w[T.resource_id];\n            E && C ? m.inBoth.push({\n              store: C,\n              task: E\n            }) : E && !C ? m.inTaskNotInStore.push(E) : !E && C && m.inStoreNotInTask.push(C);\n          }\n        });\n      } else i != n.assignmentsArray && i != n.resourceValueArray || ($ = {}, w = {}, S = {}, b.forEach(function (T) {\n        $[T.id || T.$id] = T;\n      }), _.forEach(function (T) {\n        w[T.id] = T;\n      }), b.concat(_).forEach(function (T) {\n        var E = T.id || T.$id;\n        if (!S[E]) {\n          S[E] = !0;\n          var C = $[E],\n            D = w[E];\n          C && D ? m.inBoth.push({\n            store: D,\n            task: C\n          }) : C && !D ? m.inTaskNotInStore.push(C) : !C && D && m.inStoreNotInTask.push(D);\n        }\n      }));\n      return m;\n    }(l(f), y);\n    v.inStoreNotInTask.forEach(function (b) {\n      s.removeItem(b.id);\n    }), v.inTaskNotInStore.forEach(function (b) {\n      s.addItem(b);\n    }), v.inBoth.forEach(function (b) {\n      if (function (m, p) {\n        var k = {\n          id: !0\n        };\n        for (var x in m) if (!k[x] && String(m[x]) !== String(p[x])) return !0;\n        return !1;\n      }(b.task, b.store)) (function (m, p) {\n        var k = {\n          id: !0\n        };\n        for (var x in m) k[x] || (p[x] = m[x]);\n      })(b.task, b.store), s.updateItem(b.store.id);else if (b.task.start_date && b.task.end_date && b.task.mode !== a.fixedDates) {\n        var _ = o(b.store, f);\n        b.store.start_date.valueOf() == _.start_date.valueOf() && b.store.end_date.valueOf() == _.end_date.valueOf() || (b.store.start_date = _.start_date, b.store.end_date = _.end_date, b.store.duration = _.duration, s.updateItem(b.store.id));\n      }\n    }), d(f.id);\n  }\n  function g(f) {\n    var y = f[e] || s.find(function (v) {\n      return v.task_id == f.id;\n    });\n    h(f, y);\n  }\n  t.$data.assignmentsStore = s, t.attachEvent(\"onGanttReady\", function () {\n    if (t.config.process_resource_assignments) {\n      t.attachEvent(\"onParse\", function () {\n        t.silent(function () {\n          s.clearAll();\n          var k = [];\n          t.eachTask(function (x) {\n            if (x.type !== t.config.types.project) {\n              var $ = u(x);\n              c(x, $), $.forEach(function (w) {\n                k.push(w);\n              });\n            }\n          }), s.parse(k);\n        });\n      });\n      var f = !1,\n        y = !1,\n        v = {},\n        b = !1;\n      t.attachEvent(\"onBeforeBatchUpdate\", function () {\n        f = !0;\n      }), t.attachEvent(\"onAfterBatchUpdate\", function () {\n        if (y) {\n          var k = {};\n          for (var x in v) k[x] = t.getTaskAssignments(v[x].id);\n          for (var x in t.config.process_resource_assignments && i === \"resourceValueArray\" && (p = null), v) h(v[x], k[x]);\n        }\n        y = !1, f = !1, v = {};\n      }), t.attachEvent(\"onTaskCreated\", function (k) {\n        var x = u(k);\n        return s.parse(x), c(k, x), !0;\n      }), t.attachEvent(\"onAfterTaskUpdate\", function (k, x) {\n        f ? (y = !0, v[k] = x) : x.unscheduled || g(x);\n      }), t.attachEvent(\"onAfterTaskAdd\", function (k, x) {\n        f ? (y = !0, v[k] = x) : g(x);\n      }), t.attachEvent(\"onRowDragEnd\", function (k) {\n        g(t.getTask(k));\n      }), t.$data.tasksStore.attachEvent(\"onAfterDeleteConfirmed\", function (k, x) {\n        var $,\n          w = [k];\n        t.eachTask(function (S) {\n          w.push(S.id);\n        }, k), $ = {}, w.forEach(function (S) {\n          $[S] = !0;\n        }), s.find(function (S) {\n          return $[S.task_id];\n        }).forEach(function (S) {\n          s.removeItem(S.id);\n        });\n      }), t.$data.tasksStore.attachEvent(\"onClearAll\", function () {\n        return _ = null, m = null, p = null, s.clearAll(), !0;\n      }), t.attachEvent(\"onTaskIdChange\", function (k, x) {\n        s.find(function ($) {\n          return $.task_id == k;\n        }).forEach(function ($) {\n          $.task_id = x, s.updateItem($.id);\n        }), d(x);\n      }), t.attachEvent(\"onBeforeUndo\", function (k) {\n        return b = !0, !0;\n      }), t.attachEvent(\"onAfterUndo\", function (k) {\n        b = !0;\n      });\n      var _ = null,\n        m = null,\n        p = null;\n      s.attachEvent(\"onStoreUpdated\", function () {\n        return f && !b || (_ = null, m = null, p = null), !0;\n      }), t.getResourceAssignments = function (k, x) {\n        var $ = t.defined(x) && x !== null;\n        return _ === null && (_ = {}, m = {}, s.eachItem(function (w) {\n          _[w.resource_id] || (_[w.resource_id] = []), _[w.resource_id].push(w);\n          var S = w.resource_id + \"-\" + w.task_id;\n          m[S] || (m[S] = []), m[S].push(w);\n        })), $ ? (m[k + \"-\" + x] || []).slice() : (_[k] || []).slice();\n      }, t.getTaskAssignments = function (k) {\n        if (p === null) {\n          var x = [];\n          p = {}, s.eachItem(function ($) {\n            p[$.task_id] || (p[$.task_id] = []), p[$.task_id].push($), $.task_id == k && x.push($);\n          });\n        }\n        return (p[k] || []).slice();\n      }, t.getTaskResources = function (k) {\n        const x = t.getDatastore(\"resource\"),\n          $ = t.getTaskAssignments(k),\n          w = {};\n        $.forEach(function (T) {\n          w[T.resource_id] || (w[T.resource_id] = T.resource_id);\n        });\n        const S = [];\n        for (const T in w) {\n          const E = x.getItem(w[T]);\n          E && S.push(E);\n        }\n        return S;\n      }, t.updateTaskAssignments = d;\n    }\n  }, {\n    once: !0\n  });\n}\nfunction hi(t) {\n  function e(o) {\n    return function () {\n      return !t.config.placeholder_task || o.apply(this, arguments);\n    };\n  }\n  function n() {\n    var o = t.getTaskBy(\"type\", t.config.types.placeholder);\n    if (!o.length || !t.isTaskExists(o[0].id)) {\n      var l = {\n        unscheduled: !0,\n        type: t.config.types.placeholder,\n        duration: 0,\n        text: t.locale.labels.new_task\n      };\n      if (t.callEvent(\"onTaskCreated\", [l]) === !1) return;\n      t.addTask(l);\n    }\n  }\n  function i(o) {\n    var l = t.getTask(o);\n    l.type == t.config.types.placeholder && (l.start_date && l.end_date && l.unscheduled && (l.unscheduled = !1), t.batchUpdate(function () {\n      var d = t.copy(l);\n      t.silent(function () {\n        t.deleteTask(l.id);\n      }), delete d[\"!nativeeditor_status\"], d.type = t.config.types.task, d.id = t.uid(), t.addTask(d);\n    }));\n  }\n  t.config.types.placeholder = \"placeholder\", t.attachEvent(\"onDataProcessorReady\", e(function (o) {\n    o && !o._silencedPlaceholder && (o._silencedPlaceholder = !0, o.attachEvent(\"onBeforeUpdate\", e(function (l, d, c) {\n      return c.type != t.config.types.placeholder || (o.setUpdated(l, !1), !1);\n    })));\n  }));\n  var a = !1;\n  function r(o) {\n    return !!(t.config.types.placeholder && t.isTaskExists(o) && t.getTask(o).type == t.config.types.placeholder);\n  }\n  function s(o) {\n    return !(!r(o.source) && !r(o.target));\n  }\n  t.attachEvent(\"onGanttReady\", function () {\n    a || (a = !0, t.attachEvent(\"onAfterTaskUpdate\", e(i)), t.attachEvent(\"onAfterTaskAdd\", e(function (o, l) {\n      l.type != t.config.types.placeholder && (t.getTaskBy(\"type\", t.config.types.placeholder).forEach(function (d) {\n        t.silent(function () {\n          t.isTaskExists(d.id) && t.deleteTask(d.id);\n        });\n      }), n());\n    })), t.attachEvent(\"onParse\", e(n)));\n  }), t.attachEvent(\"onLinkValidation\", function (o) {\n    return !s(o);\n  }), t.attachEvent(\"onBeforeLinkAdd\", function (o, l) {\n    return !s(l);\n  }), t.attachEvent(\"onBeforeUndoStack\", function (o) {\n    for (var l = 0; l < o.commands.length; l++) {\n      var d = o.commands[l];\n      d.entity === \"task\" && d.value.type === t.config.types.placeholder && (o.commands.splice(l, 1), l--);\n    }\n    return !0;\n  });\n}\nfunction _i(t) {\n  function e(c) {\n    return function () {\n      return !t.config.auto_types || t.getTaskType(t.config.types.project) != t.config.types.project || c.apply(this, arguments);\n    };\n  }\n  function n(c, u) {\n    var h = t.getTask(c),\n      g = r(h);\n    g !== !1 && t.getTaskType(h) !== g && (u.$needsUpdate = !0, u[h.id] = {\n      task: h,\n      type: g\n    });\n  }\n  function i(c) {\n    if (!t.getState().group_mode) {\n      var u = function (h, g) {\n        return n(h, g = g || {}), t.eachParent(function (f) {\n          n(f.id, g);\n        }, h), g;\n      }(c);\n      u.$needsUpdate && t.batchUpdate(function () {\n        (function (h) {\n          for (var g in h) if (h[g] && h[g].task) {\n            var f = h[g].task;\n            f.type = h[g].type, t.updateTask(f.id);\n          }\n        })(u);\n      });\n    }\n  }\n  var a;\n  function r(c) {\n    var u = t.config.types,\n      h = t.hasChild(c.id),\n      g = t.getTaskType(c.type);\n    return h && g === u.task ? u.project : !h && g === u.project && u.task;\n  }\n  var s,\n    o,\n    l = !0;\n  function d(c) {\n    c != t.config.root_id && t.isTaskExists(c) && i(c);\n  }\n  t.attachEvent(\"onParse\", e(function () {\n    l = !1, t.getState().group_mode || (t.batchUpdate(function () {\n      t.eachTask(function (c) {\n        var u = r(c);\n        u !== !1 && function (h, g) {\n          t.getState().group_mode || (h.type = g, t.updateTask(h.id));\n        }(c, u);\n      });\n    }), l = !0);\n  })), t.attachEvent(\"onAfterTaskAdd\", e(function (c) {\n    l && i(c);\n  })), t.attachEvent(\"onAfterTaskUpdate\", e(function (c) {\n    l && i(c);\n  })), t.attachEvent(\"onBeforeTaskDelete\", e(function (c, u) {\n    return a = t.getParent(c), !0;\n  })), t.attachEvent(\"onAfterTaskDelete\", e(function (c, u) {\n    d(a);\n  })), t.attachEvent(\"onRowDragStart\", e(function (c, u, h) {\n    return s = t.getParent(c), !0;\n  })), t.attachEvent(\"onRowDragEnd\", e(function (c, u) {\n    d(s), i(c);\n  })), t.attachEvent(\"onBeforeTaskMove\", e(function (c, u, h) {\n    return o = t.getParent(c), !0;\n  })), t.attachEvent(\"onAfterTaskMove\", e(function (c, u, h) {\n    document.querySelector(\".gantt_drag_marker\") || (d(o), i(c));\n  }));\n}\nconst Zt = class Zt {\n  constructor() {\n    this.canParse = e => !isNaN(this.parse(e)), this.format = e => String(e), this.parse = e => parseInt(e, 10);\n  }\n};\nZt.create = (e = null) => new Zt();\nlet Pt = Zt;\nconst Qt = class Qt {\n  constructor(e) {\n    this.format = n => this._getWBSCode(n.source), this.canParse = n => this._linkReg.test(n), this.parse = n => {\n      if (!this.canParse(n)) return null;\n      const i = this._linkReg.exec(n)[0].trim();\n      return {\n        id: void 0,\n        source: this._findSource(i) || null,\n        target: null,\n        type: this._gantt.config.links.finish_to_start,\n        lag: 0\n      };\n    }, this._getWBSCode = n => {\n      const i = this._gantt.getTask(n);\n      return this._gantt.getWBSCode(i);\n    }, this._findSource = n => {\n      const i = new RegExp(\"^[0-9.]+\", \"i\");\n      if (i.exec(n)) {\n        const a = i.exec(n)[0],\n          r = this._gantt.getTaskByWBSCode(a);\n        if (r) return r.id;\n      }\n      return null;\n    }, this._linkReg = /^[0-9\\.]+/, this._gantt = e;\n  }\n};\nQt.create = (e = null, n) => new Qt(n);\nlet ke = Qt;\nfunction gi(t) {\n  t.ext.formatters = {\n    durationFormatter: function (e) {\n      return e || (e = {}), e.store || (e.store = t.config.duration_unit), e.enter || (e.enter = t.config.duration_unit), Pt.create(e, t);\n    },\n    linkFormatter: function (e) {\n      return ke.create(e, t);\n    }\n  };\n}\nfunction fi(t) {\n  t.ext = t.ext || {}, t.config.show_empty_state = !1, t.ext.emptyStateElement = t.ext.emptyStateElement || {\n    isEnabled: () => t.config.show_empty_state === !0,\n    isGanttEmpty: () => !t.getTaskByTime().length,\n    renderContent(e) {\n      const n = `<div class='gantt_empty_state'><div class='gantt_empty_state_image'></div>${`<div class='gantt_empty_state_text'>\n    <div class='gantt_empty_state_text_link' data-empty-state-create-task>${t.locale.labels.empty_state_text_link}</div>\n    <div class='gantt_empty_state_text_description'>${t.locale.labels.empty_state_text_description}</div>\n    </div>`}</div>`;\n      e.innerHTML = n;\n    },\n    clickEvents: [],\n    attachAddTaskEvent() {\n      const e = t.attachEvent(\"onEmptyClick\", function (n) {\n        t.utils.dom.closest(n.target, \"[data-empty-state-create-task]\") && t.createTask({\n          id: t.uid(),\n          text: \"New Task\"\n        });\n      });\n      this.clickEvents.push(e);\n    },\n    detachAddTaskEvents() {\n      this.clickEvents.forEach(function (e) {\n        t.detachEvent(e);\n      }), this.clickEvents = [];\n    },\n    getContainer() {\n      if (t.$container) {\n        const e = t.utils.dom;\n        if (t.$container.contains(t.$grid_data)) return e.closest(t.$grid_data, \".gantt_layout_content\");\n        if (t.$container.contains(t.$task_data)) return e.closest(t.$task_data, \".gantt_layout_content\");\n      }\n      return null;\n    },\n    getNode() {\n      const e = this.getContainer();\n      return e ? e.querySelector(\".gantt_empty_state_wrapper\") : null;\n    },\n    show() {\n      const e = this.getContainer();\n      if (!e && this.isGanttEmpty()) return null;\n      const n = document.createElement(\"div\");\n      n.className = \"gantt_empty_state_wrapper\", n.style.marginTop = t.config.scale_height - e.offsetHeight + \"px\";\n      const i = t.$container.querySelectorAll(\".gantt_empty_state_wrapper\");\n      Array.prototype.forEach.call(i, function (a) {\n        a.parentNode.removeChild(a);\n      }), this.detachAddTaskEvents(), this.attachAddTaskEvent(), e.appendChild(n), this.renderContent(n);\n    },\n    hide() {\n      const e = this.getNode();\n      if (!e) return !1;\n      e.parentNode.removeChild(e);\n    },\n    init() {}\n  }, t.attachEvent(\"onDataRender\", function () {\n    const e = t.ext.emptyStateElement;\n    e.isEnabled() && e.isGanttEmpty() ? e.show() : e.hide();\n  });\n}\nconst _n = function (t, e) {\n    const n = e.baselines && e.baselines.length,\n      i = t.config.baselines.render_mode == \"separateRow\" || t.config.baselines.render_mode == \"individualRow\";\n    if (n && i) return !0;\n  },\n  pi = function (t, e) {\n    let n = !1;\n    return t.eachTask(function (i) {\n      n || (n = _n(t, i));\n    }, e), n;\n  },\n  $t = function (t) {\n    return t.render && t.render == \"split\" && !t.$open;\n  },\n  mi = function (t, e, n, i) {\n    let a = i || e.$task_data.scrollHeight,\n      r = !1,\n      s = !1;\n    return t.eachParent(function (o) {\n      if ($t(o)) {\n        s = !0;\n        const l = e.getItemPosition(o).rowHeight;\n        l < a && (a = l, r = !0);\n      }\n    }, n.id), {\n      maxHeight: a,\n      shrinkHeight: r,\n      splitChild: s\n    };\n  };\nfunction vi(t) {\n  t.config.baselines = {\n    datastore: \"baselines\",\n    render_mode: !1,\n    dataprocessor_baselines: !1,\n    row_height: 16,\n    bar_height: 8\n  };\n  const e = t.createDatastore({\n    name: t.config.baselines.datastore,\n    initItem: function (a) {\n      return a.id || (a.id = t.uid()), function (r) {\n        if (!r.task_id || !r.start_date && !r.end_date) return !1;\n        r.start_date ? r.start_date = t.date.parseDate(r.start_date, \"parse_date\") : r.start_date = null, r.end_date ? r.end_date = t.date.parseDate(r.end_date, \"parse_date\") : r.end_date = null, r.duration = r.duration || 1, r.start_date && !r.end_date ? r.end_date = t.calculateEndDate(r.start_date, r.duration) : r.end_date && !r.start_date && (r.start_date = t.calculateEndDate(r.end_date, -r.duration));\n      }(a), a;\n    }\n  });\n  function n(a) {\n    let r = 0;\n    t.adjustTaskHeightForBaselines(a), t.eachTask(function (s) {\n      let o = s.row_height || t.config.row_height;\n      r = r || o, o > r && (r = o);\n    }, a.id), a.row_height < r && (a.row_height = r);\n  }\n  function i(a) {\n    t.eachParent(function (r) {\n      if ($t(r)) {\n        const s = r.row_height || t.getLayoutView(\"timeline\").getBarHeight(r.id);\n        let o = a.row_height;\n        t.getChildren(r.id).forEach(function (l) {\n          const d = t.getTask(l);\n          if (d.id == a.id) return;\n          const c = d.row_height || t.getLayoutView(\"timeline\").getBarHeight(d.id);\n          o = o || c, c > o && (o = c);\n        }), r.row_height = o, r.bar_height = r.bar_height || s;\n      }\n    }, a.id);\n  }\n  t.$data.baselineStore = e, t.adjustTaskHeightForBaselines = function (a) {\n    let r,\n      s,\n      o = a.baselines && a.baselines.length || 0;\n    const l = t.config.baselines.row_height,\n      d = t.getLayoutView(\"timeline\");\n    if (d && t.config.show_chart) switch (t.config.baselines.render_mode) {\n      case \"taskRow\":\n        a.row_height = a.bar_height + 4;\n        break;\n      case \"separateRow\":\n        r = d.getBarHeight(a.id), o ? (a.bar_height = a.bar_height || r, a.bar_height > r && (r = a.bar_height), a.row_height = r + l) : a.bar_height && (a.row_height = a.bar_height + 4), i(a);\n        break;\n      case \"individualRow\":\n        r = d.getBarHeight(a.id), o ? (a.bar_height = a.bar_height || r, a.bar_height > r && (r = a.bar_height), s = l * o, a.row_height = r + s + 2) : a.bar_height && (a.row_height = a.bar_height + 4), i(a);\n    }\n  }, t.attachEvent(\"onGanttReady\", function () {\n    t.config.baselines && (t.attachEvent(\"onParse\", function () {\n      e.eachItem(function (a) {\n        const r = a.task_id;\n        if (t.isTaskExists(r)) {\n          const s = t.getTask(r);\n          s.baselines = s.baselines || [];\n          let o = !0;\n          for (let l = 0; l < s.baselines.length; l++) {\n            let d = s.baselines[l];\n            if (d.id == a.id) {\n              o = !1, t.mixin(d, a, !0);\n              break;\n            }\n          }\n          o && s.baselines.push(a), V(t) || ($t(s) ? n(s) : t.adjustTaskHeightForBaselines(s));\n        }\n      });\n    }), t.attachEvent(\"onBeforeTaskUpdate\", function (a, r) {\n      return function (s) {\n        let o = !1;\n        const l = {},\n          d = s.baselines || [],\n          c = t.getTaskBaselines(s.id);\n        d.length != c.length && (o = !0), d.forEach(function (u) {\n          l[u.id] = !0;\n          const h = e.getItem(u.id);\n          if (h) {\n            const g = +h.start_date != +u.start_date,\n              f = +h.end_date != +u.end_date;\n            (g || f) && e.updateItem(u.id, u);\n          } else e.addItem(u);\n        }), c.forEach(function (u) {\n          l[u.id] || e.removeItem(u.id);\n        }), o && ($t(s) ? n(s) : t.adjustTaskHeightForBaselines(s), t.render());\n      }(r), !0;\n    }), t.attachEvent(\"onAfterUndo\", function (a) {\n      if ((t.config.baselines.render_mode == \"separateRow\" || t.config.baselines.render_mode == \"individualRow\") && a) {\n        let r = !1;\n        a.commands.forEach(function (s) {\n          if (s.entity == \"task\") {\n            const o = s.value.id;\n            if (t.isTaskExists(o)) {\n              const l = t.getTask(o);\n              if (l.parent && t.isTaskExists(l.parent)) {\n                const d = t.getTask(l.parent);\n                $t(d) && (n(d), r = !0);\n              }\n            }\n          }\n        }), r && t.render();\n      }\n    }), t.attachEvent(\"onAfterTaskDelete\", function (a, r) {\n      if (_n && r.parent && t.isTaskExists(r.parent)) {\n        const s = t.getTask(r.parent);\n        $t(s) && n(s);\n      }\n      e.eachItem(function (s) {\n        t.isTaskExists(s.task_id) || e.removeItem(s.id);\n      });\n    }), t.getTaskBaselines = function (a) {\n      const r = [];\n      return e.eachItem(function (s) {\n        s.task_id == a && r.push(s);\n      }), r;\n    }, t.$data.baselineStore.attachEvent(\"onClearAll\", function () {\n      return t.eachTask(function (a) {\n        a.baselines && delete a.baselines;\n      }), !0;\n    }), t.$data.tasksStore.attachEvent(\"onClearAll\", function () {\n      return e.clearAll(), !0;\n    }), t.attachEvent(\"onTaskIdChange\", function (a, r) {\n      e.find(function (s) {\n        return s.task_id == a;\n      }).forEach(function (s) {\n        s.task_id = r, e.updateItem(s.id);\n      });\n    }));\n  }, {\n    once: !0\n  });\n}\nfunction ki(t) {\n  function e(n) {\n    throw t.assert(!1, \"Can't parse data: incorrect value of gantt.parse or gantt.load method. Actual argument value: \" + JSON.stringify(n)), new Error(\"Invalid argument for gantt.parse or gantt.load. An object or a JSON string of format https://docs.dhtmlx.com/gantt/desktop__supported_data_formats.html#json is expected. Actual argument value: \" + JSON.stringify(n));\n  }\n  t.load = function () {\n    throw new Error(\"gantt.load() method is not available in the node.js, use gantt.parse() instead\");\n  }, t.parse = function (n, i) {\n    this.on_load({\n      xmlDoc: {\n        responseText: n\n      }\n    }, i);\n  }, t.serialize = function (n) {\n    return this[n = n || \"json\"].serialize();\n  }, t.on_load = function (n, i) {\n    if (n.xmlDoc && n.xmlDoc.status === 404) this.assert(!1, \"Failed to load the data from <a href='\" + n.xmlDoc.responseURL + \"' target='_blank'>\" + n.xmlDoc.responseURL + \"</a>, server returns 404\");else if (!t.$destroyed) {\n      this.callEvent(\"onBeforeParse\", []), i || (i = \"json\"), this.assert(this[i], \"Invalid data type:'\" + i + \"'\");\n      var a = n.xmlDoc.responseText,\n        r = this[i].parse(a, n);\n      this._process_loading(r);\n    }\n  }, t._process_loading = function (n) {\n    n.collections && this._load_collections(n.collections), n.resources && this.$data.resourcesStore && this.$data.resourcesStore.parse(n.resources), t.config.baselines && n.baselines && this.$data.baselineStore && this.$data.baselineStore.parse(n.baselines);\n    const i = n.data || n.tasks;\n    n.assignments && function (r, s) {\n      const o = {};\n      s.forEach(l => {\n        o[l.task_id] || (o[l.task_id] = []), o[l.task_id].push(l);\n      }), r.forEach(l => {\n        l[t.config.resource_property] = o[l.id] || [];\n      });\n    }(i, n.assignments), this.$data.tasksStore.parse(i);\n    var a = n.links || (n.collections && n.collections.links ? n.collections.links : []);\n    this.$data.linksStore.parse(a), this.callEvent(\"onParse\", []), this.render();\n  }, t._load_collections = function (n) {\n    var i = !1;\n    for (var a in n) if (n.hasOwnProperty(a)) {\n      i = !0;\n      var r = n[a];\n      this.serverList[a] = this.serverList[a] || [];\n      var s = this.serverList[a];\n      if (!s) continue;\n      s.splice(0, s.length);\n      for (var o = 0; o < r.length; o++) {\n        var l = r[o],\n          d = this.copy(l);\n        for (var c in d.key = d.value, l) if (l.hasOwnProperty(c)) {\n          if (c == \"value\" || c == \"label\") continue;\n          d[c] = l[c];\n        }\n        s.push(d);\n      }\n    }\n    i && this.callEvent(\"onOptionsLoad\", []);\n  }, t.attachEvent(\"onBeforeTaskDisplay\", function (n, i) {\n    return !i.$ignore;\n  }), t.json = {\n    parse: function (n) {\n      if (n || e(n), typeof n == \"string\") if (typeof JSON != null) try {\n        n = JSON.parse(n);\n      } catch {\n        e(n);\n      } else t.assert(!1, \"JSON is not supported\");\n      return n.data || n.tasks || e(n), n.dhx_security && (t.security_key = n.dhx_security), n;\n    },\n    serializeTask: function (n) {\n      return this._copyObject(n);\n    },\n    serializeLink: function (n) {\n      return this._copyLink(n);\n    },\n    _copyLink: function (n) {\n      var i = {};\n      for (var a in n) i[a] = n[a];\n      return i;\n    },\n    _copyObject: function (n) {\n      var i = {};\n      for (var a in n) a.charAt(0) != \"$\" && (i[a] = n[a], Z(i[a]) && (i[a] = t.defined(t.templates.xml_format) ? t.templates.xml_format(i[a]) : t.templates.format_date(i[a])));\n      return i;\n    },\n    serialize: function () {\n      var n = [],\n        i = [];\n      let a = [];\n      t.eachTask(function (o) {\n        t.resetProjectDates(o), n.push(this.serializeTask(o));\n      }, t.config.root_id, this);\n      for (var r = t.getLinks(), s = 0; s < r.length; s++) i.push(this.serializeLink(r[s]));\n      return t.getDatastore(\"baselines\").eachItem(function (o) {\n        const l = t.json.serializeTask(o);\n        a.push(l);\n      }), {\n        data: n,\n        links: i,\n        baselines: a\n      };\n    }\n  }, t.xml = {\n    _xmlNodeToJSON: function (n, i) {\n      for (var a = {}, r = 0; r < n.attributes.length; r++) a[n.attributes[r].name] = n.attributes[r].value;\n      if (!i) {\n        for (r = 0; r < n.childNodes.length; r++) {\n          var s = n.childNodes[r];\n          s.nodeType == 1 && (a[s.tagName] = s.firstChild ? s.firstChild.nodeValue : \"\");\n        }\n        a.text || (a.text = n.firstChild ? n.firstChild.nodeValue : \"\");\n      }\n      return a;\n    },\n    _getCollections: function (n) {\n      for (var i = {}, a = t.ajax.xpath(\"//coll_options\", n), r = 0; r < a.length; r++) for (var s = i[a[r].getAttribute(\"for\")] = [], o = t.ajax.xpath(\".//item\", a[r]), l = 0; l < o.length; l++) {\n        for (var d = o[l].attributes, c = {\n            key: o[l].getAttribute(\"value\"),\n            label: o[l].getAttribute(\"label\")\n          }, u = 0; u < d.length; u++) {\n          var h = d[u];\n          h.nodeName != \"value\" && h.nodeName != \"label\" && (c[h.nodeName] = h.nodeValue);\n        }\n        s.push(c);\n      }\n      return i;\n    },\n    _getXML: function (n, i, a) {\n      a = a || \"data\", i.getXMLTopNode || (i = t.ajax.parse(i));\n      var r = t.ajax.xmltop(a, i.xmlDoc);\n      r && r.tagName == a || function (o) {\n        throw t.assert(!1, \"Can't parse data: incorrect value of gantt.parse or gantt.load method. Actual argument value: \" + JSON.stringify(o)), new Error(\"Invalid argument for gantt.parse or gantt.load. An XML of format https://docs.dhtmlx.com/gantt/desktop__supported_data_formats.html#xmldhtmlxgantt20 is expected. Actual argument value: \" + JSON.stringify(o));\n      }(n);\n      var s = r.getAttribute(\"dhx_security\");\n      return s && (t.security_key = s), r;\n    },\n    parse: function (n, i) {\n      i = this._getXML(n, i);\n      for (var a = {}, r = a.data = [], s = t.ajax.xpath(\"//task\", i), o = 0; o < s.length; o++) r[o] = this._xmlNodeToJSON(s[o]);\n      return a.collections = this._getCollections(i), a;\n    },\n    _copyLink: function (n) {\n      return \"<item id='\" + n.id + \"' source='\" + n.source + \"' target='\" + n.target + \"' type='\" + n.type + \"' />\";\n    },\n    _copyObject: function (n) {\n      return \"<task id='\" + n.id + \"' parent='\" + (n.parent || \"\") + \"' start_date='\" + n.start_date + \"' duration='\" + n.duration + \"' open='\" + !!n.open + \"' progress='\" + n.progress + \"' end_date='\" + n.end_date + \"'><![CDATA[\" + n.text + \"]]></task>\";\n    },\n    serialize: function () {\n      for (var n = [], i = [], a = t.json.serialize(), r = 0, s = a.data.length; r < s; r++) n.push(this._copyObject(a.data[r]));\n      for (r = 0, s = a.links.length; r < s; r++) i.push(this._copyLink(a.links[r]));\n      return \"<data>\" + n.join(\"\") + \"<coll_options for='links'>\" + i.join(\"\") + \"</coll_options></data>\";\n    }\n  }, t.oldxml = {\n    parse: function (n, i) {\n      i = t.xml._getXML(n, i, \"projects\");\n      for (var a = {\n          collections: {\n            links: []\n          }\n        }, r = a.data = [], s = t.ajax.xpath(\"//task\", i), o = 0; o < s.length; o++) {\n        r[o] = t.xml._xmlNodeToJSON(s[o]);\n        var l = s[o].parentNode;\n        l.tagName == \"project\" ? r[o].parent = \"project-\" + l.getAttribute(\"id\") : r[o].parent = l.parentNode.getAttribute(\"id\");\n      }\n      for (s = t.ajax.xpath(\"//project\", i), o = 0; o < s.length; o++) (d = t.xml._xmlNodeToJSON(s[o], !0)).id = \"project-\" + d.id, r.push(d);\n      for (o = 0; o < r.length; o++) {\n        var d;\n        (d = r[o]).start_date = d.startdate || d.est, d.end_date = d.enddate, d.text = d.name, d.duration = d.duration / 8, d.open = 1, d.duration || d.end_date || (d.duration = 1), d.predecessortasks && a.collections.links.push({\n          target: d.id,\n          source: d.predecessortasks,\n          type: t.config.links.finish_to_start\n        });\n      }\n      return a;\n    },\n    serialize: function () {\n      t.message(\"Serialization to 'old XML' is not implemented\");\n    }\n  }, t.serverList = function (n, i) {\n    return i ? this.serverList[n] = i.slice(0) : this.serverList[n] || (this.serverList[n] = []), this.serverList[n];\n  };\n}\nfunction ae(t, e, n, i, a) {\n  return this.date = t, this.unit = e, this.task = n, this.id = i, this.calendar = a, this;\n}\nfunction re(t, e, n, i, a, r) {\n  return this.date = t, this.dir = e, this.unit = n, this.task = i, this.id = a, this.calendar = r, this;\n}\nfunction se(t, e, n, i, a, r, s) {\n  return this.start_date = t, this.duration = e, this.unit = n, this.step = i, this.task = a, this.id = r, this.calendar = s, this;\n}\nfunction yi(t, e, n, i) {\n  return this.start_date = t, this.end_date = e, this.task = n, this.calendar = i, this.unit = null, this.step = null, this;\n}\nvar gn = function (t) {\n  return {\n    getWorkHoursArguments: function () {\n      var e = arguments[0];\n      if (!bt((e = Z(e) ? {\n        date: e\n      } : L({}, e)).date)) throw t.assert(!1, \"Invalid date argument for getWorkHours method\"), new Error(\"Invalid date argument for getWorkHours method\");\n      return e;\n    },\n    setWorkTimeArguments: function () {\n      return arguments[0];\n    },\n    unsetWorkTimeArguments: function () {\n      return arguments[0];\n    },\n    isWorkTimeArguments: function () {\n      var e,\n        n = arguments[0];\n      if (n instanceof ae) return n;\n      if ((e = n.date ? new ae(n.date, n.unit, n.task, null, n.calendar) : new ae(arguments[0], arguments[1], arguments[2], null, arguments[3])).unit = e.unit || t.config.duration_unit, !bt(e.date)) throw t.assert(!1, \"Invalid date argument for isWorkTime method\"), new Error(\"Invalid date argument for isWorkTime method\");\n      return e;\n    },\n    getClosestWorkTimeArguments: function (e) {\n      var n,\n        i = arguments[0];\n      if (i instanceof re) return i;\n      if (n = Z(i) ? new re(i) : new re(i.date, i.dir, i.unit, i.task, null, i.calendar), i.id && (n.task = i), n.dir = i.dir || \"any\", n.unit = i.unit || t.config.duration_unit, !bt(n.date)) throw t.assert(!1, \"Invalid date argument for getClosestWorkTime method\"), new Error(\"Invalid date argument for getClosestWorkTime method\");\n      return n;\n    },\n    _getStartEndConfig: function (e) {\n      var n,\n        i = yi;\n      if (e instanceof i) return e;\n      if (Z(e) ? n = new i(arguments[0], arguments[1], arguments[2], arguments[3]) : (n = new i(e.start_date, e.end_date, e.task), e.id !== null && e.id !== void 0 && (n.task = e)), n.unit = n.unit || t.config.duration_unit, n.step = n.step || t.config.duration_step, n.start_date = n.start_date || n.start || n.date, !bt(n.start_date)) throw t.assert(!1, \"Invalid start_date argument for getDuration method\"), new Error(\"Invalid start_date argument for getDuration method\");\n      if (!bt(n.end_date)) throw t.assert(!1, \"Invalid end_date argument for getDuration method\"), new Error(\"Invalid end_date argument for getDuration method\");\n      return n;\n    },\n    getDurationArguments: function (e, n, i, a) {\n      return this._getStartEndConfig.apply(this, arguments);\n    },\n    hasDurationArguments: function (e, n, i, a) {\n      return this._getStartEndConfig.apply(this, arguments);\n    },\n    calculateEndDateArguments: function (e, n, i, a) {\n      var r,\n        s = arguments[0];\n      if (s instanceof se) return s;\n      if (r = Z(s) ? new se(arguments[0], arguments[1], arguments[2], void 0, arguments[3], void 0, arguments[4]) : new se(s.start_date, s.duration, s.unit, s.step, s.task, null, s.calendar), s.id !== null && s.id !== void 0 && (r.task = s, r.unit = null, r.step = null), r.unit = r.unit || t.config.duration_unit, r.step = r.step || t.config.duration_step, !bt(r.start_date)) throw t.assert(!1, \"Invalid start_date argument for calculateEndDate method\"), new Error(\"Invalid start_date argument for calculateEndDate method\");\n      return r;\n    }\n  };\n};\nfunction fn() {}\nfn.prototype = {\n  _getIntervals: function (t) {\n    for (var e = [], n = 0; n < t.length; n += 2) e.push({\n      start: t[n],\n      end: t[n + 1]\n    });\n    return e;\n  },\n  _toHoursArray: function (t) {\n    var e = [];\n    function n(a) {\n      var r,\n        s = Math.floor(a / 3600),\n        o = a - 60 * s * 60,\n        l = Math.floor(o / 60);\n      return s + \":\" + ((r = String(l)).length < 2 && (r = \"0\" + r), r);\n    }\n    for (var i = 0; i < t.length; i++) e.push(n(t[i].start) + \"-\" + n(t[i].end));\n    return e;\n  },\n  _intersectHourRanges: function (t, e) {\n    var n = [],\n      i = t.length > e.length ? t : e,\n      a = t === i ? e : t;\n    i = i.slice(), a = a.slice(), n = [];\n    for (var r = 0; r < i.length; r++) for (var s = i[r], o = 0; o < a.length; o++) {\n      var l = a[o];\n      l.start < s.end && l.end > s.start && (n.push({\n        start: Math.max(s.start, l.start),\n        end: Math.min(s.end, l.end)\n      }), s.end > l.end && (a.splice(o, 1), o--, r--));\n    }\n    return n;\n  },\n  _mergeAdjacentIntervals: function (t) {\n    var e = t.slice();\n    e.sort(function (r, s) {\n      return r.start - s.start;\n    });\n    for (var n = e[0], i = 1; i < e.length; i++) {\n      var a = e[i];\n      a.start <= n.end ? (a.end > n.end && (n.end = a.end), e.splice(i, 1), i--) : n = a;\n    }\n    return e;\n  },\n  _mergeHoursConfig: function (t, e) {\n    return this._mergeAdjacentIntervals(this._intersectHourRanges(t, e));\n  },\n  merge: function (t, e) {\n    var n = G(t.getConfig().parsed),\n      i = G(e.getConfig().parsed),\n      a = {\n        hours: this._toHoursArray(this._mergeHoursConfig(n.hours, i.hours)),\n        dates: {},\n        customWeeks: {}\n      };\n    const r = (o, l) => {\n      for (let d in o.dates) {\n        const c = o.dates[d];\n        +d > 1e3 && (a.dates[d] = !1);\n        for (const u in l.dates) {\n          const h = l.dates[u];\n          if (u == d && (a.dates[d] = !(!c || !h)), Array.isArray(c)) {\n            const g = Array.isArray(h) ? h : l.hours;\n            a.dates[d] = this._toHoursArray(this._mergeHoursConfig(c, g));\n          }\n        }\n      }\n    };\n    if (r(n, i), r(i, n), n.customWeeks) for (var s in n.customWeeks) a.customWeeks[s] = n.customWeeks[s];\n    if (i.customWeeks) for (var s in i.customWeeks) a.customWeeks[s] = i.customWeeks[s];\n    return a;\n  }\n};\nclass bi {\n  constructor() {\n    this.clear();\n  }\n  getItem(e, n, i) {\n    if (this._cache.has(e)) {\n      const a = this._cache.get(e)[i.getFullYear()];\n      if (a && a.has(n)) return a.get(n);\n    }\n    return -1;\n  }\n  setItem(e, n, i, a) {\n    if (!e || !n) return;\n    const r = this._cache,\n      s = a.getFullYear();\n    let o;\n    r.has(e) ? o = r.get(e) : (o = [], r.set(e, o));\n    let l = o[s];\n    l || (l = o[s] = /* @__PURE__ */new Map()), l.set(n, i);\n  }\n  clear() {\n    this._cache = /* @__PURE__ */new Map();\n  }\n}\nclass xi {\n  constructor() {\n    this.clear();\n  }\n  getItem(e, n, i) {\n    const a = this._cache;\n    if (a && a[e]) {\n      const r = a[e];\n      if (r === void 0) return -1;\n      const s = r[i.getFullYear()];\n      if (s && s[n] !== void 0) return s[n];\n    }\n    return -1;\n  }\n  setItem(e, n, i, a) {\n    if (!e || !n) return;\n    const r = this._cache;\n    if (!r) return;\n    r[e] || (r[e] = []);\n    const s = r[e],\n      o = a.getFullYear();\n    let l = s[o];\n    l || (l = s[o] = {}), l[n] = i;\n  }\n  clear() {\n    this._cache = {};\n  }\n}\nclass $i {\n  constructor(e) {\n    this.getMinutesPerWeek = n => {\n      const i = n.valueOf();\n      if (this._weekCache.has(i)) return this._weekCache.get(i);\n      const a = this._calendar,\n        r = this._calendar.$gantt;\n      let s = 0,\n        o = r.date.week_start(new Date(n));\n      for (let l = 0; l < 7; l++) s += 60 * a.getHoursPerDay(o), o = r.date.add(o, 1, \"day\");\n      return this._weekCache.set(i, s), s;\n    }, this.getMinutesPerMonth = n => {\n      const i = n.valueOf();\n      if (this._monthCache.has(i)) return this._monthCache.get(i);\n      const a = this._calendar,\n        r = this._calendar.$gantt;\n      let s = 0,\n        o = r.date.week_start(new Date(n));\n      const l = r.date.add(o, 1, \"month\").valueOf();\n      for (; o.valueOf() < l;) s += 60 * a.getHoursPerDay(o), o = r.date.add(o, 1, \"day\");\n      return this._monthCache.set(i, s), s;\n    }, this.clear = () => {\n      this._weekCache = /* @__PURE__ */new Map(), this._monthCache = /* @__PURE__ */new Map();\n    }, this.clear(), this._calendar = e;\n  }\n}\nclass wi {\n  constructor() {\n    this.clear();\n  }\n  _getCacheObject(e, n, i) {\n    const a = this._cache;\n    a[n] || (a[n] = []);\n    let r = a[n];\n    r || (r = a[n] = {});\n    let s = r[i];\n    s || (s = r[i] = {});\n    const o = e.getFullYear();\n    let l = s[o];\n    return l || (l = s[o] = {\n      durations: {},\n      endDates: {}\n    }), l;\n  }\n  _endDateCacheKey(e, n) {\n    return String(e) + \"-\" + String(n);\n  }\n  _durationCacheKey(e, n) {\n    return String(e) + \"-\" + String(n);\n  }\n  getEndDate(e, n, i, a, r) {\n    const s = this._getCacheObject(e, i, a),\n      o = e.valueOf(),\n      l = this._endDateCacheKey(o, n);\n    let d;\n    if (s.endDates[l] === void 0) {\n      const c = r(),\n        u = c.valueOf();\n      s.endDates[l] = u, s.durations[this._durationCacheKey(o, u)] = n, d = c;\n    } else d = new Date(s.endDates[l]);\n    return d;\n  }\n  getDuration(e, n, i, a, r) {\n    const s = this._getCacheObject(e, i, a),\n      o = e.valueOf(),\n      l = n.valueOf(),\n      d = this._durationCacheKey(o, l);\n    let c;\n    if (s.durations[d] === void 0) {\n      const u = r();\n      s.durations[d] = u.valueOf(), c = u;\n    } else c = s.durations[d];\n    return c;\n  }\n  clear() {\n    this._cache = {};\n  }\n}\nfunction ye(t, e) {\n  this.argumentsHelper = e, this.$gantt = t, this._workingUnitsCache = typeof Map < \"u\" ? new bi() : new xi(), this._largeUnitsCache = new $i(this), this._dateDurationCache = new wi(), this._worktime = null, this._cached_timestamps = {}, this._cached_timestamps_count = 0;\n}\nye.prototype = {\n  units: [\"year\", \"month\", \"week\", \"day\", \"hour\", \"minute\"],\n  _clearCaches: function () {\n    this._workingUnitsCache.clear(), this._largeUnitsCache.clear(), this._dateDurationCache.clear();\n  },\n  _getUnitOrder: function (t) {\n    for (var e = 0, n = this.units.length; e < n; e++) if (this.units[e] == t) return e;\n  },\n  _resetTimestampCache: function () {\n    this._cached_timestamps = {}, this._cached_timestamps_count = 0;\n  },\n  _timestamp: function (t) {\n    this._cached_timestamps_count > 1e6 && this._resetTimestampCache();\n    var e = null;\n    if (t.day || t.day === 0) e = t.day;else if (t.date) {\n      var n = String(t.date.valueOf());\n      this._cached_timestamps[n] ? e = this._cached_timestamps[n] : (e = Date.UTC(t.date.getFullYear(), t.date.getMonth(), t.date.getDate()), this._cached_timestamps[n] = e, this._cached_timestamps_count++);\n    }\n    return e;\n  },\n  _checkIfWorkingUnit: function (t, e) {\n    if (!this[\"_is_work_\" + e]) {\n      const n = this.$gantt.date[`${e}_start`](new Date(t)),\n        i = this.$gantt.date.add(n, 1, e);\n      return this.hasDuration(n, i);\n    }\n    return this[\"_is_work_\" + e](t);\n  },\n  _is_work_day: function (t) {\n    var e = this._getWorkHours(t);\n    return !!Array.isArray(e) && e.length > 0;\n  },\n  _is_work_hour: function (t) {\n    for (var e = this._getWorkHours(t), n = t.getHours(), i = 0; i < e.length; i++) if (n >= e[i].startHour && n < e[i].endHour) return !0;\n    return !1;\n  },\n  _getTimeOfDayStamp: function (t, e) {\n    var n = t.getHours();\n    return t.getHours() || t.getMinutes() || !e || (n = 24), 60 * n * 60 + 60 * t.getMinutes();\n  },\n  _is_work_minute: function (t) {\n    for (var e = this._getWorkHours(t), n = this._getTimeOfDayStamp(t), i = 0; i < e.length; i++) if (n >= e[i].start && n < e[i].end) return !0;\n    return !1;\n  },\n  _nextDate: function (t, e, n) {\n    return this.$gantt.date.add(t, n, e);\n  },\n  _getWorkUnitsBetweenGeneric: function (t, e, n, i) {\n    var a = this.$gantt.date,\n      r = new Date(t),\n      s = new Date(e);\n    i = i || 1;\n    var o,\n      l,\n      d = 0,\n      c = null,\n      u = !1;\n    (o = a[n + \"_start\"](new Date(r))).valueOf() != r.valueOf() && (u = !0);\n    var h = !1;\n    (l = a[n + \"_start\"](new Date(e))).valueOf() != e.valueOf() && (h = !0);\n    for (var g = !1; r.valueOf() < s.valueOf();) {\n      if (g = (c = this._nextDate(r, n, i)).valueOf() > s.valueOf(), this._isWorkTime(r, n)) (u || h && g) && (o = a[n + \"_start\"](new Date(r)), l = a.add(o, i, n)), u ? (u = !1, c = this._nextDate(o, n, i), d += (l.valueOf() - r.valueOf()) / (l.valueOf() - o.valueOf())) : h && g ? (h = !1, d += (s.valueOf() - r.valueOf()) / (l.valueOf() - o.valueOf())) : d++;else {\n        var f = this._getUnitOrder(n),\n          y = this.units[f - 1];\n        y && !this._isWorkTime(r, y) && (c = this._getClosestWorkTimeFuture(r, y));\n      }\n      r = c;\n    }\n    return d;\n  },\n  _getMinutesPerHour: function (t) {\n    var e = this._getTimeOfDayStamp(t),\n      n = this._getTimeOfDayStamp(this._nextDate(t, \"hour\", 1));\n    n === 0 && (n = 86400);\n    for (var i = this._getWorkHours(t), a = 0; a < i.length; a++) {\n      var r = i[a];\n      if (e >= r.start && n <= r.end) return 60;\n      if (e < r.end && n > r.start) return (Math.min(n, r.end) - Math.max(e, r.start)) / 60;\n    }\n    return 0;\n  },\n  _getMinutesPerDay: function (t) {\n    var e = this._getWorkHours(t),\n      n = 0;\n    return e.forEach(function (i) {\n      n += i.durationMinutes;\n    }), n;\n  },\n  getHoursPerDay: function (t) {\n    var e = this._getWorkHours(t),\n      n = 0;\n    return e.forEach(function (i) {\n      n += i.durationHours;\n    }), n;\n  },\n  _getWorkUnitsForRange: function (t, e, n, i) {\n    var a,\n      r = 0,\n      s = new Date(t),\n      o = new Date(e);\n    for (a = R(n == \"minute\" ? this._getMinutesPerDay : this.getHoursPerDay, this); s.valueOf() < o.valueOf();) if (o - s > 27648e5 && s.getDate() === 0) {\n      var l = this._largeUnitsCache.getMinutesPerMonth(s);\n      n == \"hour\" && (l /= 60), r += l, s = this.$gantt.date.add(s, 1, \"month\");\n    } else {\n      if (o - s > 13824e5) {\n        var d = this.$gantt.date.week_start(new Date(s));\n        if (s.valueOf() === d.valueOf()) {\n          l = this._largeUnitsCache.getMinutesPerWeek(s), n == \"hour\" && (l /= 60), r += l, s = this.$gantt.date.add(s, 7, \"day\");\n          continue;\n        }\n      }\n      r += a(s), s = this._nextDate(s, \"day\", 1);\n    }\n    return r / i;\n  },\n  _getMinutesBetweenSingleDay: function (t, e) {\n    for (var n = this._getIntervalTimestamp(t, e), i = this._getWorkHours(t), a = 0, r = 0; r < i.length; r++) {\n      var s = i[r];\n      if (n.end >= s.start && n.start <= s.end) {\n        var o = Math.max(s.start, n.start),\n          l = Math.min(s.end, n.end);\n        a += (l - o) / 60, n.start = l;\n      }\n    }\n    return Math.floor(a);\n  },\n  _getMinutesBetween: function (t, e, n, i) {\n    var a = new Date(t),\n      r = new Date(e);\n    i = i || 1;\n    var s = new Date(a),\n      o = this.$gantt.date.add(this.$gantt.date.day_start(new Date(a)), 1, \"day\");\n    if (r.valueOf() <= o.valueOf()) return this._getMinutesBetweenSingleDay(t, e);\n    var l = this.$gantt.date.day_start(new Date(r)),\n      d = r,\n      c = this._getMinutesBetweenSingleDay(s, o),\n      u = this._getMinutesBetweenSingleDay(l, d);\n    return c + this._getWorkUnitsForRange(o, l, n, i) + u;\n  },\n  _getHoursBetween: function (t, e, n, i) {\n    var a = new Date(t),\n      r = new Date(e);\n    i = i || 1;\n    var s = new Date(a),\n      o = this.$gantt.date.add(this.$gantt.date.day_start(new Date(a)), 1, \"day\");\n    if (r.valueOf() <= o.valueOf()) return Math.round(this._getMinutesBetweenSingleDay(t, e) / 60);\n    var l = this.$gantt.date.day_start(new Date(r)),\n      d = r,\n      c = this._getMinutesBetweenSingleDay(s, o, n, i) / 60,\n      u = this._getMinutesBetweenSingleDay(l, d, n, i) / 60,\n      h = c + this._getWorkUnitsForRange(o, l, n, i) + u;\n    return Math.round(h);\n  },\n  getConfig: function () {\n    return this._worktime;\n  },\n  _setConfig: function (t) {\n    this._worktime = t, this._parseSettings(), this._clearCaches();\n  },\n  _parseSettings: function () {\n    var t = this.getConfig();\n    for (var e in t.parsed = {\n      dates: {},\n      hours: null,\n      haveCustomWeeks: !1,\n      customWeeks: {},\n      customWeeksRangeStart: null,\n      customWeeksRangeEnd: null,\n      customWeeksBoundaries: []\n    }, t.parsed.hours = this._parseHours(t.hours), t.dates) t.parsed.dates[e] = this._parseHours(t.dates[e]);\n    if (t.customWeeks) {\n      var n = null,\n        i = null;\n      for (var e in t.customWeeks) {\n        var a = t.customWeeks[e];\n        if (a.from && a.to) {\n          var r = a.from,\n            s = a.to;\n          (!n || n > r.valueOf()) && (n = r.valueOf()), (!i || i < s.valueOf()) && (i = s.valueOf()), t.parsed.customWeeksBoundaries.push({\n            from: r.valueOf(),\n            fromReadable: new Date(r),\n            to: s.valueOf(),\n            toReadable: new Date(s),\n            name: e\n          }), t.parsed.haveCustomWeeks = !0;\n          var o = t.parsed.customWeeks[e] = {\n            from: a.from,\n            to: a.to,\n            hours: this._parseHours(a.hours),\n            dates: {}\n          };\n          for (var l in a.dates) o.dates[l] = this._parseHours(a.dates[l]);\n        }\n      }\n      t.parsed.customWeeksRangeStart = n, t.parsed.customWeeksRangeEnd = i;\n    }\n  },\n  _tryChangeCalendarSettings: function (t) {\n    var e = JSON.stringify(this.getConfig());\n    return t(), !!this.hasWorkTime() || (this._setConfig(JSON.parse(e)), this._clearCaches(), !1);\n  },\n  _arraysEqual: function (t, e) {\n    if (t === e) return !0;\n    if (!t || !e || t.length != e.length) return !1;\n    for (var n = 0; n < t.length; ++n) if (t[n] !== e[n]) return !1;\n    return !0;\n  },\n  _compareSettings: function (t, e) {\n    if (!this._arraysEqual(t.hours, e.hours)) return !1;\n    var n = Object.keys(t.dates),\n      i = Object.keys(e.dates);\n    if (n.sort(), i.sort(), !this._arraysEqual(n, i)) return !1;\n    for (var a = 0; a < n.length; a++) {\n      var r = n[a],\n        s = t.dates[r],\n        o = t.dates[r];\n      if (s !== o && !(Array.isArray(s) && Array.isArray(o) && this._arraysEqual(s, o))) return !1;\n    }\n    return !0;\n  },\n  equals: function (t) {\n    if (!(t instanceof ye)) return !1;\n    var e = this.getConfig(),\n      n = t.getConfig();\n    if (!this._compareSettings(e, n)) return !1;\n    if (e.parsed.haveCustomWeeks && n.parsed.haveCustomWeeks) {\n      if (e.parsed.customWeeksBoundaries.length != n.parsed.customWeeksBoundaries.length) return !1;\n      for (var i in e.parsed.customWeeks) {\n        var a = e.parsed.customWeeks[i],\n          r = n.parsed.customWeeks[i];\n        if (!r || !this._compareSettings(a, r)) return !1;\n      }\n    } else if (e.parse.haveCustomWeeks !== n.parsed.haveCustomWeeks) return !1;\n    return !0;\n  },\n  getWorkHours: function () {\n    var t = this.argumentsHelper.getWorkHoursArguments.apply(this.argumentsHelper, arguments);\n    return this._getWorkHours(t.date, !1);\n  },\n  _getWorkHours: function (t, e) {\n    var n = this.getConfig();\n    if (e !== !1 && (n = n.parsed), !t) return n.hours;\n    var i = this._timestamp({\n      date: t\n    });\n    if (n.haveCustomWeeks && n.customWeeksRangeStart <= i && n.customWeeksRangeEnd > i) {\n      for (var a = 0; a < n.customWeeksBoundaries.length; a++) if (n.customWeeksBoundaries[a].from <= i && n.customWeeksBoundaries[a].to > i) {\n        n = n.customWeeks[n.customWeeksBoundaries[a].name];\n        break;\n      }\n    }\n    var r = !0;\n    return n.dates[i] !== void 0 ? r = n.dates[i] : n.dates[t.getDay()] !== void 0 && (r = n.dates[t.getDay()]), r === !0 ? n.hours : r || [];\n  },\n  _getIntervalTimestamp: function (t, e) {\n    var n = {\n      start: 0,\n      end: 0\n    };\n    n.start = 60 * t.getHours() * 60 + 60 * t.getMinutes() + t.getSeconds();\n    var i = e.getHours();\n    return !i && !e.getMinutes() && !e.getSeconds() && t.valueOf() < e.valueOf() && (i = 24), n.end = 60 * i * 60 + 60 * e.getMinutes() + e.getSeconds(), n;\n  },\n  _parseHours: function (t) {\n    if (Array.isArray(t)) {\n      var e = [];\n      t.forEach(function (o) {\n        typeof o == \"number\" ? e.push(60 * o * 60) : typeof o == \"string\" && o.split(\"-\").map(function (l) {\n          return l.trim();\n        }).forEach(function (l) {\n          var d = l.split(\":\").map(function (u) {\n              return u.trim();\n            }),\n            c = parseInt(60 * d[0] * 60);\n          d[1] && (c += parseInt(60 * d[1])), d[2] && (c += parseInt(d[2])), e.push(c);\n        });\n      });\n      for (var n = [], i = 0; i < e.length; i += 2) {\n        var a = e[i],\n          r = e[i + 1],\n          s = r - a;\n        n.push({\n          start: a,\n          end: r,\n          startHour: Math.floor(a / 3600),\n          startMinute: Math.floor(a / 60),\n          endHour: Math.ceil(r / 3600),\n          endMinute: Math.ceil(r / 60),\n          durationSeconds: s,\n          durationMinutes: s / 60,\n          durationHours: s / 3600\n        });\n      }\n      return n;\n    }\n    return t;\n  },\n  setWorkTime: function (t) {\n    return this._tryChangeCalendarSettings(R(function () {\n      var e = t.hours === void 0 || t.hours,\n        n = this._timestamp(t),\n        i = this.getConfig();\n      if (n !== null ? i.dates[n] = e : t.customWeeks || (i.hours = e), t.customWeeks) {\n        if (i.customWeeks || (i.customWeeks = {}), typeof t.customWeeks == \"string\") n !== null ? i.customWeeks[t.customWeeks].dates[n] = e : t.customWeeks || (i.customWeeks[t.customWeeks].hours = e);else if (typeof t.customWeeks == \"object\" && Function.prototype.toString.call(t.customWeeks.constructor) === \"function Object() { [native code] }\") for (var a in t.customWeeks) i.customWeeks[a] = t.customWeeks[a];\n      }\n      this._parseSettings(), this._clearCaches();\n    }, this));\n  },\n  unsetWorkTime: function (t) {\n    return this._tryChangeCalendarSettings(R(function () {\n      if (t) {\n        var e = this._timestamp(t);\n        e !== null && delete this.getConfig().dates[e];\n      } else this.reset_calendar();\n      this._parseSettings(), this._clearCaches();\n    }, this));\n  },\n  _isWorkTime: function (t, e) {\n    var n,\n      i = -1;\n    return n = String(t.valueOf()), (i = this._workingUnitsCache.getItem(e, n, t)) == -1 && (i = this._checkIfWorkingUnit(t, e), this._workingUnitsCache.setItem(e, n, i, t)), i;\n  },\n  isWorkTime: function () {\n    var t = this.argumentsHelper.isWorkTimeArguments.apply(this.argumentsHelper, arguments);\n    return this._isWorkTime(t.date, t.unit);\n  },\n  calculateDuration: function () {\n    var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments);\n    if (!t.unit) return !1;\n    var e = this;\n    return this._dateDurationCache.getDuration(t.start_date, t.end_date, t.unit, t.step, function () {\n      return e._calculateDuration(t.start_date, t.end_date, t.unit, t.step);\n    });\n  },\n  _calculateDuration: function (t, e, n, i) {\n    var a = 0,\n      r = 1;\n    if (t.valueOf() > e.valueOf()) {\n      var s = e;\n      e = t, t = s, r = -1;\n    }\n    return a = n == \"hour\" && i == 1 ? this._getHoursBetween(t, e, n, i) : n == \"minute\" && i == 1 ? this._getMinutesBetween(t, e, n, i) : this._getWorkUnitsBetweenGeneric(t, e, n, i), r * Math.round(a);\n  },\n  hasDuration: function () {\n    var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments),\n      e = t.start_date,\n      n = t.end_date,\n      i = t.unit,\n      a = t.step;\n    if (!i) return !1;\n    var r = new Date(e),\n      s = new Date(n);\n    for (a = a || 1; r.valueOf() < s.valueOf();) {\n      if (this._isWorkTime(r, i)) return !0;\n      r = this._nextDate(r, i, a);\n    }\n    return !1;\n  },\n  calculateEndDate: function () {\n    var t = this.argumentsHelper.calculateEndDateArguments.apply(this.argumentsHelper, arguments),\n      e = t.start_date,\n      n = t.duration,\n      i = t.unit,\n      a = t.step;\n    if (!i) return !1;\n    var r = t.duration >= 0 ? 1 : -1;\n    n = Math.abs(1 * n);\n    var s = this;\n    return this._dateDurationCache.getEndDate(e, n, i, a * r, function () {\n      return s._calculateEndDate(e, n, i, a * r);\n    });\n  },\n  _calculateEndDate: function (t, e, n, i) {\n    return !!n && (i == 1 && n == \"minute\" ? this._calculateMinuteEndDate(t, e, i) : i == -1 && n == \"minute\" ? this._subtractMinuteDate(t, e, i) : i == 1 && n == \"hour\" ? this._calculateHourEndDate(t, e, i) : this._addInterval(t, e, n, i, null).end);\n  },\n  _addInterval: function (t, e, n, i, a) {\n    for (var r = 0, s = t, o = !1; r < e && (!a || !a(s));) {\n      var l = this._nextDate(s, n, i);\n      n == \"day\" && (o = o || !s.getHours() && l.getHours()) && (l.setHours(0), l.getHours() || (o = !1));\n      var d = new Date(l.valueOf() + 1);\n      i > 0 && (d = new Date(l.valueOf() - 1)), this._isWorkTime(d, n) && !o && r++, s = l;\n    }\n    return {\n      end: s,\n      start: t,\n      added: r\n    };\n  },\n  _addHoursUntilDayEnd: function (t, e) {\n    for (var n = this.$gantt.date.add(this.$gantt.date.day_start(new Date(t)), 1, \"day\"), i = 0, a = e, r = this._getIntervalTimestamp(t, n), s = this._getWorkHours(t), o = 0; o < s.length && i < e; o++) {\n      var l = s[o];\n      if (r.end >= l.start && r.start <= l.end) {\n        var d = Math.max(l.start, r.start),\n          c = Math.min(l.end, r.end),\n          u = (c - d) / 3600;\n        u > a && (u = a, c = d + 60 * a * 60);\n        var h = Math.round((c - d) / 3600);\n        i += h, a -= h, r.start = c;\n      }\n    }\n    var g = n;\n    return i === e && (g = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 0, 0, r.start)), {\n      added: i,\n      end: g\n    };\n  },\n  _calculateHourEndDate: function (t, e, n) {\n    var i = new Date(t),\n      a = 0;\n    n = n || 1, e = Math.abs(1 * e);\n    var r = this._addHoursUntilDayEnd(i, e);\n    if (a = r.added, i = r.end, d = e - a) {\n      for (var s = i; a < e;) {\n        var o = this._nextDate(s, \"day\", n);\n        o.setHours(0), o.setMinutes(0), o.setSeconds(0);\n        var l = 0;\n        if (a + (l = n > 0 ? this.getHoursPerDay(new Date(o.valueOf() - 1)) : this.getHoursPerDay(new Date(o.valueOf() + 1))) >= e) break;\n        a += l, s = o;\n      }\n      i = s;\n    }\n    if (a < e) {\n      var d = e - a;\n      i = (r = this._addHoursUntilDayEnd(i, d)).end;\n    }\n    return i;\n  },\n  _addMinutesUntilHourEnd: function (t, e) {\n    if (t.getMinutes() === 0) return {\n      added: 0,\n      end: new Date(t)\n    };\n    for (var n = this.$gantt.date.add(this.$gantt.date.hour_start(new Date(t)), 1, \"hour\"), i = 0, a = e, r = this._getIntervalTimestamp(t, n), s = this._getWorkHours(t), o = 0; o < s.length && i < e; o++) {\n      var l = s[o];\n      if (r.end >= l.start && r.start <= l.end) {\n        var d = Math.max(l.start, r.start),\n          c = Math.min(l.end, r.end),\n          u = (c - d) / 60;\n        u > a && (u = a, c = d + 60 * a);\n        var h = Math.round((c - d) / 60);\n        a -= h, i += h, r.start = c;\n      }\n    }\n    var g = n;\n    return i === e && (g = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 0, 0, r.start)), {\n      added: i,\n      end: g\n    };\n  },\n  _subtractMinutesUntilHourStart: function (t, e) {\n    for (var n = this.$gantt.date.hour_start(new Date(t)), i = 0, a = e, r = 60 * n.getHours() * 60 + 60 * n.getMinutes() + n.getSeconds(), s = 60 * t.getHours() * 60 + 60 * t.getMinutes() + t.getSeconds(), o = this._getWorkHours(t), l = o.length - 1; l >= 0 && i < e; l--) {\n      var d = o[l];\n      if (s > d.start && r <= d.end) {\n        var c = Math.min(s, d.end),\n          u = Math.max(r, d.start),\n          h = (c - u) / 60;\n        h > a && (h = a, u = c - 60 * a);\n        var g = Math.abs(Math.round((c - u) / 60));\n        a -= g, i += g, s = u;\n      }\n    }\n    var f = n;\n    return i === e && (f = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 0, 0, s)), {\n      added: i,\n      end: f\n    };\n  },\n  _subtractMinuteDate: function (t, e, n) {\n    var i = this.getClosestWorkTime({\n        date: t,\n        dir: \"past\",\n        unit: \"minute\"\n      }),\n      a = 0;\n    n = n || -1, e = Math.abs(1 * e), e = Math.round(e);\n    const r = this._isMinutePrecision(i);\n    let s = this._subtractMinutesUntilHourStart(i, e);\n    a += s.added, i = s.end;\n    for (var o = 0, l = [], d = 0; a < e;) {\n      var c = this.$gantt.date.day_start(new Date(i)),\n        u = !1;\n      i.valueOf() === c.valueOf() && (c = this.$gantt.date.add(c, -1, \"day\"), u = !0);\n      var h = new Date(c.getFullYear(), c.getMonth(), c.getDate(), 23, 59, 59, 999).valueOf();\n      h !== o && (l = this._getWorkHours(c), d = this._getMinutesPerDay(c), o = h);\n      var g = e - a,\n        f = this._getTimeOfDayStamp(i, u);\n      if (l.length && d) {\n        if (l[l.length - 1].end <= f && g > d) a += d, i = this.$gantt.date.add(i, -1, \"day\");else {\n          for (var y = !1, v = null, b = null, _ = l.length - 1; _ >= 0; _--) if (l[_].start < f - 1 && l[_].end >= f - 1) {\n            y = !0, v = l[_], b = l[_ - 1];\n            break;\n          }\n          if (y) {\n            if (f === v.end && g >= v.durationMinutes) a += v.durationMinutes, i = this.$gantt.date.add(i, -v.durationMinutes, \"minute\");else if (!r && g <= f / 60 - v.startMinute) a += g, i = this.$gantt.date.add(i, -g, \"minute\");else if (r) g <= f / 60 - v.startMinute ? (a += g, i = this.$gantt.date.add(i, -g, \"minute\")) : (a += f / 60 - v.startMinute, i = b ? new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, b.end) : this.$gantt.date.day_start(i));else {\n              var m = this._getMinutesPerHour(i);\n              m <= g ? (a += m, i = this._nextDate(i, \"hour\", n)) : (s = this._subtractMinutesUntilHourStart(i, g), a += s.added, i = s.end);\n            }\n          } else if (i.getHours() === 0 && i.getMinutes() === 0 && i.getSeconds() === 0) {\n            if ((p = this._getClosestWorkTimePast(i, \"hour\")).valueOf() === i.valueOf()) {\n              var p = this.$gantt.date.add(i, -1, \"day\"),\n                k = this._getWorkHours(p);\n              if (k.length) {\n                var x = k[k.length - 1];\n                p.setSeconds(x.durationSeconds);\n              }\n            }\n            i = p;\n          } else i = this._getClosestWorkTimePast(new Date(i - 1), \"hour\");\n        }\n      } else i = this.$gantt.date.add(i, -1, \"day\");\n    }\n    if (a < e) {\n      var $ = e - a;\n      s = this._subtractMinutesUntilHourStart(i, $), a += s.added, i = s.end;\n    }\n    return i;\n  },\n  _calculateMinuteEndDate: function (t, e, n) {\n    var i = new Date(t),\n      a = 0;\n    n = n || 1, e = Math.abs(1 * e), e = Math.round(e);\n    var r = this._addMinutesUntilHourEnd(i, e);\n    a += r.added, i = r.end;\n    for (var s = 0, o = [], l = 0, d = this._isMinutePrecision(i); a < e;) {\n      var c = this.$gantt.date.day_start(new Date(i)).valueOf();\n      c !== s && (o = this._getWorkHours(i), l = this._getMinutesPerDay(i), s = c);\n      var u = e - a,\n        h = this._getTimeOfDayStamp(i);\n      if (o.length && l) {\n        if (o[0].start >= h && u >= l) {\n          if (a += l, u == l) {\n            i = new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, o[o.length - 1].end);\n            break;\n          }\n          i = this.$gantt.date.add(i, 1, \"day\"), i = this.$gantt.date.day_start(i);\n        } else {\n          for (var g = !1, f = null, y = 0; y < o.length; y++) if (o[y].start <= h && o[y].end > h) {\n            g = !0, f = o[y];\n            break;\n          }\n          if (g) {\n            if (h === f.start && u >= f.durationMinutes) a += f.durationMinutes, i = this.$gantt.date.add(i, f.durationMinutes, \"minute\");else if (u <= f.endMinute - h / 60) a += u, i = this.$gantt.date.add(i, u, \"minute\");else {\n              var v = this._getMinutesPerHour(i);\n              v <= u ? (a += v, i = d ? this.$gantt.date.add(i, v, \"minute\") : this._nextDate(i, \"hour\", n)) : (a += (r = this._addMinutesUntilHourEnd(i, u)).added, i = r.end);\n            }\n          } else i = this._getClosestWorkTimeFuture(i, \"hour\");\n        }\n      } else i = this.$gantt.date.add(this.$gantt.date.day_start(i), 1, \"day\");\n    }\n    if (a < e) {\n      var b = e - a;\n      a += (r = this._addMinutesUntilHourEnd(i, b)).added, i = r.end;\n    }\n    return i;\n  },\n  getClosestWorkTime: function () {\n    var t = this.argumentsHelper.getClosestWorkTimeArguments.apply(this.argumentsHelper, arguments);\n    return this._getClosestWorkTime(t.date, t.unit, t.dir);\n  },\n  _getClosestWorkTime: function (t, e, n) {\n    var i = new Date(t);\n    if (this._isWorkTime(i, e)) return i;\n    if (i = this.$gantt.date[e + \"_start\"](i), n != \"any\" && n) i = n == \"past\" ? this._getClosestWorkTimePast(i, e) : this._getClosestWorkTimeFuture(i, e);else {\n      var a = this._getClosestWorkTimeFuture(i, e),\n        r = this._getClosestWorkTimePast(i, e);\n      i = Math.abs(a - t) <= Math.abs(t - r) ? a : r;\n    }\n    return i;\n  },\n  _getClosestWorkTimeFuture: function (t, e) {\n    return this._getClosestWorkTimeGeneric(t, e, 1);\n  },\n  _getClosestWorkTimePast: function (t, e) {\n    var n = this._getClosestWorkTimeGeneric(t, e, -1);\n    return this.$gantt.date.add(n, 1, e);\n  },\n  _findClosestTimeInDay: function (t, e, n) {\n    var i = new Date(t),\n      a = null,\n      r = !1;\n    this._getWorkHours(i).length || (i = this._getClosestWorkTime(i, \"day\", e < 0 ? \"past\" : \"future\"), e < 0 && (i = new Date(i.valueOf() - 1), r = !0), n = this._getWorkHours(i));\n    var s = this._getTimeOfDayStamp(i);\n    if (r && (s = this._getTimeOfDayStamp(new Date(i.valueOf() + 1), r)), e > 0) {\n      for (var o = 0; o < n.length; o++) if (n[o].start >= s) {\n        a = new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, n[o].start);\n        break;\n      }\n    } else for (o = n.length - 1; o >= 0; o--) {\n      if (n[o].end <= s) {\n        a = new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, n[o].end);\n        break;\n      }\n      if (n[o].end > s && n[o].start <= s) {\n        a = new Date(i.getFullYear(), i.getMonth(), i.getDate(), 0, 0, s);\n        break;\n      }\n    }\n    return a;\n  },\n  _getClosestWorkMinute: function (t, e, n) {\n    var i = new Date(t),\n      a = this._getWorkHours(i),\n      r = this._findClosestTimeInDay(i, n, a);\n    return r || (n > 0 ? (i = this.calculateEndDate(i, n, e), i = this.$gantt.date.day_start(i)) : (i = this.calculateEndDate(i, n, \"day\"), i = this.$gantt.date.day_start(i), i = this.$gantt.date.add(i, 1, \"day\"), i = new Date(i.valueOf() - 1)), a = this._getWorkHours(i), r = this._findClosestTimeInDay(i, n, a)), n < 0 && (r = this.$gantt.date.add(r, -1, e)), r;\n  },\n  _getClosestWorkTimeGeneric: function (t, e, n) {\n    if (e === \"hour\" || e === \"minute\") return this._getClosestWorkMinute(t, e, n);\n    for (var i = this._getUnitOrder(e), a = this.units[i - 1], r = t, s = 0; !this._isWorkTime(r, e) && (!a || this._isWorkTime(r, a) || (r = n > 0 ? this._getClosestWorkTimeFuture(r, a) : this._getClosestWorkTimePast(r, a), !this._isWorkTime(r, e)));) {\n      if (++s > 3e3) return this.$gantt.assert(!1, \"Invalid working time check\"), !1;\n      var o = r.getTimezoneOffset();\n      r = this.$gantt.date.add(r, n, e), r = this.$gantt._correct_dst_change(r, o, n, e), this.$gantt.date[e + \"_start\"] && (r = this.$gantt.date[e + \"_start\"](r));\n    }\n    return r;\n  },\n  hasWorkTime: function () {\n    var t = this.getConfig(),\n      e = t.dates;\n    for (var n in t.dates);\n    var i = this._checkWorkHours(t.hours),\n      a = !1;\n    return [0, 1, 2, 3, 4, 5, 6].forEach(function (r) {\n      if (!a) {\n        var s = e[r];\n        s === !0 ? a = i : Array.isArray(s) && (a = this._checkWorkHours(s));\n      }\n    }.bind(this)), a;\n  },\n  _checkWorkHours: function (t) {\n    if (t.length === 0) return !1;\n    for (var e = !1, n = 0; n < t.length; n += 2) t[n] !== t[n + 1] && (e = !0);\n    return e;\n  },\n  _isMinutePrecision: function (t) {\n    let e = !1;\n    return this._getWorkHours(t).forEach(function (n) {\n      (n.startMinute % 60 || n.endMinute % 60) && (e = !0);\n    }), e;\n  }\n};\nconst It = {\n    isLegacyResourceCalendarFormat: function (t) {\n      if (!t) return !1;\n      for (var e in t) if (t[e] && typeof t[e] == \"object\") return !0;\n      return !1;\n    },\n    getResourceProperty: function (t) {\n      var e = t.resource_calendars,\n        n = t.resource_property;\n      if (this.isLegacyResourceCalendarFormat(e)) for (var i in t) {\n        n = i;\n        break;\n      }\n      return n;\n    },\n    getCalendarIdFromLegacyConfig: function (t, e) {\n      if (e) for (var n in e) {\n        var i = e[n];\n        if (t[n]) {\n          var a = i[t[n]];\n          if (a) return a;\n        }\n      }\n      return null;\n    }\n  },\n  Si = (Wt = {}, {\n    getCalendarIdFromMultipleResources: function (t, e) {\n      var n = function (a) {\n        return a.map(function (r) {\n          return r && r.resource_id ? r.resource_id : r;\n        }).sort().join(\"-\");\n      }(t);\n      if (t.length) {\n        if (t.length === 1) return e.getResourceCalendar(n).id;\n        if (Wt[n]) return Wt[n].id;\n        var i = function (a, r) {\n          return r.mergeCalendars(a.map(function (s) {\n            var o = s && s.resource_id ? s.resource_id : s;\n            return r.getResourceCalendar(o);\n          }));\n        }(t, e);\n        return Wt[n] = i, e.addCalendar(i);\n      }\n      return null;\n    }\n  });\nvar Wt;\nfunction pn(t) {\n  this.$gantt = t, this._calendars = {}, this._legacyConfig = void 0, this.$gantt.attachEvent(\"onGanttReady\", function () {\n    this.$gantt.config.resource_calendars && (this._isLegacyConfig = It.isLegacyResourceCalendarFormat(this.$gantt.config.resource_calendars));\n  }.bind(this)), this.$gantt.attachEvent(\"onBeforeGanttReady\", function () {\n    this.createDefaultCalendars();\n  }.bind(this)), this.$gantt.attachEvent(\"onBeforeGanttRender\", function () {\n    this.createDefaultCalendars();\n  }.bind(this));\n}\nfunction be(t, e) {\n  this.argumentsHelper = e, this.$gantt = t;\n}\nfunction mn(t) {\n  this.$gantt = t.$gantt, this.argumentsHelper = gn(this.$gantt), this.calendarManager = t, this.$disabledCalendar = new be(this.$gantt, this.argumentsHelper);\n}\npn.prototype = {\n  _calendars: {},\n  _convertWorkTimeSettings: function (t) {\n    var e = t.days;\n    if (e && !t.dates) {\n      t.dates = t.dates || {};\n      for (var n = 0; n < e.length; n++) t.dates[n] = e[n], e[n] instanceof Array || (t.dates[n] = !!e[n]);\n    }\n    return delete t.days, t;\n  },\n  mergeCalendars: function () {\n    var t = [],\n      e = arguments;\n    if (Array.isArray(e[0])) t = e[0].slice();else for (var n = 0; n < arguments.length; n++) t.push(arguments[n]);\n    var i,\n      a = new fn();\n    return t.forEach(function (r) {\n      i = i ? this._createCalendarFromConfig(a.merge(i, r)) : r;\n    }.bind(this)), this.createCalendar(i);\n  },\n  _createCalendarFromConfig: function (t) {\n    var e = new ye(this.$gantt, gn(this.$gantt));\n    e.id = String(st());\n    var n = this._convertWorkTimeSettings(t);\n    if (n.customWeeks) for (var i in n.customWeeks) n.customWeeks[i] = this._convertWorkTimeSettings(n.customWeeks[i]);\n    return e._setConfig(n), e;\n  },\n  createCalendar: function (t) {\n    var e;\n    return t || (t = {}), L(e = t.getConfig ? G(t.getConfig()) : t.worktime ? G(t.worktime) : G(t), G(this.defaults.fulltime.worktime)), this._createCalendarFromConfig(e);\n  },\n  getCalendar: function (t) {\n    t = t || \"global\";\n    var e = this._calendars[t];\n    return e || (this.createDefaultCalendars(), e = this._calendars[t]), e;\n  },\n  getCalendars: function () {\n    var t = [];\n    for (var e in this._calendars) t.push(this.getCalendar(e));\n    return t;\n  },\n  _getOwnCalendar: function (t) {\n    var e = this.$gantt.config;\n    if (t[e.calendar_property]) return this.getCalendar(t[e.calendar_property]);\n    if (e.resource_calendars) {\n      var n;\n      if (n = this._legacyConfig === !1 ? e.resource_property : It.getResourceProperty(e), Array.isArray(t[n])) e.dynamic_resource_calendars ? i = Si.getCalendarIdFromMultipleResources(t[n], this) : a = this.getResourceCalendar(t[n]);else if (this._legacyConfig === void 0 && (this._legacyConfig = It.isLegacyResourceCalendarFormat(e.resource_calendars)), this._legacyConfig) var i = It.getCalendarIdFromLegacyConfig(t, e.resource_calendars);else if (n && t[n] && e.resource_calendars[t[n]]) var a = this.getResourceCalendar(t[n]);\n      if (i && (a = this.getCalendar(i)), a) return a;\n    }\n    return null;\n  },\n  getResourceCalendar: function (t) {\n    if (t == null) return this.getCalendar();\n    var e = null;\n    e = typeof t == \"number\" || typeof t == \"string\" ? t : t.id || t.key;\n    var n = this.$gantt.config,\n      i = n.resource_calendars,\n      a = null;\n    if (Array.isArray(t) && t.length === 1 && (e = typeof t[0] == \"object\" ? t[0].resource_id : t[0]), i) {\n      if (this._legacyConfig === void 0 && (this._legacyConfig = It.isLegacyResourceCalendarFormat(n.resource_calendars)), this._legacyConfig) {\n        for (var r in i) if (i[r][e]) {\n          a = i[r][e];\n          break;\n        }\n      } else a = i[e];\n      if (a) return this.getCalendar(a);\n    }\n    return this.getCalendar();\n  },\n  getTaskCalendar: function (t) {\n    var e,\n      n = this.$gantt;\n    if (t == null) return this.getCalendar();\n    if (!(e = typeof t != \"number\" && typeof t != \"string\" || !n.isTaskExists(t) ? t : n.getTask(t))) return this.getCalendar();\n    var i = this._getOwnCalendar(e),\n      a = !!n.getState().group_mode;\n    if (!i && n.config.inherit_calendar && n.isTaskExists(e.parent)) {\n      for (var r = e; n.isTaskExists(r.parent) && (r = n.getTask(r.parent), !n.isSummaryTask(r) || !(i = this._getOwnCalendar(r))););\n      a && !i && t.$effective_calendar && (i = this.getCalendar(t.$effective_calendar));\n    }\n    return i || this.getCalendar();\n  },\n  addCalendar: function (t) {\n    if (!this.isCalendar(t)) {\n      var e = t.id;\n      (t = this.createCalendar(t)).id = e;\n    }\n    if (t._tryChangeCalendarSettings(function () {})) {\n      var n = this.$gantt.config;\n      return t.id = t.id || st(), this._calendars[t.id] = t, n.worktimes || (n.worktimes = {}), n.worktimes[t.id] = t.getConfig(), t.id;\n    }\n    return this.$gantt.callEvent(\"onCalendarError\", [{\n      message: \"Invalid calendar settings, no worktime available\"\n    }, t]), null;\n  },\n  deleteCalendar: function (t) {\n    var e = this.$gantt.config;\n    return !!t && !!this._calendars[t] && (delete this._calendars[t], e.worktimes && e.worktimes[t] && delete e.worktimes[t], !0);\n  },\n  restoreConfigCalendars: function (t) {\n    for (var e in t) if (!this._calendars[e]) {\n      var n = t[e],\n        i = this.createCalendar(n);\n      i.id = e, this.addCalendar(i);\n    }\n  },\n  defaults: {\n    global: {\n      id: \"global\",\n      worktime: {\n        hours: [8, 12, 13, 17],\n        days: [0, 1, 1, 1, 1, 1, 0]\n      }\n    },\n    fulltime: {\n      id: \"fulltime\",\n      worktime: {\n        hours: [0, 24],\n        days: [1, 1, 1, 1, 1, 1, 1]\n      }\n    }\n  },\n  createDefaultCalendars: function () {\n    var t = this.$gantt.config;\n    this.restoreConfigCalendars(this.defaults), this.restoreConfigCalendars(t.worktimes);\n  },\n  isCalendar: function (t) {\n    return [t.isWorkTime, t.setWorkTime, t.getWorkHours, t.unsetWorkTime, t.getClosestWorkTime, t.calculateDuration, t.hasDuration, t.calculateEndDate].every(function (e) {\n      return e instanceof Function;\n    });\n  }\n}, be.prototype = {\n  getWorkHours: function () {\n    return [0, 24];\n  },\n  setWorkTime: function () {\n    return !0;\n  },\n  unsetWorkTime: function () {\n    return !0;\n  },\n  isWorkTime: function () {\n    return !0;\n  },\n  getClosestWorkTime: function (t) {\n    return this.argumentsHelper.getClosestWorkTimeArguments.apply(this.argumentsHelper, arguments).date;\n  },\n  calculateDuration: function () {\n    var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments),\n      e = t.start_date,\n      n = t.end_date,\n      i = t.unit,\n      a = t.step;\n    return this._calculateDuration(e, n, i, a);\n  },\n  _calculateDuration: function (t, e, n, i) {\n    var a = this.$gantt.date,\n      r = {\n        week: 6048e5,\n        day: 864e5,\n        hour: 36e5,\n        minute: 6e4\n      },\n      s = 0;\n    if (r[n]) s = Math.round((e - t) / (i * r[n]));else {\n      for (var o = new Date(t), l = new Date(e); o.valueOf() < l.valueOf();) s += 1, o = a.add(o, i, n);\n      o.valueOf() != e.valueOf() && (s += (l - o) / (a.add(o, i, n) - o));\n    }\n    return Math.round(s);\n  },\n  hasDuration: function () {\n    var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments),\n      e = t.start_date,\n      n = t.end_date;\n    return !!t.unit && (e = new Date(e), n = new Date(n), e.valueOf() < n.valueOf());\n  },\n  hasWorkTime: function () {\n    return !0;\n  },\n  equals: function (t) {\n    return t instanceof be;\n  },\n  calculateEndDate: function () {\n    var t = this.argumentsHelper.calculateEndDateArguments.apply(this.argumentsHelper, arguments),\n      e = t.start_date,\n      n = t.duration,\n      i = t.unit,\n      a = t.step;\n    return this.$gantt.date.add(e, a * n, i);\n  }\n}, mn.prototype = {\n  _getCalendar: function (t) {\n    var e;\n    if (this.$gantt.config.work_time) {\n      var n = this.calendarManager;\n      t.task ? e = n.getTaskCalendar(t.task) : t.id ? e = n.getTaskCalendar(t) : t.calendar && (e = t.calendar), e || (e = n.getTaskCalendar());\n    } else e = this.$disabledCalendar;\n    return e;\n  },\n  getWorkHours: function (t) {\n    return t = this.argumentsHelper.getWorkHoursArguments.apply(this.argumentsHelper, arguments), this._getCalendar(t).getWorkHours(t.date);\n  },\n  setWorkTime: function (t, e) {\n    return t = this.argumentsHelper.setWorkTimeArguments.apply(this.argumentsHelper, arguments), e || (e = this.calendarManager.getCalendar()), e.setWorkTime(t);\n  },\n  unsetWorkTime: function (t, e) {\n    return t = this.argumentsHelper.unsetWorkTimeArguments.apply(this.argumentsHelper, arguments), e || (e = this.calendarManager.getCalendar()), e.unsetWorkTime(t);\n  },\n  isWorkTime: function (t, e, n, i) {\n    var a = this.argumentsHelper.isWorkTimeArguments.apply(this.argumentsHelper, arguments);\n    return (i = this._getCalendar(a)).isWorkTime(a);\n  },\n  getClosestWorkTime: function (t) {\n    return t = this.argumentsHelper.getClosestWorkTimeArguments.apply(this.argumentsHelper, arguments), this._getCalendar(t).getClosestWorkTime(t);\n  },\n  calculateDuration: function () {\n    var t = this.argumentsHelper.getDurationArguments.apply(this.argumentsHelper, arguments);\n    return this._getCalendar(t).calculateDuration(t);\n  },\n  hasDuration: function () {\n    var t = this.argumentsHelper.hasDurationArguments.apply(this.argumentsHelper, arguments);\n    return this._getCalendar(t).hasDuration(t);\n  },\n  calculateEndDate: function (t) {\n    return t = this.argumentsHelper.calculateEndDateArguments.apply(this.argumentsHelper, arguments), this._getCalendar(t).calculateEndDate(t);\n  }\n};\nconst Ti = {\n  create: function (t, e) {\n    return {\n      getWorkHours: function (n) {\n        return e.getWorkHours(n);\n      },\n      setWorkTime: function (n) {\n        return e.setWorkTime(n);\n      },\n      unsetWorkTime: function (n) {\n        e.unsetWorkTime(n);\n      },\n      isWorkTime: function (n, i, a) {\n        return e.isWorkTime(n, i, a);\n      },\n      getClosestWorkTime: function (n) {\n        return e.getClosestWorkTime(n);\n      },\n      calculateDuration: function (n, i, a) {\n        return e.calculateDuration(n, i, a);\n      },\n      _hasDuration: function (n, i, a) {\n        return e.hasDuration(n, i, a);\n      },\n      calculateEndDate: function (n, i, a, r) {\n        return e.calculateEndDate(n, i, a, r);\n      },\n      mergeCalendars: R(t.mergeCalendars, t),\n      createCalendar: R(t.createCalendar, t),\n      addCalendar: R(t.addCalendar, t),\n      getCalendar: R(t.getCalendar, t),\n      getCalendars: R(t.getCalendars, t),\n      getResourceCalendar: R(t.getResourceCalendar, t),\n      getTaskCalendar: R(t.getTaskCalendar, t),\n      deleteCalendar: R(t.deleteCalendar, t)\n    };\n  }\n};\nfunction Ei(t) {\n  t.isUnscheduledTask = function (s) {\n    return t.assert(s && s instanceof Object, \"Invalid argument <b>task</b>=\" + s + \" of gantt.isUnscheduledTask. Task object was expected\"), !!s.unscheduled || !s.start_date;\n  }, t._isAllowedUnscheduledTask = function (s) {\n    return !(!s.unscheduled || !t.config.show_unscheduled);\n  }, t._isTaskInTimelineLimits = function (s) {\n    var o = s.start_date ? s.start_date.valueOf() : null,\n      l = s.end_date ? s.end_date.valueOf() : null;\n    return !!(o && l && o <= this._max_date.valueOf() && l >= this._min_date.valueOf());\n  }, t.isTaskVisible = function (s) {\n    if (!this.isTaskExists(s)) return !1;\n    var o = this.getTask(s);\n    return !(!this._isAllowedUnscheduledTask(o) && !this._isTaskInTimelineLimits(o)) && this.getGlobalTaskIndex(s) >= 0;\n  }, t._getProjectEnd = function () {\n    if (t.config.project_end) return t.config.project_end;\n    var s = t.getTaskByTime();\n    return (s = s.sort(function (o, l) {\n      return +o.end_date > +l.end_date ? 1 : -1;\n    })).length ? s[s.length - 1].end_date : null;\n  }, t._getProjectStart = function () {\n    if (t.config.project_start) return t.config.project_start;\n    if (t.config.start_date) return t.config.start_date;\n    if (t.getState().min_date) return t.getState().min_date;\n    var s = t.getTaskByTime();\n    return (s = s.sort(function (o, l) {\n      return +o.start_date > +l.start_date ? 1 : -1;\n    })).length ? s[0].start_date : null;\n  };\n  var e = function (s, o) {\n    var l = !!(o && o != t.config.root_id && t.isTaskExists(o)) && t.getTask(o),\n      d = null;\n    if (l) {\n      if (t.config.schedule_from_end) d = t.calculateEndDate({\n        start_date: l.end_date,\n        duration: -t.config.duration_step,\n        task: s\n      });else {\n        if (!l.start_date) return e(l, t.getParent(l));\n        d = l.start_date;\n      }\n    } else if (t.config.schedule_from_end) d = t.calculateEndDate({\n      start_date: t._getProjectEnd(),\n      duration: -t.config.duration_step,\n      task: s\n    });else {\n      const c = t.getTaskByIndex(0),\n        u = t.config.start_date || t.getState().min_date;\n      d = c ? c.start_date ? c.start_date : c.end_date ? t.calculateEndDate({\n        start_date: c.end_date,\n        duration: -t.config.duration_step,\n        task: s\n      }) : u : u;\n    }\n    return t.assert(d, \"Invalid dates\"), new Date(d);\n  };\n  t._set_default_task_timing = function (s) {\n    s.start_date = s.start_date || e(s, t.getParent(s)), s.duration = s.duration || t.config.duration_step, s.end_date = s.end_date || t.calculateEndDate(s);\n  }, t.createTask = function (s, o, l) {\n    if (s = s || {}, t.defined(s.id) || (s.id = t.uid()), s.start_date || (s.start_date = e(s, o)), s.text === void 0 && (s.text = t.locale.labels.new_task), s.duration === void 0 && (s.duration = 1), this.isTaskExists(o)) {\n      this.setParent(s, o, !0);\n      var d = this.getTask(o);\n      d.$open = !0, this.config.details_on_create || this.callEvent(\"onAfterParentExpand\", [o, d]);\n    }\n    return this.callEvent(\"onTaskCreated\", [s]) ? (this.config.details_on_create ? (t.isTaskExists(s.id) ? t.getTask(s.id).$index != s.$index && (s.start_date && typeof s.start_date == \"string\" && (s.start_date = this.date.parseDate(s.start_date, \"parse_date\")), s.end_date && typeof s.end_date == \"string\" && (s.end_date = this.date.parseDate(s.end_date, \"parse_date\")), this.$data.tasksStore.updateItem(s.id, s)) : (s.$new = !0, this.silent(function () {\n      t.$data.tasksStore.addItem(s, l);\n    })), this.selectTask(s.id), this.refreshData(), this.showLightbox(s.id)) : this.addTask(s, o, l) && (this.showTask(s.id), this.selectTask(s.id)), s.id) : null;\n  }, t._update_flags = function (s, o) {\n    var l = t.$data.tasksStore;\n    s === void 0 ? (this._lightbox_id = null, l.silent(function () {\n      l.unselect();\n    }), this.getSelectedTasks && this._multiselect.reset(), this._tasks_dnd && this._tasks_dnd.drag && (this._tasks_dnd.drag.id = null)) : (this._lightbox_id == s && (this._lightbox_id = o), l.getSelectedId() == s && l.silent(function () {\n      l.unselect(s), l.select(o);\n    }), this._tasks_dnd && this._tasks_dnd.drag && this._tasks_dnd.drag.id == s && (this._tasks_dnd.drag.id = o));\n  };\n  var n = function (s, o) {\n    var l = t.getTaskType(s.type),\n      d = {\n        type: l,\n        $no_start: !1,\n        $no_end: !1,\n        scheduled_summary: !1\n      };\n    return l === t.config.types.project && s.auto_scheduling === !1 && (d.scheduled_summary = !0), o || l != s.$rendered_type ? (l == t.config.types.project ? d.$no_end = d.$no_start = !0 : l != t.config.types.milestone && (d.$no_end = !(s.end_date || s.duration), d.$no_start = !s.start_date, t._isAllowedUnscheduledTask(s) && (d.$no_end = d.$no_start = !1)), d) : (d.$no_start = s.$no_start, d.$no_end = s.$no_end, d);\n  };\n  function i(s) {\n    s.$effective_calendar = t.getTaskCalendar(s).id, s.start_date = t.getClosestWorkTime({\n      dir: \"future\",\n      date: s.start_date,\n      unit: t.config.duration_unit,\n      task: s\n    }), s.end_date = t.calculateEndDate(s);\n  }\n  function a(s, o, l, d) {\n    const c = {\n        start: \"start_date\",\n        end: \"end_date\"\n      },\n      u = {\n        start: \"$auto_start_date\",\n        end: \"$auto_end_date\"\n      };\n    let h;\n    h = s.type === t.config.types.project && s.auto_scheduling === !1 ? u : c, o.$no_start && (s[h.start] = l ? new Date(l) : e(s, this.getParent(s))), o.$no_end && (s[h.end] = d ? new Date(d) : this.calculateEndDate({\n      start_date: s[h.start],\n      duration: this.config.duration_step,\n      task: s\n    })), (o.$no_start || o.$no_end) && this._init_task_timing(s);\n  }\n  function r(s) {\n    var o = null,\n      l = null,\n      d = s !== void 0 ? s : t.config.root_id,\n      c = [];\n    return t.eachTask(function (u) {\n      const h = t.getTaskType(u.type) == t.config.types.project && u.auto_scheduling === !1;\n      t.getTaskType(u.type) == t.config.types.project && !h || t.isUnscheduledTask(u) || (u.rollup && c.push(u.id), !u.start_date || u.$no_start && !h || o && !(o > u.start_date.valueOf()) || (o = u.start_date.valueOf()), !u.end_date || u.$no_end && !h || l && !(l < u.end_date.valueOf()) || (l = u.end_date.valueOf()));\n    }, d), {\n      start_date: o ? new Date(o) : null,\n      end_date: l ? new Date(l) : null,\n      rollup: c\n    };\n  }\n  t._init_task_timing = function (s) {\n    var o = n(s, !0),\n      l = s.$rendered_type != o.type,\n      d = o.type;\n    l && (s.$no_start = o.$no_start, s.$no_end = o.$no_end, s.$rendered_type = o.type), l && d != this.config.types.milestone && d == this.config.types.project && (this._set_default_task_timing(s), s.$calculate_duration = !1), d == this.config.types.milestone && (s.end_date = s.start_date), s.start_date && s.end_date && s.$calculate_duration !== !1 && (s.duration = this.calculateDuration(s)), s.$calculate_duration || (s.$calculate_duration = !0), s.end_date || (s.end_date = s.start_date), s.duration = s.duration || 0, this.config.min_duration === 0 && s.duration === 0 && (s.$no_end = !1);\n    var c = this.getTaskCalendar(s);\n    s.$effective_calendar && s.$effective_calendar !== c.id && (i(s), this.config.inherit_calendar && this.isSummaryTask(s) && this.eachTask(function (u) {\n      i(u);\n    }, s.id)), s.$effective_calendar = c.id;\n  }, t.isSummaryTask = function (s) {\n    t.assert(s && s instanceof Object, \"Invalid argument <b>task</b>=\" + s + \" of gantt.isSummaryTask. Task object was expected\");\n    var o = n(s);\n    return !(!o.$no_end && !o.$no_start);\n  }, t.resetProjectDates = function (s) {\n    var o = n(s);\n    if (o.$no_end || o.$no_start) {\n      var l = r(s.id);\n      a.call(this, s, o, l.start_date, l.end_date), s.$rollup = l.rollup;\n    }\n  }, t.getSubtaskDuration = function (s) {\n    var o = 0,\n      l = s !== void 0 ? s : t.config.root_id;\n    return this.eachTask(function (d) {\n      this.getTaskType(d.type) == t.config.types.project || this.isUnscheduledTask(d) || (o += d.duration);\n    }, l), o;\n  }, t.getSubtaskDates = function (s) {\n    var o = r(s);\n    return {\n      start_date: o.start_date,\n      end_date: o.end_date\n    };\n  }, t._update_parents = function (s, o, l) {\n    if (s) {\n      var d = this.getTask(s);\n      d.rollup && (l = !0);\n      var c = this.getParent(d),\n        u = n(d),\n        h = !0;\n      if (l || d.start_date && d.end_date && (u.$no_start || u.$no_end)) {\n        const y = d.$auto_start_date ? \"$auto_start_date\" : \"start_date\",\n          v = d.$auto_end_date ? \"$auto_end_date\" : \"end_date\";\n        var g = d[y].valueOf(),\n          f = d[v].valueOf();\n        t.resetProjectDates(d), l || g != d[y].valueOf() || f != d[v].valueOf() || (h = !1), h && !o && this.refreshTask(d.id, !0), u.scheduled_summary && (h = !0);\n      }\n      h && c && this.isTaskExists(c) && this._update_parents(c, o, l);\n    }\n  }, t.roundDate = function (s) {\n    var o = t.getScale();\n    Z(s) && (s = {\n      date: s,\n      unit: o ? o.unit : t.config.duration_unit,\n      step: o ? o.step : t.config.duration_step\n    });\n    var l,\n      d,\n      c,\n      u = s.date,\n      h = s.step,\n      g = s.unit;\n    if (!o) return u;\n    if (g == o.unit && h == o.step && +u >= +o.min_date && +u <= +o.max_date) c = Math.floor(t.columnIndexByDate(u)), o.trace_x[c] || (c -= 1, o.rtl && (c = 0)), d = new Date(o.trace_x[c]), l = t.date.add(d, h, g);else {\n      for (c = Math.floor(t.columnIndexByDate(u)), l = t.date[g + \"_start\"](new Date(o.min_date)), o.trace_x[c] && (l = t.date[g + \"_start\"](o.trace_x[c])); +l < +u;) {\n        var f = (l = t.date[g + \"_start\"](t.date.add(l, h, g))).getTimezoneOffset();\n        l = t._correct_dst_change(l, f, l, g), t.date[g + \"_start\"] && (l = t.date[g + \"_start\"](l));\n      }\n      d = t.date.add(l, -1 * h, g);\n    }\n    return s.dir && s.dir == \"future\" ? l : s.dir && s.dir == \"past\" || Math.abs(u - d) < Math.abs(l - u) ? d : l;\n  }, t.correctTaskWorkTime = function (s) {\n    t.config.work_time && t.config.correct_work_time && (this.isWorkTime(s.start_date, void 0, s) ? this.isWorkTime(new Date(+s.end_date - 1), void 0, s) || (s.end_date = this.calculateEndDate(s)) : (s.start_date = this.getClosestWorkTime({\n      date: s.start_date,\n      dir: \"future\",\n      task: s\n    }), s.end_date = this.calculateEndDate(s)));\n  }, t.attachEvent(\"onBeforeTaskUpdate\", function (s, o) {\n    return t._init_task_timing(o), !0;\n  }), t.attachEvent(\"onBeforeTaskAdd\", function (s, o) {\n    return t._init_task_timing(o), !0;\n  }), t.attachEvent(\"onAfterTaskMove\", function (s, o, l) {\n    return t._init_task_timing(t.getTask(s)), !0;\n  });\n}\nfunction ze(t, e) {\n  var n,\n    i = t.config.container_resize_timeout || 20;\n  let a = We(t);\n  if (t.config.container_resize_method == \"timeout\") l();else try {\n    t.event(e, \"resize\", function () {\n      if (t.$scrollbarRepaint) t.$scrollbarRepaint = null;else {\n        let d = We(t);\n        if (a.x == d.x && a.y == d.y) return;\n        a = d, r();\n      }\n    });\n  } catch {\n    l();\n  }\n  function r() {\n    clearTimeout(n), n = setTimeout(function () {\n      t.$destroyed || t.render();\n    }, i);\n  }\n  var s = t.$root.offsetHeight,\n    o = t.$root.offsetWidth;\n  function l() {\n    t.$root.offsetHeight == s && t.$root.offsetWidth == o || r(), s = t.$root.offsetHeight, o = t.$root.offsetWidth, setTimeout(l, i);\n  }\n}\nfunction We(t) {\n  return {\n    x: t.$root.offsetWidth,\n    y: t.$root.offsetHeight\n  };\n}\nfunction Ci(t) {\n  t.assert = /* @__PURE__ */function (r) {\n    return function (s, o) {\n      s || r.config.show_errors && r.callEvent(\"onError\", [o]) !== !1 && (r.message ? r.message({\n        type: \"error\",\n        text: o,\n        expire: -1\n      }) : console.log(o));\n    };\n  }(t);\n  var e = \"Invalid value of the first argument of `gantt.init`. Supported values: HTMLElement, String (element id).This error means that either invalid object is passed into `gantt.init` or that the element with the specified ID doesn't exist on the page when `gantt.init` is called.\";\n  function n(r) {\n    if (!r || typeof r == \"string\" && document.getElementById(r) || function (s) {\n      try {\n        s.cloneNode(!1);\n      } catch {\n        return !1;\n      }\n      return !0;\n    }(r)) return !0;\n    throw t.assert(!1, e), new Error(e);\n  }\n  t.init = function (r, s, o) {\n    t.env.isNode ? r = null : n(r), s && o && (this.config.start_date = this._min_date = new Date(s), this.config.end_date = this._max_date = new Date(o)), this.date.init(), this.init = function (l) {\n      t.env.isNode ? l = null : n(l), this.$container && this.$container.parentNode && (this.$container.parentNode.removeChild(this.$container), this.$container = null), this.$layout && this.$layout.clear(), this._reinit(l);\n    }, this._reinit(r);\n  }, t._quickRefresh = function (r) {\n    for (var s = this._getDatastores.call(this), o = 0; o < s.length; o++) s[o]._quick_refresh = !0;\n    for (r(), o = 0; o < s.length; o++) s[o]._quick_refresh = !1;\n  };\n  var i = function () {\n      this._clearTaskLayers && this._clearTaskLayers(), this._clearLinkLayers && this._clearLinkLayers(), this.$layout && (this.$layout.destructor(), this.$layout = null, this.$ui.reset());\n    }.bind(t),\n    a = function () {\n      V(t) || (this.$root.innerHTML = \"\", this.$root.gantt = this, me(this), this.config.layout.id = \"main\", this.$layout = this.$ui.createView(\"layout\", this.$root, this.config.layout), this.$layout.attachEvent(\"onBeforeResize\", function () {\n        for (var r = t.$services.getService(\"datastores\"), s = 0; s < r.length; s++) t.getDatastore(r[s]).filter(), t.$data.tasksStore._skipTaskRecalculation ? t.$data.tasksStore._skipTaskRecalculation != \"lightbox\" && (t.$data.tasksStore._skipTaskRecalculation = !1) : t.getDatastore(r[s]).callEvent(\"onBeforeRefreshAll\", []);\n      }), this.$layout.attachEvent(\"onResize\", function () {\n        t._quickRefresh(function () {\n          t.refreshData();\n        });\n      }), this.callEvent(\"onGanttLayoutReady\", []), this.$layout.render(), this.$container = this.$layout.$container.firstChild, function (r) {\n        window.getComputedStyle(r.$root).getPropertyValue(\"position\") == \"static\" && (r.$root.style.position = \"relative\");\n        var s = document.createElement(\"iframe\");\n        s.className = \"gantt_container_resize_watcher\", s.tabIndex = -1, r.config.wai_aria_attributes && (s.setAttribute(\"role\", \"none\"), s.setAttribute(\"aria-hidden\", !0)), (window.Sfdc || window.$A || window.Aura) && (r.config.container_resize_method = \"timeout\"), r.$root.appendChild(s), s.contentWindow ? ze(r, s.contentWindow) : (r.$root.removeChild(s), ze(r, window));\n      }(this));\n    }.bind(t);\n  t.resetLayout = function () {\n    i(), a(), this.render();\n  }, t._reinit = function (r) {\n    this.callEvent(\"onBeforeGanttReady\", []), this._update_flags(), this.$services.getService(\"templateLoader\").initTemplates(this), i(), this.$root = null, r && (this.$root = we(r), a(), this.$mouseEvents.reset(this.$root), function (s) {\n      s.$container && !s.config.autosize && s.$root.offsetHeight < 50 && console.warn(`The Gantt container has a small height, so you cannot see its content. If it is not intended, you need to set the 'height' style rule to the container:\nhttps://docs.dhtmlx.com/gantt/faq.html#theganttchartisntrenderedcorrectly`);\n    }(t)), this.callEvent(\"onTemplatesReady\", []), this.callEvent(\"onGanttReady\", []), this.render();\n  }, t.$click = {\n    buttons: {\n      edit: function (r) {\n        t.isReadonly(t.getTask(r)) || t.showLightbox(r);\n      },\n      delete: function (r) {\n        var s = t.getTask(r);\n        if (!t.isReadonly(s)) {\n          var o = t.locale.labels.confirm_deleting,\n            l = t.locale.labels.confirm_deleting_title;\n          t._simple_confirm(o, l, function () {\n            t.isTaskExists(r) && (s.$new ? (t.$data.tasksStore._skipTaskRecalculation = \"lightbox\", t.silent(function () {\n              t.deleteTask(r, !0);\n            }), t.$data.tasksStore._skipTaskRecalculation = !1, t.refreshData()) : (t.$data.tasksStore._skipTaskRecalculation = !0, t.deleteTask(r))), t.hideLightbox();\n          });\n        }\n      }\n    }\n  }, t.render = function () {\n    var r;\n    if (this.callEvent(\"onBeforeGanttRender\", []), !V(t)) {\n      !this.config.sort && this._sort && (this._sort = void 0), this.$root && (this.config.rtl ? (this.$root.classList.add(\"gantt_rtl\"), this.$root.firstChild.classList.add(\"gantt_rtl\")) : (this.$root.classList.remove(\"gantt_rtl\"), this.$root.firstChild.classList.remove(\"gantt_rtl\")));\n      var s = this.getScrollState(),\n        o = s ? s.x : 0;\n      this._getHorizontalScrollbar() && (o = this._getHorizontalScrollbar().$config.codeScrollLeft || o || 0), r = null, o && (r = t.dateFromPos(o + this.config.task_scroll_offset));\n    }\n    if (me(this), V(t)) t.refreshData();else {\n      this.$layout.$config.autosize = this.config.autosize;\n      var l = this.config.preserve_scroll;\n      if (this.config.preserve_scroll = !1, this.$layout.resize(), this.config.preserve_scroll = l, this.config.preserve_scroll && s) {\n        if (o || s.y) {\n          var d = t.getScrollState();\n          if (+r != +t.dateFromPos(d.x) || d.y != s.y) {\n            o = null;\n            var c = null;\n            r && (o = Math.max(t.posFromDate(r) - t.config.task_scroll_offset, 0)), s.y && (c = s.y), t.scrollTo(o, c);\n          }\n        }\n        this.$layout.getScrollbarsInfo().forEach(u => {\n          const h = t.$ui.getView(u.id),\n            g = t.utils.dom.isChildOf(h.$view, t.$container);\n          u.boundViews.forEach(f => {\n            const y = t.$ui.getView(f);\n            u.y && u.y != s.y && y && !g && y.scrollTo(void 0, 0), u.x_pos && u.x_pos != s.x && y && g && y.scrollTo(u.x_pos, void 0);\n          });\n        });\n      }\n    }\n    this.callEvent(\"onGanttRender\", []);\n  }, t.setSizes = t.render, t.getTaskRowNode = function (r) {\n    for (var s = this.$grid_data.childNodes, o = this.config.task_attribute, l = 0; l < s.length; l++) if (s[l].getAttribute && s[l].getAttribute(o) == r) return s[l];\n    return null;\n  }, t.changeLightboxType = function (r) {\n    if (this.getLightboxType() == r) return !0;\n    t._silent_redraw_lightbox(r);\n  }, t._get_link_type = function (r, s) {\n    var o = null;\n    return r && s ? o = t.config.links.start_to_start : !r && s ? o = t.config.links.finish_to_start : r || s ? r && !s && (o = t.config.links.start_to_finish) : o = t.config.links.finish_to_finish, o;\n  }, t.isLinkAllowed = function (r, s, o, l) {\n    var d = null;\n    if (!(d = typeof r == \"object\" ? r : {\n      source: r,\n      target: s,\n      type: this._get_link_type(o, l)\n    }) || !(d.source && d.target && d.type) || d.source == d.target) return !1;\n    var c = !0;\n    return this.checkEvent(\"onLinkValidation\") && (c = this.callEvent(\"onLinkValidation\", [d])), c;\n  }, t._correct_dst_change = function (r, s, o, l) {\n    var d = Vt(l) * o;\n    if (d > 3600 && d < 86400) {\n      var c = r.getTimezoneOffset() - s;\n      c && (r = t.date.add(r, c, \"minute\"));\n    }\n    return r;\n  }, t.isSplitTask = function (r) {\n    return t.assert(r && r instanceof Object, \"Invalid argument <b>task</b>=\" + r + \" of gantt.isSplitTask. Task object was expected\"), this.$data.tasksStore._isSplitItem(r);\n  }, t._is_icon_open_click = function (r) {\n    if (!r) return !1;\n    var s = r.target || r.srcElement;\n    if (!s || !s.className) return !1;\n    var o = X(s);\n    return o.indexOf(\"gantt_tree_icon\") !== -1 && (o.indexOf(\"gantt_close\") !== -1 || o.indexOf(\"gantt_open\") !== -1);\n  };\n}\nconst Di = {\n    date: {\n      month_full: [\"كانون الثاني\", \"شباط\", \"آذار\", \"نيسان\", \"أيار\", \"حزيران\", \"تموز\", \"آب\", \"أيلول\", \"تشرين الأول\", \"تشرين الثاني\", \"كانون الأول\"],\n      month_short: [\"يناير\", \"فبراير\", \"مارس\", \"أبريل\", \"مايو\", \"يونيو\", \"يوليو\", \"أغسطس\", \"سبتمبر\", \"أكتوبر\", \"نوفمبر\", \"ديسمبر\"],\n      day_full: [\"الأحد\", \"الأثنين\", \"ألثلاثاء\", \"الأربعاء\", \"ألحميس\", \"ألجمعة\", \"السبت\"],\n      day_short: [\"احد\", \"اثنين\", \"ثلاثاء\", \"اربعاء\", \"خميس\", \"جمعة\", \"سبت\"]\n    },\n    labels: {\n      new_task: \"مهمة جديد\",\n      icon_save: \"اخزن\",\n      icon_cancel: \"الغاء\",\n      icon_details: \"تفاصيل\",\n      icon_edit: \"تحرير\",\n      icon_delete: \"حذف\",\n      confirm_closing: \"التغييرات سوف تضيع, هل انت متأكد؟\",\n      confirm_deleting: \"الحدث سيتم حذفها نهائيا ، هل أنت متأكد؟\",\n      section_description: \"الوصف\",\n      section_time: \"الفترة الزمنية\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"الغاء\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Ai = {\n    date: {\n      month_full: [\"Студзень\", \"Люты\", \"Сакавік\", \"Красавік\", \"Maй\", \"Чэрвень\", \"Ліпень\", \"Жнівень\", \"Верасень\", \"Кастрычнік\", \"Лістапад\", \"Снежань\"],\n      month_short: [\"Студз\", \"Лют\", \"Сак\", \"Крас\", \"Maй\", \"Чэр\", \"Ліп\", \"Жнів\", \"Вер\", \"Каст\", \"Ліст\", \"Снеж\"],\n      day_full: [\"Нядзеля\", \"Панядзелак\", \"Аўторак\", \"Серада\", \"Чацвер\", \"Пятніца\", \"Субота\"],\n      day_short: [\"Нд\", \"Пн\", \"Аўт\", \"Ср\", \"Чцв\", \"Пт\", \"Сб\"]\n    },\n    labels: {\n      new_task: \"Новае заданне\",\n      icon_save: \"Захаваць\",\n      icon_cancel: \"Адмяніць\",\n      icon_details: \"Дэталі\",\n      icon_edit: \"Змяніць\",\n      icon_delete: \"Выдаліць\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Падзея будзе выдалена незваротна, працягнуць?\",\n      section_description: \"Апісанне\",\n      section_time: \"Перыяд часу\",\n      section_type: \"Тып\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"ІСР\",\n      column_text: \"Задача\",\n      column_start_date: \"Пачатак\",\n      column_duration: \"Працяг\",\n      column_add: \"\",\n      link: \"Сувязь\",\n      confirm_link_deleting: \"будзе выдалена\",\n      link_start: \"(пачатак)\",\n      link_end: \"(канец)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Хвiлiна\",\n      hours: \"Гадзiна\",\n      days: \"Дзень\",\n      weeks: \"Тыдзень\",\n      months: \"Месяц\",\n      years: \"Год\",\n      message_ok: \"OK\",\n      message_cancel: \"Адмяніць\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Ii = {\n    date: {\n      month_full: [\"Gener\", \"Febrer\", \"Març\", \"Abril\", \"Maig\", \"Juny\", \"Juliol\", \"Agost\", \"Setembre\", \"Octubre\", \"Novembre\", \"Desembre\"],\n      month_short: [\"Gen\", \"Feb\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Oct\", \"Nov\", \"Des\"],\n      day_full: [\"Diumenge\", \"Dilluns\", \"Dimarts\", \"Dimecres\", \"Dijous\", \"Divendres\", \"Dissabte\"],\n      day_short: [\"Dg\", \"Dl\", \"Dm\", \"Dc\", \"Dj\", \"Dv\", \"Ds\"]\n    },\n    labels: {\n      new_task: \"Nova tasca\",\n      icon_save: \"Guardar\",\n      icon_cancel: \"Cancel·lar\",\n      icon_details: \"Detalls\",\n      icon_edit: \"Editar\",\n      icon_delete: \"Esborrar\",\n      confirm_closing: \"\",\n      confirm_deleting: \"L'esdeveniment s'esborrarà definitivament, continuar ?\",\n      section_description: \"Descripció\",\n      section_time: \"Periode de temps\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"Cancel·lar\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Mi = {\n    date: {\n      month_full: [\"一月\", \"二月\", \"三月\", \"四月\", \"五月\", \"六月\", \"七月\", \"八月\", \"九月\", \"十月\", \"十一月\", \"十二月\"],\n      month_short: [\"1月\", \"2月\", \"3月\", \"4月\", \"5月\", \"6月\", \"7月\", \"8月\", \"9月\", \"10月\", \"11月\", \"12月\"],\n      day_full: [\"星期日\", \"星期一\", \"星期二\", \"星期三\", \"星期四\", \"星期五\", \"星期六\"],\n      day_short: [\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"]\n    },\n    labels: {\n      new_task: \"新任務\",\n      icon_save: \"保存\",\n      icon_cancel: \"关闭\",\n      icon_details: \"详细\",\n      icon_edit: \"编辑\",\n      icon_delete: \"删除\",\n      confirm_closing: \"请确认是否撤销修改!\",\n      confirm_deleting: \"是否删除日程?\",\n      section_description: \"描述\",\n      section_time: \"时间范围\",\n      section_type: \"类型\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"工作分解结构\",\n      column_text: \"任务名\",\n      column_start_date: \"开始时间\",\n      column_duration: \"持续时间\",\n      column_add: \"\",\n      link: \"关联\",\n      confirm_link_deleting: \"将被删除\",\n      link_start: \" (开始)\",\n      link_end: \" (结束)\",\n      type_task: \"任务\",\n      type_project: \"项目\",\n      type_milestone: \"里程碑\",\n      minutes: \"分钟\",\n      hours: \"小时\",\n      days: \"天\",\n      weeks: \"周\",\n      months: \"月\",\n      years: \"年\",\n      message_ok: \"OK\",\n      message_cancel: \"关闭\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Ni = {\n    date: {\n      month_full: [\"Leden\", \"Únor\", \"Březen\", \"Duben\", \"Květen\", \"Červen\", \"Červenec\", \"Srpen\", \"Září\", \"Říjen\", \"Listopad\", \"Prosinec\"],\n      month_short: [\"Led\", \"Ún\", \"Bře\", \"Dub\", \"Kvě\", \"Čer\", \"Čec\", \"Srp\", \"Září\", \"Říj\", \"List\", \"Pro\"],\n      day_full: [\"Neděle\", \"Pondělí\", \"Úterý\", \"Středa\", \"Čtvrtek\", \"Pátek\", \"Sobota\"],\n      day_short: [\"Ne\", \"Po\", \"Út\", \"St\", \"Čt\", \"Pá\", \"So\"]\n    },\n    labels: {\n      new_task: \"Nová práce\",\n      icon_save: \"Uložit\",\n      icon_cancel: \"Zpět\",\n      icon_details: \"Detail\",\n      icon_edit: \"Edituj\",\n      icon_delete: \"Smazat\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Událost bude trvale smazána, opravdu?\",\n      section_description: \"Poznámky\",\n      section_time: \"Doba platnosti\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"Zpět\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Li = {\n    date: {\n      month_full: [\"Januar\", \"Februar\", \"Marts\", \"April\", \"Maj\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"December\"],\n      month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Maj\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dec\"],\n      day_full: [\"Søndag\", \"Mandag\", \"Tirsdag\", \"Onsdag\", \"Torsdag\", \"Fredag\", \"Lørdag\"],\n      day_short: [\"Søn\", \"Man\", \"Tir\", \"Ons\", \"Tor\", \"Fre\", \"Lør\"]\n    },\n    labels: {\n      new_task: \"Ny opgave\",\n      icon_save: \"Gem\",\n      icon_cancel: \"Fortryd\",\n      icon_details: \"Detaljer\",\n      icon_edit: \"Tilret\",\n      icon_delete: \"Slet\",\n      confirm_closing: \"Dine rettelser vil gå tabt.. Er dy sikker?\",\n      confirm_deleting: \"Bigivenheden vil blive slettet permanent. Er du sikker?\",\n      section_description: \"Beskrivelse\",\n      section_time: \"Tidsperiode\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"Fortryd\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Pi = {\n    date: {\n      month_full: [\" Januar\", \" Februar\", \" März \", \" April\", \" Mai\", \" Juni\", \" Juli\", \" August\", \" September \", \" Oktober\", \" November \", \" Dezember\"],\n      month_short: [\"Jan\", \"Feb\", \"Mär\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\"],\n      day_full: [\"Sonntag\", \"Montag\", \"Dienstag\", \" Mittwoch\", \" Donnerstag\", \"Freitag\", \"Samstag\"],\n      day_short: [\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"]\n    },\n    labels: {\n      new_task: \"Neue Aufgabe\",\n      icon_save: \"Speichern\",\n      icon_cancel: \"Abbrechen\",\n      icon_details: \"Details\",\n      icon_edit: \"Ändern\",\n      icon_delete: \"Löschen\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Der Eintrag wird gelöscht\",\n      section_description: \"Beschreibung\",\n      section_time: \"Zeitspanne\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"PSP\",\n      column_text: \"Task-Namen\",\n      column_start_date: \"Startzeit\",\n      column_duration: \"Dauer\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"werden gelöscht\",\n      link_start: \"(starten)\",\n      link_end: \"(ende)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minuten\",\n      hours: \"Stunden\",\n      days: \"Tage\",\n      weeks: \"Wochen\",\n      months: \"Monate\",\n      years: \"Jahre\",\n      message_ok: \"OK\",\n      message_cancel: \"Abbrechen\",\n      section_constraint: \"Regel\",\n      constraint_type: \"Regel\",\n      constraint_date: \"Regel - Datum\",\n      asap: \"So bald wie möglich\",\n      alap: \"So spät wie möglich\",\n      snet: \"Beginn nicht vor\",\n      snlt: \"Beginn nicht später als\",\n      fnet: \"Fertigstellung nicht vor\",\n      fnlt: \"Fertigstellung nicht später als\",\n      mso: \"Muss beginnen am\",\n      mfo: \"Muss fertig sein am\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Ri = {\n    date: {\n      month_full: [\"Ιανουάριος\", \"Φεβρουάριος\", \"Μάρτιος\", \"Απρίλιος\", \"Μάϊος\", \"Ιούνιος\", \"Ιούλιος\", \"Αύγουστος\", \"Σεπτέμβριος\", \"Οκτώβριος\", \"Νοέμβριος\", \"Δεκέμβριος\"],\n      month_short: [\"ΙΑΝ\", \"ΦΕΒ\", \"ΜΑΡ\", \"ΑΠΡ\", \"ΜΑΙ\", \"ΙΟΥΝ\", \"ΙΟΥΛ\", \"ΑΥΓ\", \"ΣΕΠ\", \"ΟΚΤ\", \"ΝΟΕ\", \"ΔΕΚ\"],\n      day_full: [\"Κυριακή\", \"Δευτέρα\", \"Τρίτη\", \"Τετάρτη\", \"Πέμπτη\", \"Παρασκευή\", \"Κυριακή\"],\n      day_short: [\"ΚΥ\", \"ΔΕ\", \"ΤΡ\", \"ΤΕ\", \"ΠΕ\", \"ΠΑ\", \"ΣΑ\"]\n    },\n    labels: {\n      new_task: \"Νέα εργασία\",\n      icon_save: \"Αποθήκευση\",\n      icon_cancel: \"Άκυρο\",\n      icon_details: \"Λεπτομέρειες\",\n      icon_edit: \"Επεξεργασία\",\n      icon_delete: \"Διαγραφή\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Το έργο θα διαγραφεί οριστικά. Θέλετε να συνεχίσετε;\",\n      section_description: \"Περιγραφή\",\n      section_time: \"Χρονική περίοδος\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"Άκυρο\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Hi = {\n    date: {\n      month_full: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n      month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n      day_full: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n      day_short: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"]\n    },\n    labels: {\n      new_task: \"New task\",\n      icon_save: \"Save\",\n      icon_cancel: \"Cancel\",\n      icon_details: \"Details\",\n      icon_edit: \"Edit\",\n      icon_delete: \"Delete\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Task will be deleted permanently, are you sure?\",\n      section_description: \"Description\",\n      section_time: \"Time period\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"Cancel\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Oi = {\n    date: {\n      month_full: [\"Enero\", \"Febrero\", \"Marzo\", \"Abril\", \"Mayo\", \"Junio\", \"Julio\", \"Agosto\", \"Septiembre\", \"Octubre\", \"Noviembre\", \"Diciembre\"],\n      month_short: [\"Ene\", \"Feb\", \"Mar\", \"Abr\", \"May\", \"Jun\", \"Jul\", \"Ago\", \"Sep\", \"Oct\", \"Nov\", \"Dic\"],\n      day_full: [\"Domingo\", \"Lunes\", \"Martes\", \"Miércoles\", \"Jueves\", \"Viernes\", \"Sábado\"],\n      day_short: [\"Dom\", \"Lun\", \"Mar\", \"Mié\", \"Jue\", \"Vie\", \"Sáb\"]\n    },\n    labels: {\n      new_task: \"Nueva tarea\",\n      icon_save: \"Guardar\",\n      icon_cancel: \"Cancelar\",\n      icon_details: \"Detalles\",\n      icon_edit: \"Editar\",\n      icon_delete: \"Eliminar\",\n      confirm_closing: \"\",\n      confirm_deleting: \"El evento se borrará definitivamente, ¿continuar?\",\n      section_description: \"Descripción\",\n      section_time: \"Período\",\n      section_type: \"Tipo\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"EDT\",\n      column_text: \"Tarea\",\n      column_start_date: \"Inicio\",\n      column_duration: \"Duración\",\n      column_add: \"\",\n      link: \"Enlace\",\n      confirm_link_deleting: \"será borrada\",\n      link_start: \" (inicio)\",\n      link_end: \" (fin)\",\n      type_task: \"Tarea\",\n      type_project: \"Proyecto\",\n      type_milestone: \"Hito\",\n      minutes: \"Minutos\",\n      hours: \"Horas\",\n      days: \"Días\",\n      weeks: \"Semanas\",\n      months: \"Meses\",\n      years: \"Años\",\n      message_ok: \"OK\",\n      message_cancel: \"Cancelar\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Bi = {\n    date: {\n      month_full: [\"ژانویه\", \"فوریه\", \"مارس\", \"آوریل\", \"مه\", \"ژوئن\", \"ژوئیه\", \"اوت\", \"سپتامبر\", \"اکتبر\", \"نوامبر\", \"دسامبر\"],\n      month_short: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"],\n      day_full: [\"يکشنبه\", \"دوشنبه\", \"سه‌شنبه\", \"چهارشنبه\", \"پنجشنبه\", \"جمعه\", \"شنبه\"],\n      day_short: [\"ی\", \"د\", \"س\", \"چ\", \"پ\", \"ج\", \"ش\"]\n    },\n    labels: {\n      new_task: \"وظیفه جدید\",\n      icon_save: \"ذخیره\",\n      icon_cancel: \"لغو\",\n      icon_details: \"جزییات\",\n      icon_edit: \"ویرایش\",\n      icon_delete: \"حذف\",\n      confirm_closing: \"تغییرات شما ازدست خواهد رفت، آیا مطمئن هستید؟\",\n      confirm_deleting: \"این مورد برای همیشه حذف خواهد شد، آیا مطمئن هستید؟\",\n      section_description: \"توضیحات\",\n      section_time: \"مدت زمان\",\n      section_type: \"نوع\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"عنوان\",\n      column_start_date: \"زمان شروع\",\n      column_duration: \"مدت\",\n      column_add: \"\",\n      link: \"ارتباط\",\n      confirm_link_deleting: \"حذف خواهد شد\",\n      link_start: \" (آغاز)\",\n      link_end: \" (پایان)\",\n      type_task: \"وظیفه\",\n      type_project: \"پروژه\",\n      type_milestone: \"نگارش\",\n      minutes: \"دقایق\",\n      hours: \"ساعات\",\n      days: \"روزها\",\n      weeks: \"هفته\",\n      months: \"ماه‌ها\",\n      years: \"سال‌ها\",\n      message_ok: \"تایید\",\n      message_cancel: \"لغو\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  zi = {\n    date: {\n      month_full: [\"Tammikuu\", \"Helmikuu\", \"Maaliskuu\", \"Huhtikuu\", \"Toukokuu\", \"Kes&auml;kuu\", \"Hein&auml;kuu\", \"Elokuu\", \"Syyskuu\", \"Lokakuu\", \"Marraskuu\", \"Joulukuu\"],\n      month_short: [\"Tam\", \"Hel\", \"Maa\", \"Huh\", \"Tou\", \"Kes\", \"Hei\", \"Elo\", \"Syy\", \"Lok\", \"Mar\", \"Jou\"],\n      day_full: [\"Sunnuntai\", \"Maanantai\", \"Tiistai\", \"Keskiviikko\", \"Torstai\", \"Perjantai\", \"Lauantai\"],\n      day_short: [\"Su\", \"Ma\", \"Ti\", \"Ke\", \"To\", \"Pe\", \"La\"]\n    },\n    labels: {\n      new_task: \"Uusi tehtävä\",\n      icon_save: \"Tallenna\",\n      icon_cancel: \"Peru\",\n      icon_details: \"Tiedot\",\n      icon_edit: \"Muokkaa\",\n      icon_delete: \"Poista\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Haluatko varmasti poistaa tapahtuman?\",\n      section_description: \"Kuvaus\",\n      section_time: \"Aikajakso\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"Peru\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Wi = {\n    date: {\n      month_full: [\"Janvier\", \"Février\", \"Mars\", \"Avril\", \"Mai\", \"Juin\", \"Juillet\", \"Août\", \"Septembre\", \"Octobre\", \"Novembre\", \"Décembre\"],\n      month_short: [\"Jan\", \"Fév\", \"Mar\", \"Avr\", \"Mai\", \"Juin\", \"Juil\", \"Aoû\", \"Sep\", \"Oct\", \"Nov\", \"Déc\"],\n      day_full: [\"Dimanche\", \"Lundi\", \"Mardi\", \"Mercredi\", \"Jeudi\", \"Vendredi\", \"Samedi\"],\n      day_short: [\"Dim\", \"Lun\", \"Mar\", \"Mer\", \"Jeu\", \"Ven\", \"Sam\"]\n    },\n    labels: {\n      new_task: \"Nouvelle tâche\",\n      icon_save: \"Enregistrer\",\n      icon_cancel: \"Annuler\",\n      icon_details: \"Détails\",\n      icon_edit: \"Modifier\",\n      icon_delete: \"Effacer\",\n      confirm_closing: \"\",\n      confirm_deleting: \"L'événement sera effacé sans appel, êtes-vous sûr ?\",\n      section_description: \"Description\",\n      section_time: \"Période\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"OTP\",\n      column_text: \"Nom de la tâche\",\n      column_start_date: \"Date initiale\",\n      column_duration: \"Durée\",\n      column_add: \"\",\n      link: \"Le lien\",\n      confirm_link_deleting: \"sera supprimé\",\n      link_start: \"(début)\",\n      link_end: \"(fin)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Heures\",\n      days: \"Jours\",\n      weeks: \"Semaines\",\n      months: \"Mois\",\n      years: \"Années\",\n      message_ok: \"OK\",\n      message_cancel: \"Annuler\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  ji = {\n    date: {\n      month_full: [\"ינואר\", \"פברואר\", \"מרץ\", \"אפריל\", \"מאי\", \"יוני\", \"יולי\", \"אוגוסט\", \"ספטמבר\", \"אוקטובר\", \"נובמבר\", \"דצמבר\"],\n      month_short: [\"ינו\", \"פבר\", \"מרץ\", \"אפר\", \"מאי\", \"יונ\", \"יול\", \"אוג\", \"ספט\", \"אוק\", \"נוב\", \"דצמ\"],\n      day_full: [\"ראשון\", \"שני\", \"שלישי\", \"רביעי\", \"חמישי\", \"שישי\", \"שבת\"],\n      day_short: [\"א\", \"ב\", \"ג\", \"ד\", \"ה\", \"ו\", \"ש\"]\n    },\n    labels: {\n      new_task: \"משימה חדש\",\n      icon_save: \"שמור\",\n      icon_cancel: \"בטל\",\n      icon_details: \"פרטים\",\n      icon_edit: \"ערוך\",\n      icon_delete: \"מחק\",\n      confirm_closing: \"\",\n      confirm_deleting: \"ארוע ימחק סופית.להמשיך?\",\n      section_description: \"הסבר\",\n      section_time: \"תקופה\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"בטל\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Fi = {\n    date: {\n      month_full: [\"Siječanj\", \"Veljača\", \"Ožujak\", \"Travanj\", \"Svibanj\", \"Lipanj\", \"Srpanj\", \"Kolovoz\", \"Rujan\", \"Listopad\", \"Studeni\", \"Prosinac\"],\n      month_short: [\"Sij\", \"Velj\", \"Ožu\", \"Tra\", \"Svi\", \"Lip\", \"Srp\", \"Kol\", \"Ruj\", \"Lis\", \"Stu\", \"Pro\"],\n      day_full: [\"Nedjelja\", \"Ponedjeljak\", \"Utorak\", \"Srijeda\", \"Četvrtak\", \"Petak\", \"Subota\"],\n      day_short: [\"Ned\", \"Pon\", \"Uto\", \"Sri\", \"Čet\", \"Pet\", \"Sub\"]\n    },\n    labels: {\n      new_task: \"Novi Zadatak\",\n      icon_save: \"Spremi\",\n      icon_cancel: \"Odustani\",\n      icon_details: \"Detalji\",\n      icon_edit: \"Izmjeni\",\n      icon_delete: \"Obriši\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Zadatak će biti trajno izbrisan, jeste li sigurni?\",\n      section_description: \"Opis\",\n      section_time: \"Vremenski Period\",\n      section_type: \"Tip\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Naziv Zadatka\",\n      column_start_date: \"Početno Vrijeme\",\n      column_duration: \"Trajanje\",\n      column_add: \"\",\n      link: \"Poveznica\",\n      confirm_link_deleting: \"će biti izbrisan\",\n      link_start: \" (početak)\",\n      link_end: \" (kraj)\",\n      type_task: \"Zadatak\",\n      type_project: \"Projekt\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minute\",\n      hours: \"Sati\",\n      days: \"Dani\",\n      weeks: \"Tjedni\",\n      months: \"Mjeseci\",\n      years: \"Godine\",\n      message_ok: \"OK\",\n      message_cancel: \"Odustani\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Vi = {\n    date: {\n      month_full: [\"Január\", \"Február\", \"Március\", \"Április\", \"Május\", \"Június\", \"Július\", \"Augusztus\", \"Szeptember\", \"Október\", \"November\", \"December\"],\n      month_short: [\"Jan\", \"Feb\", \"Már\", \"Ápr\", \"Máj\", \"Jún\", \"Júl\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dec\"],\n      day_full: [\"Vasárnap\", \"Hétfõ\", \"Kedd\", \"Szerda\", \"Csütörtök\", \"Péntek\", \"szombat\"],\n      day_short: [\"Va\", \"Hé\", \"Ke\", \"Sze\", \"Csü\", \"Pé\", \"Szo\"]\n    },\n    labels: {\n      new_task: \"Új feladat\",\n      icon_save: \"Mentés\",\n      icon_cancel: \"Mégse\",\n      icon_details: \"Részletek\",\n      icon_edit: \"Szerkesztés\",\n      icon_delete: \"Törlés\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Az esemény törölve lesz, biztosan folytatja?\",\n      section_description: \"Leírás\",\n      section_time: \"Idõszak\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"Mégse\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Ui = {\n    date: {\n      month_full: [\"Januari\", \"Februari\", \"Maret\", \"April\", \"Mei\", \"Juni\", \"Juli\", \"Agustus\", \"September\", \"Oktober\", \"November\", \"Desember\"],\n      month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Mei\", \"Jun\", \"Jul\", \"Ags\", \"Sep\", \"Okt\", \"Nov\", \"Des\"],\n      day_full: [\"Minggu\", \"Senin\", \"Selasa\", \"Rabu\", \"Kamis\", \"Jumat\", \"Sabtu\"],\n      day_short: [\"Ming\", \"Sen\", \"Sel\", \"Rab\", \"Kam\", \"Jum\", \"Sab\"]\n    },\n    labels: {\n      new_task: \"Tugas baru\",\n      icon_save: \"Simpan\",\n      icon_cancel: \"Batal\",\n      icon_details: \"Detail\",\n      icon_edit: \"Edit\",\n      icon_delete: \"Hapus\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Acara akan dihapus\",\n      section_description: \"Keterangan\",\n      section_time: \"Periode\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"Batal\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  qi = {\n    date: {\n      month_full: [\"Gennaio\", \"Febbraio\", \"Marzo\", \"Aprile\", \"Maggio\", \"Giugno\", \"Luglio\", \"Agosto\", \"Settembre\", \"Ottobre\", \"Novembre\", \"Dicembre\"],\n      month_short: [\"Gen\", \"Feb\", \"Mar\", \"Apr\", \"Mag\", \"Giu\", \"Lug\", \"Ago\", \"Set\", \"Ott\", \"Nov\", \"Dic\"],\n      day_full: [\"Domenica\", \"Lunedì\", \"Martedì\", \"Mercoledì\", \"Giovedì\", \"Venerdì\", \"Sabato\"],\n      day_short: [\"Dom\", \"Lun\", \"Mar\", \"Mer\", \"Gio\", \"Ven\", \"Sab\"]\n    },\n    labels: {\n      new_task: \"Nuovo compito\",\n      icon_save: \"Salva\",\n      icon_cancel: \"Chiudi\",\n      icon_details: \"Dettagli\",\n      icon_edit: \"Modifica\",\n      icon_delete: \"Elimina\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Sei sicuro di confermare l'eliminazione?\",\n      section_description: \"Descrizione\",\n      section_time: \"Periodo di tempo\",\n      section_type: \"Tipo\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Nome Attività\",\n      column_start_date: \"Inizio\",\n      column_duration: \"Durata\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"sarà eliminato\",\n      link_start: \" (inizio)\",\n      link_end: \" (fine)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minuti\",\n      hours: \"Ore\",\n      days: \"Giorni\",\n      weeks: \"Settimane\",\n      months: \"Mesi\",\n      years: \"Anni\",\n      message_ok: \"OK\",\n      message_cancel: \"Chiudi\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Gi = {\n    date: {\n      month_full: [\"1月\", \"2月\", \"3月\", \"4月\", \"5月\", \"6月\", \"7月\", \"8月\", \"9月\", \"10月\", \"11月\", \"12月\"],\n      month_short: [\"1月\", \"2月\", \"3月\", \"4月\", \"5月\", \"6月\", \"7月\", \"8月\", \"9月\", \"10月\", \"11月\", \"12月\"],\n      day_full: [\"日曜日\", \"月曜日\", \"火曜日\", \"水曜日\", \"木曜日\", \"金曜日\", \"土曜日\"],\n      day_short: [\"日\", \"月\", \"火\", \"水\", \"木\", \"金\", \"土\"]\n    },\n    labels: {\n      new_task: \"新しい仕事\",\n      icon_save: \"保存\",\n      icon_cancel: \"キャンセル\",\n      icon_details: \"詳細\",\n      icon_edit: \"編集\",\n      icon_delete: \"削除\",\n      confirm_closing: \"\",\n      confirm_deleting: \"イベント完全に削除されます、宜しいですか？\",\n      section_description: \"デスクリプション\",\n      section_time: \"期間\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"キャンセル\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Yi = {\n    date: {\n      month_full: [\"1월\", \"2월\", \"3월\", \"4월\", \"5월\", \"6월\", \"7월\", \"8월\", \"9월\", \"10월\", \"11월\", \"12월\"],\n      month_short: [\"1월\", \"2월\", \"3월\", \"4월\", \"5월\", \"6월\", \"7월\", \"8월\", \"9월\", \"10월\", \"11월\", \"12월\"],\n      day_full: [\"일요일\", \"월요일\", \"화요일\", \"수요일\", \"목요일\", \"금요일\", \"토요일\"],\n      day_short: [\"일\", \"월\", \"화\", \"수\", \"목\", \"금\", \"토\"]\n    },\n    labels: {\n      new_task: \"이름없는 작업\",\n      icon_save: \"저장\",\n      icon_cancel: \"취소\",\n      icon_details: \"세부 사항\",\n      icon_edit: \"수정\",\n      icon_delete: \"삭제\",\n      confirm_closing: \"\",\n      confirm_deleting: \"작업을 삭제하시겠습니까?\",\n      section_description: \"설명\",\n      section_time: \"기간\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"작업명\",\n      column_start_date: \"시작일\",\n      column_duration: \"기간\",\n      column_add: \"\",\n      link: \"전제\",\n      confirm_link_deleting: \"삭제 하시겠습니까?\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"작업\",\n      type_project: \"프로젝트\",\n      type_milestone: \"마일스톤\",\n      minutes: \"분\",\n      hours: \"시간\",\n      days: \"일\",\n      weeks: \"주\",\n      months: \"달\",\n      years: \"년\",\n      message_ok: \"OK\",\n      message_cancel: \"취소\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  };\nclass Ji {\n  constructor(e) {\n    this.addLocale = (n, i) => {\n      this._locales[n] = i;\n    }, this.getLocale = n => this._locales[n], this._locales = {};\n    for (const n in e) this._locales[n] = e[n];\n  }\n}\nconst Ki = {\n    date: {\n      month_full: [\"Januar\", \"Februar\", \"Mars\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Desember\"],\n      month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Des\"],\n      day_full: [\"Søndag\", \"Mandag\", \"Tirsdag\", \"Onsdag\", \"Torsdag\", \"Fredag\", \"Lørdag\"],\n      day_short: [\"Søn\", \"Mon\", \"Tir\", \"Ons\", \"Tor\", \"Fre\", \"Lør\"]\n    },\n    labels: {\n      new_task: \"Ny oppgave\",\n      icon_save: \"Lagre\",\n      icon_cancel: \"Avbryt\",\n      icon_details: \"Detaljer\",\n      icon_edit: \"Rediger\",\n      icon_delete: \"Slett\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Hendelsen vil bli slettet permanent. Er du sikker?\",\n      section_description: \"Beskrivelse\",\n      section_time: \"Tidsperiode\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"Avbryt\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Xi = {\n    date: {\n      month_full: [\"Januari\", \"Februari\", \"Maart\", \"April\", \"Mei\", \"Juni\", \"Juli\", \"Augustus\", \"September\", \"Oktober\", \"November\", \"December\"],\n      month_short: [\"Jan\", \"Feb\", \"mrt\", \"Apr\", \"Mei\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dec\"],\n      day_full: [\"Zondag\", \"Maandag\", \"Dinsdag\", \"Woensdag\", \"Donderdag\", \"Vrijdag\", \"Zaterdag\"],\n      day_short: [\"Zo\", \"Ma\", \"Di\", \"Wo\", \"Do\", \"Vr\", \"Za\"]\n    },\n    labels: {\n      new_task: \"Nieuwe taak\",\n      icon_save: \"Opslaan\",\n      icon_cancel: \"Annuleren\",\n      icon_details: \"Details\",\n      icon_edit: \"Bewerken\",\n      icon_delete: \"Verwijderen\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Item zal permanent worden verwijderd, doorgaan?\",\n      section_description: \"Beschrijving\",\n      section_time: \"Tijd periode\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Taak omschrijving\",\n      column_start_date: \"Startdatum\",\n      column_duration: \"Duur\",\n      column_add: \"\",\n      link: \"Koppeling\",\n      confirm_link_deleting: \"zal worden verwijderd\",\n      link_start: \" (start)\",\n      link_end: \" (eind)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"minuten\",\n      hours: \"uren\",\n      days: \"dagen\",\n      weeks: \"weken\",\n      months: \"maanden\",\n      years: \"jaren\",\n      message_ok: \"OK\",\n      message_cancel: \"Annuleren\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Zi = {\n    date: {\n      month_full: [\"Januar\", \"Februar\", \"Mars\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Desember\"],\n      month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Des\"],\n      day_full: [\"Søndag\", \"Mandag\", \"Tirsdag\", \"Onsdag\", \"Torsdag\", \"Fredag\", \"Lørdag\"],\n      day_short: [\"Søn\", \"Man\", \"Tir\", \"Ons\", \"Tor\", \"Fre\", \"Lør\"]\n    },\n    labels: {\n      new_task: \"Ny oppgave\",\n      icon_save: \"Lagre\",\n      icon_cancel: \"Avbryt\",\n      icon_details: \"Detaljer\",\n      icon_edit: \"Endre\",\n      icon_delete: \"Slett\",\n      confirm_closing: \"Endringer blir ikke lagret, er du sikker?\",\n      confirm_deleting: \"Oppføringen vil bli slettet, er du sikker?\",\n      section_description: \"Beskrivelse\",\n      section_time: \"Tidsperiode\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"Avbryt\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  Qi = {\n    date: {\n      month_full: [\"Styczeń\", \"Luty\", \"Marzec\", \"Kwiecień\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpień\", \"Wrzesień\", \"Październik\", \"Listopad\", \"Grudzień\"],\n      month_short: [\"Sty\", \"Lut\", \"Mar\", \"Kwi\", \"Maj\", \"Cze\", \"Lip\", \"Sie\", \"Wrz\", \"Paź\", \"Lis\", \"Gru\"],\n      day_full: [\"Niedziela\", \"Poniedziałek\", \"Wtorek\", \"Środa\", \"Czwartek\", \"Piątek\", \"Sobota\"],\n      day_short: [\"Nie\", \"Pon\", \"Wto\", \"Śro\", \"Czw\", \"Pią\", \"Sob\"]\n    },\n    labels: {\n      new_task: \"Nowe zadanie\",\n      icon_save: \"Zapisz\",\n      icon_cancel: \"Anuluj\",\n      icon_details: \"Szczegóły\",\n      icon_edit: \"Edytuj\",\n      icon_delete: \"Usuń\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Zdarzenie zostanie usunięte na zawsze, kontynuować?\",\n      section_description: \"Opis\",\n      section_time: \"Okres czasu\",\n      section_type: \"Typ\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Nazwa zadania\",\n      column_start_date: \"Początek\",\n      column_duration: \"Czas trwania\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"zostanie usunięty\",\n      link_start: \" (początek)\",\n      link_end: \" (koniec)\",\n      type_task: \"Zadanie\",\n      type_project: \"Projekt\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minuty\",\n      hours: \"Godziny\",\n      days: \"Dni\",\n      weeks: \"Tydzień\",\n      months: \"Miesiące\",\n      years: \"Lata\",\n      message_ok: \"OK\",\n      message_cancel: \"Anuluj\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  ta = {\n    date: {\n      month_full: [\"Janeiro\", \"Fevereiro\", \"Março\", \"Abril\", \"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \"Outubro\", \"Novembro\", \"Dezembro\"],\n      month_short: [\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"],\n      day_full: [\"Domingo\", \"Segunda\", \"Terça\", \"Quarta\", \"Quinta\", \"Sexta\", \"Sábado\"],\n      day_short: [\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sab\"]\n    },\n    labels: {\n      new_task: \"Nova tarefa\",\n      icon_save: \"Salvar\",\n      icon_cancel: \"Cancelar\",\n      icon_details: \"Detalhes\",\n      icon_edit: \"Editar\",\n      icon_delete: \"Excluir\",\n      confirm_closing: \"\",\n      confirm_deleting: \"As tarefas serão excluidas permanentemente, confirme?\",\n      section_description: \"Descrição\",\n      section_time: \"Período\",\n      section_type: \"Tipo\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"EAP\",\n      column_text: \"Nome tarefa\",\n      column_start_date: \"Data início\",\n      column_duration: \"Duração\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"Será excluído!\",\n      link_start: \" (início)\",\n      link_end: \" (fim)\",\n      type_task: \"Task\",\n      type_project: \"Projeto\",\n      type_milestone: \"Marco\",\n      minutes: \"Minutos\",\n      hours: \"Horas\",\n      days: \"Dias\",\n      weeks: \"Semanas\",\n      months: \"Meses\",\n      years: \"Anos\",\n      message_ok: \"OK\",\n      message_cancel: \"Cancelar\",\n      section_constraint: \"Restrição\",\n      constraint_type: \"Tipo Restrição\",\n      constraint_date: \"Data restrição\",\n      asap: \"Mais breve possível\",\n      alap: \"Mais tarde possível\",\n      snet: \"Não começar antes de\",\n      snlt: \"Não começar depois de\",\n      fnet: \"Não terminar antes de\",\n      fnlt: \"Não terminar depois de\",\n      mso: \"Precisa começar em\",\n      mfo: \"Precisa terminar em\",\n      resources_filter_placeholder: \"Tipo de filtros\",\n      resources_filter_label: \"Ocultar vazios\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  ea = {\n    date: {\n      month_full: [\"Ianuarie\", \"Februarie\", \"Martie\", \"Aprilie\", \"Mai\", \"Iunie\", \"Iulie\", \"August\", \"Septembrie\", \"Octombrie\", \"November\", \"December\"],\n      month_short: [\"Ian\", \"Feb\", \"Mar\", \"Apr\", \"Mai\", \"Iun\", \"Iul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n      day_full: [\"Duminica\", \"Luni\", \"Marti\", \"Miercuri\", \"Joi\", \"Vineri\", \"Sambata\"],\n      day_short: [\"Du\", \"Lu\", \"Ma\", \"Mi\", \"Jo\", \"Vi\", \"Sa\"]\n    },\n    labels: {\n      new_task: \"Sarcina noua\",\n      icon_save: \"Salveaza\",\n      icon_cancel: \"Anuleaza\",\n      icon_details: \"Detalii\",\n      icon_edit: \"Editeaza\",\n      icon_delete: \"Sterge\",\n      confirm_closing: \"Schimbarile nu vor fi salvate, esti sigur?\",\n      confirm_deleting: \"Evenimentul va fi sters permanent, esti sigur?\",\n      section_description: \"Descriere\",\n      section_time: \"Interval\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"Anuleaza\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  na = {\n    date: {\n      month_full: [\"Январь\", \"Февраль\", \"Март\", \"Апрель\", \"Maй\", \"Июнь\", \"Июль\", \"Август\", \"Сентябрь\", \"Oктябрь\", \"Ноябрь\", \"Декабрь\"],\n      month_short: [\"Янв\", \"Фев\", \"Maр\", \"Aпр\", \"Maй\", \"Июн\", \"Июл\", \"Aвг\", \"Сен\", \"Окт\", \"Ноя\", \"Дек\"],\n      day_full: [\"Воскресенье\", \"Понедельник\", \"Вторник\", \"Среда\", \"Четверг\", \"Пятница\", \"Суббота\"],\n      day_short: [\"Вс\", \"Пн\", \"Вт\", \"Ср\", \"Чт\", \"Пт\", \"Сб\"]\n    },\n    labels: {\n      new_task: \"Новое задание\",\n      icon_save: \"Сохранить\",\n      icon_cancel: \"Отменить\",\n      icon_details: \"Детали\",\n      icon_edit: \"Изменить\",\n      icon_delete: \"Удалить\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Событие будет удалено безвозвратно, продолжить?\",\n      section_description: \"Описание\",\n      section_time: \"Период времени\",\n      section_type: \"Тип\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"ИСР\",\n      column_text: \"Задача\",\n      column_start_date: \"Начало\",\n      column_duration: \"Длительность\",\n      column_add: \"\",\n      link: \"Связь\",\n      confirm_link_deleting: \"будет удалена\",\n      link_start: \" (начало)\",\n      link_end: \" (конец)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Минута\",\n      hours: \"Час\",\n      days: \"День\",\n      weeks: \"Неделя\",\n      months: \"Месяц\",\n      years: \"Год\",\n      message_ok: \"OK\",\n      message_cancel: \"Отменить\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"начните вводить слово для фильтрации\",\n      resources_filter_label: \"спрятать не установленные\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  ia = {\n    date: {\n      month_full: [\"Januar\", \"Februar\", \"Marec\", \"April\", \"Maj\", \"Junij\", \"Julij\", \"Avgust\", \"September\", \"Oktober\", \"November\", \"December\"],\n      month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Maj\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dec\"],\n      day_full: [\"Nedelja\", \"Ponedeljek\", \"Torek\", \"Sreda\", \"Četrtek\", \"Petek\", \"Sobota\"],\n      day_short: [\"Ned\", \"Pon\", \"Tor\", \"Sre\", \"Čet\", \"Pet\", \"Sob\"]\n    },\n    labels: {\n      new_task: \"Nova naloga\",\n      icon_save: \"Shrani\",\n      icon_cancel: \"Prekliči\",\n      icon_details: \"Podrobnosti\",\n      icon_edit: \"Uredi\",\n      icon_delete: \"Izbriši\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Dogodek bo izbrisan. Želite nadaljevati?\",\n      section_description: \"Opis\",\n      section_time: \"Časovni okvir\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"Prekliči\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  aa = {\n    date: {\n      month_full: [\"Január\", \"Február\", \"Marec\", \"Apríl\", \"Máj\", \"Jún\", \"Júl\", \"August\", \"September\", \"Október\", \"November\", \"December\"],\n      month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Máj\", \"Jún\", \"Júl\", \"Aug\", \"Sept\", \"Okt\", \"Nov\", \"Dec\"],\n      day_full: [\"Nedeľa\", \"Pondelok\", \"Utorok\", \"Streda\", \"Štvrtok\", \"Piatok\", \"Sobota\"],\n      day_short: [\"Ne\", \"Po\", \"Ut\", \"St\", \"Št\", \"Pi\", \"So\"]\n    },\n    labels: {\n      new_task: \"Nová úloha\",\n      icon_save: \"Uložiť\",\n      icon_cancel: \"Späť\",\n      icon_details: \"Detail\",\n      icon_edit: \"Edituj\",\n      icon_delete: \"Zmazať\",\n      confirm_closing: \"Vaše zmeny nebudú uložené. Skutočne?\",\n      confirm_deleting: \"Udalosť bude natrvalo vymazaná. Skutočne?\",\n      section_description: \"Poznámky\",\n      section_time: \"Doba platnosti\",\n      section_type: \"Type\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"Späť\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  ra = {\n    date: {\n      month_full: [\"Januari\", \"Februari\", \"Mars\", \"April\", \"Maj\", \"Juni\", \"Juli\", \"Augusti\", \"September\", \"Oktober\", \"November\", \"December\"],\n      month_short: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Maj\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dec\"],\n      day_full: [\"Söndag\", \"Måndag\", \"Tisdag\", \"Onsdag\", \"Torsdag\", \"Fredag\", \"Lördag\"],\n      day_short: [\"Sön\", \"Mån\", \"Tis\", \"Ons\", \"Tor\", \"Fre\", \"Lör\"]\n    },\n    labels: {\n      new_task: \"Ny uppgift\",\n      icon_save: \"Spara\",\n      icon_cancel: \"Avbryt\",\n      icon_details: \"Detajer\",\n      icon_edit: \"Ändra\",\n      icon_delete: \"Ta bort\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Är du säker på att du vill ta bort händelsen permanent?\",\n      section_description: \"Beskrivning\",\n      section_time: \"Tid\",\n      section_type: \"Typ\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Uppgiftsnamn\",\n      column_start_date: \"Starttid\",\n      column_duration: \"Varaktighet\",\n      column_add: \"\",\n      link: \"Länk\",\n      confirm_link_deleting: \"kommer tas bort\",\n      link_start: \" (start)\",\n      link_end: \" (slut)\",\n      type_task: \"Uppgift\",\n      type_project: \"Projekt\",\n      type_milestone: \"Milstolpe\",\n      minutes: \"Minuter\",\n      hours: \"Timmar\",\n      days: \"Dagar\",\n      weeks: \"Veckor\",\n      months: \"Månader\",\n      years: \"År\",\n      message_ok: \"OK\",\n      message_cancel: \"Avbryt\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  sa = {\n    date: {\n      month_full: [\"Ocak\", \"Şubat\", \"Mart\", \"Nisan\", \"Mayıs\", \"Haziran\", \"Temmuz\", \"Ağustos\", \"Eylül\", \"Ekim\", \"Kasım\", \"Aralık\"],\n      month_short: [\"Oca\", \"Şub\", \"Mar\", \"Nis\", \"May\", \"Haz\", \"Tem\", \"Ağu\", \"Eyl\", \"Eki\", \"Kas\", \"Ara\"],\n      day_full: [\"Pazar\", \"Pazartesi\", \"Salı\", \"Çarşamba\", \"Perşembe\", \"Cuma\", \"Cumartesi\"],\n      day_short: [\"Paz\", \"Pzt\", \"Sal\", \"Çar\", \"Per\", \"Cum\", \"Cmt\"]\n    },\n    labels: {\n      new_task: \"Yeni görev\",\n      icon_save: \"Kaydet\",\n      icon_cancel: \"İptal\",\n      icon_details: \"Detaylar\",\n      icon_edit: \"Düzenle\",\n      icon_delete: \"Sil\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Görev silinecek, emin misiniz?\",\n      section_description: \"Açıklama\",\n      section_time: \"Zaman Aralığı\",\n      section_type: \"Tip\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Görev Adı\",\n      column_start_date: \"Başlangıç\",\n      column_duration: \"Süre\",\n      column_add: \"\",\n      link: \"Bağlantı\",\n      confirm_link_deleting: \"silinecek\",\n      link_start: \" (başlangıç)\",\n      link_end: \" (bitiş)\",\n      type_task: \"Görev\",\n      type_project: \"Proje\",\n      type_milestone: \"Kilometretaşı\",\n      minutes: \"Dakika\",\n      hours: \"Saat\",\n      days: \"Gün\",\n      weeks: \"Hafta\",\n      months: \"Ay\",\n      years: \"Yıl\",\n      message_ok: \"OK\",\n      message_cancel: \"Ýptal\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  },\n  oa = {\n    date: {\n      month_full: [\"Січень\", \"Лютий\", \"Березень\", \"Квітень\", \"Травень\", \"Червень\", \"Липень\", \"Серпень\", \"Вересень\", \"Жовтень\", \"Листопад\", \"Грудень\"],\n      month_short: [\"Січ\", \"Лют\", \"Бер\", \"Кві\", \"Тра\", \"Чер\", \"Лип\", \"Сер\", \"Вер\", \"Жов\", \"Лис\", \"Гру\"],\n      day_full: [\"Неділя\", \"Понеділок\", \"Вівторок\", \"Середа\", \"Четвер\", \"П'ятниця\", \"Субота\"],\n      day_short: [\"Нед\", \"Пон\", \"Вів\", \"Сер\", \"Чет\", \"Птн\", \"Суб\"]\n    },\n    labels: {\n      new_task: \"Нове завдання\",\n      icon_save: \"Зберегти\",\n      icon_cancel: \"Відміна\",\n      icon_details: \"Деталі\",\n      icon_edit: \"Редагувати\",\n      icon_delete: \"Вилучити\",\n      confirm_closing: \"\",\n      confirm_deleting: \"Подія вилучиться назавжди. Ви впевнені?\",\n      section_description: \"Опис\",\n      section_time: \"Часовий проміжок\",\n      section_type: \"Тип\",\n      section_deadline: \"Deadline\",\n      section_baselines: \"Baselines\",\n      column_wbs: \"WBS\",\n      column_text: \"Task name\",\n      column_start_date: \"Start time\",\n      column_duration: \"Duration\",\n      column_add: \"\",\n      link: \"Link\",\n      confirm_link_deleting: \"will be deleted\",\n      link_start: \" (start)\",\n      link_end: \" (end)\",\n      type_task: \"Task\",\n      type_project: \"Project\",\n      type_milestone: \"Milestone\",\n      minutes: \"Minutes\",\n      hours: \"Hours\",\n      days: \"Days\",\n      weeks: \"Week\",\n      months: \"Months\",\n      years: \"Years\",\n      message_ok: \"OK\",\n      message_cancel: \"Відміна\",\n      section_constraint: \"Constraint\",\n      constraint_type: \"Constraint type\",\n      constraint_date: \"Constraint date\",\n      asap: \"As Soon As Possible\",\n      alap: \"As Late As Possible\",\n      snet: \"Start No Earlier Than\",\n      snlt: \"Start No Later Than\",\n      fnet: \"Finish No Earlier Than\",\n      fnlt: \"Finish No Later Than\",\n      mso: \"Must Start On\",\n      mfo: \"Must Finish On\",\n      resources_filter_placeholder: \"type to filter\",\n      resources_filter_label: \"hide empty\",\n      empty_state_text_link: \"Click here\",\n      empty_state_text_description: \"to create your first task\",\n      baselines_section_placeholder: \"Start adding a new baseline\",\n      baselines_add_button: \"Add Baseline\",\n      baselines_remove_button: \"Remove\",\n      baselines_remove_all_button: \"Remove All\",\n      deadline_enable_button: \"Set\",\n      deadline_disable_button: \"Remove\"\n    }\n  };\nfunction la() {\n  this.constants = Gn, this.version = \"9.0.7\", this.license = \"gpl\", this.templates = {}, this.ext = {}, this.keys = {\n    edit_save: this.constants.KEY_CODES.ENTER,\n    edit_cancel: this.constants.KEY_CODES.ESC\n  };\n}\nfunction da(t) {\n  var e = new la(),\n    n = new Yn(t),\n    i = {};\n  e.plugins = function (l) {\n    for (var d in l) if (l[d] && !i[d]) {\n      var c = n.getExtension(d);\n      c && (c(e), i[d] = !0);\n    }\n    return i;\n  }, e.$services = /* @__PURE__ */function () {\n    var l = {};\n    return {\n      services: {},\n      setService: function (d, c) {\n        l[d] = c;\n      },\n      getService: function (d) {\n        return l[d] ? l[d]() : null;\n      },\n      dropService: function (d) {\n        l[d] && delete l[d];\n      },\n      destructor: function () {\n        for (var d in l) if (l[d]) {\n          var c = l[d];\n          c && c.destructor && c.destructor();\n        }\n        l = null;\n      }\n    };\n  }(), e.config = Jn(), e.ajax = /* @__PURE__ */function (l) {\n    return {\n      cache: !0,\n      method: \"get\",\n      parse: function (d) {\n        return typeof d != \"string\" ? d : (d = d.replace(/^[\\s]+/, \"\"), typeof DOMParser > \"u\" || mt.isIE ? dt.ActiveXObject !== void 0 && ((c = new dt.ActiveXObject(\"Microsoft.XMLDOM\")).async = \"false\", c.loadXML(d)) : c = new DOMParser().parseFromString(d, \"text/xml\"), c);\n        var c;\n      },\n      xmltop: function (d, c, u) {\n        if (c.status === void 0 || c.status < 400) {\n          var h = c.responseXML ? c.responseXML || c : this.parse(c.responseText || c);\n          if (h && h.documentElement !== null && !h.getElementsByTagName(\"parsererror\").length) return h.getElementsByTagName(d)[0];\n        }\n        return u !== -1 && l.callEvent(\"onLoadXMLError\", [\"Incorrect XML\", arguments[1], u]), document.createElement(\"DIV\");\n      },\n      xpath: function (d, c) {\n        if (c.nodeName || (c = c.responseXML || c), mt.isIE) return c.selectNodes(d) || [];\n        for (var u, h = [], g = (c.ownerDocument || c).evaluate(d, c, null, XPathResult.ANY_TYPE, null); u = g.iterateNext();) h.push(u);\n        return h;\n      },\n      query: function (d) {\n        return this._call(d.method || \"GET\", d.url, d.data || \"\", d.async || !0, d.callback, d.headers);\n      },\n      get: function (d, c, u) {\n        var h = xt(\"GET\", arguments);\n        return this.query(h);\n      },\n      getSync: function (d, c) {\n        var u = xt(\"GET\", arguments);\n        return u.async = !1, this.query(u);\n      },\n      put: function (d, c, u, h) {\n        var g = xt(\"PUT\", arguments);\n        return this.query(g);\n      },\n      del: function (d, c, u) {\n        var h = xt(\"DELETE\", arguments);\n        return this.query(h);\n      },\n      post: function (d, c, u, h) {\n        arguments.length == 1 ? c = \"\" : arguments.length == 2 && typeof c == \"function\" && (u = c, c = \"\");\n        var g = xt(\"POST\", arguments);\n        return this.query(g);\n      },\n      postSync: function (d, c, u) {\n        c = c === null ? \"\" : String(c);\n        var h = xt(\"POST\", arguments);\n        return h.async = !1, this.query(h);\n      },\n      _call: function (d, c, u, h, g, f) {\n        return new l.Promise(function (y, v) {\n          var b = typeof XMLHttpRequest !== void 0 ? new XMLHttpRequest() : new dt.ActiveXObject(\"Microsoft.XMLHTTP\"),\n            _ = navigator.userAgent.match(/AppleWebKit/) !== null && navigator.userAgent.match(/Qt/) !== null && navigator.userAgent.match(/Safari/) !== null;\n          h && (b.onreadystatechange = function () {\n            if (b.readyState == 4 || _ && b.readyState == 3) {\n              if ((b.status != 200 || b.responseText === \"\") && !l.callEvent(\"onAjaxError\", [b])) return;\n              setTimeout(function () {\n                typeof g == \"function\" && g.apply(dt, [{\n                  xmlDoc: b,\n                  filePath: c\n                }]), y(b), typeof g == \"function\" && (g = null, b = null);\n              }, 0);\n            }\n          });\n          var m = !this || !this.cache;\n          if (d == \"GET\" && m && (c += (c.indexOf(\"?\") >= 0 ? \"&\" : \"?\") + \"dhxr\" + /* @__PURE__ */new Date().getTime() + \"=1\"), b.open(d, c, h), f) for (var p in f) b.setRequestHeader(p, f[p]);else d.toUpperCase() == \"POST\" || d == \"PUT\" || d == \"DELETE\" ? b.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\") : d == \"GET\" && (u = null);\n          if (b.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"), b.send(u), !h) return {\n            xmlDoc: b,\n            filePath: c\n          };\n        });\n      },\n      urlSeparator: function (d) {\n        return d.indexOf(\"?\") != -1 ? \"&\" : \"?\";\n      }\n    };\n  }(e), e.date = Kn(e), e.RemoteEvents = Zn;\n  var a = function (l) {\n    function d(u) {\n      return {\n        target: u.target || u.srcElement,\n        pageX: u.pageX,\n        pageY: u.pageY,\n        clientX: u.clientX,\n        clientY: u.clientY,\n        metaKey: u.metaKey,\n        shiftKey: u.shiftKey,\n        ctrlKey: u.ctrlKey,\n        altKey: u.altKey\n      };\n    }\n    function c(u, h) {\n      this._obj = u, this._settings = h || {}, ot(this);\n      var g = this.getInputMethods();\n      this._drag_start_timer = null, l.attachEvent(\"onGanttScroll\", R(function (v, b) {\n        this.clearDragTimer();\n      }, this));\n      for (var f = {\n          passive: !1\n        }, y = 0; y < g.length; y++) R(function (v) {\n        l.event(u, v.down, R(function (_) {\n          v.accessor(_) && (_.button !== void 0 && _.button !== 0 || (h.preventDefault && h.selector && ct(_.target, h.selector) && _.preventDefault(), l.config.touch && _.timeStamp && _.timeStamp - 0 < 300 || (this._settings.original_target = d(_), this._settings.original_element_sizes = {\n            ...rt(_, rn(u)),\n            width: _.target.offsetWidth,\n            height: _.target.offsetHeight\n          }, l.config.touch ? (this.clearDragTimer(), this._drag_start_timer = setTimeout(R(function () {\n            l.getState().lightbox || this.dragStart(u, _, v);\n          }, this), l.config.touch_drag)) : this.dragStart(u, _, v))));\n        }, this), f);\n        var b = document.body;\n        l.event(b, v.up, R(function (_) {\n          v.accessor(_) && this.clearDragTimer();\n        }, this), f);\n      }, this)(g[y]);\n    }\n    return c.prototype = {\n      traceDragEvents: function (u, h) {\n        var g = R(function (m) {\n          return this.dragMove(u, m, h.accessor);\n        }, this);\n        R(function (m) {\n          return this.dragScroll(u, m);\n        }, this);\n        var f = R(function (m) {\n            if (!this.config.started || !j(this.config.updates_per_second) || un(this, this.config.updates_per_second)) {\n              var p = g(m);\n              if (p) try {\n                m && m.preventDefault && m.cancelable && m.preventDefault();\n              } catch {}\n              return p;\n            }\n          }, this),\n          y = vt(l.$root),\n          v = this.config.mousemoveContainer || vt(l.$root),\n          b = {\n            passive: !1\n          },\n          _ = R(function (m) {\n            return l.eventRemove(v, h.move, f), l.eventRemove(y, h.up, _, b), this.dragEnd(u);\n          }, this);\n        l.event(v, h.move, f, b), l.event(y, h.up, _, b);\n      },\n      checkPositionChange: function (u) {\n        var h = u.x - this.config.pos.x,\n          g = u.y - this.config.pos.y;\n        return Math.sqrt(Math.pow(Math.abs(h), 2) + Math.pow(Math.abs(g), 2)) > this.config.sensitivity;\n      },\n      initDnDMarker: function () {\n        var u = this.config.marker = document.createElement(\"div\");\n        u.className = \"gantt_drag_marker\", u.innerHTML = \"\", document.body.appendChild(u);\n      },\n      backupEventTarget: function (u, h) {\n        if (l.config.touch) {\n          var g = h(u),\n            f = g.target || g.srcElement,\n            y = f.cloneNode(!0);\n          this.config.original_target = d(g), this.config.original_target.target = y, this.config.backup_element = f, f.parentNode.appendChild(y), f.style.display = \"none\", (this.config.mousemoveContainer || document.body).appendChild(f);\n        }\n      },\n      getInputMethods: function () {\n        var u = [];\n        if (u.push({\n          move: \"mousemove\",\n          down: \"mousedown\",\n          up: \"mouseup\",\n          accessor: function (g) {\n            return g;\n          }\n        }), l.config.touch) {\n          var h = !0;\n          try {\n            document.createEvent(\"TouchEvent\");\n          } catch {\n            h = !1;\n          }\n          h ? u.push({\n            move: \"touchmove\",\n            down: \"touchstart\",\n            up: \"touchend\",\n            accessor: function (g) {\n              return g.touches && g.touches.length > 1 ? null : g.touches[0] ? {\n                target: document.elementFromPoint(g.touches[0].clientX, g.touches[0].clientY),\n                pageX: g.touches[0].pageX,\n                pageY: g.touches[0].pageY,\n                clientX: g.touches[0].clientX,\n                clientY: g.touches[0].clientY\n              } : g;\n            }\n          }) : dt.navigator.pointerEnabled ? u.push({\n            move: \"pointermove\",\n            down: \"pointerdown\",\n            up: \"pointerup\",\n            accessor: function (g) {\n              return g.pointerType == \"mouse\" ? null : g;\n            }\n          }) : dt.navigator.msPointerEnabled && u.push({\n            move: \"MSPointerMove\",\n            down: \"MSPointerDown\",\n            up: \"MSPointerUp\",\n            accessor: function (g) {\n              return g.pointerType == g.MSPOINTER_TYPE_MOUSE ? null : g;\n            }\n          });\n        }\n        return u;\n      },\n      clearDragTimer: function () {\n        this._drag_start_timer && (clearTimeout(this._drag_start_timer), this._drag_start_timer = null);\n      },\n      dragStart: function (u, h, g) {\n        this.config && this.config.started || (this.config = {\n          obj: u,\n          marker: null,\n          started: !1,\n          pos: this.getPosition(h),\n          sensitivity: 4\n        }, this._settings && L(this.config, this._settings, !0), this.traceDragEvents(u, g), l._prevent_touch_scroll = !0, document.body.classList.add(\"gantt_noselect\"), l.config.touch && this.dragMove(u, h, g.accessor));\n      },\n      dragMove: function (u, h, g) {\n        var f = g(h);\n        if (!f) return !1;\n        if (!this.config.marker && !this.config.started) {\n          var y = this.getPosition(f);\n          if (l.config.touch || this.checkPositionChange(y)) {\n            if (this.config.started = !0, this.config.ignore = !1, l._touch_drag = !0, this.callEvent(\"onBeforeDragStart\", [u, this.config.original_target]) === !1) return this.config.ignore = !0, !1;\n            this.backupEventTarget(h, g), this.initDnDMarker(), l._touch_feedback(), this.callEvent(\"onAfterDragStart\", [u, this.config.original_target]);\n          } else this.config.ignore = !0;\n        }\n        return this.config.ignore ? !1 : h.targetTouches && !f.target ? void 0 : (f.pos = this.getPosition(f), this.config.marker.style.left = f.pos.x + \"px\", this.config.marker.style.top = f.pos.y + \"px\", this.callEvent(\"onDragMove\", [u, f]), !0);\n      },\n      dragEnd: function (u) {\n        var h = this.config.backup_element;\n        h && h.parentNode && h.parentNode.removeChild(h), l._prevent_touch_scroll = !1, this.config.marker && (this.config.marker.parentNode.removeChild(this.config.marker), this.config.marker = null, this.callEvent(\"onDragEnd\", [])), this.config.started = !1, l._touch_drag = !1, document.body.classList.remove(\"gantt_noselect\");\n      },\n      getPosition: function (u) {\n        var h = 0,\n          g = 0;\n        return u.pageX || u.pageY ? (h = u.pageX, g = u.pageY) : (u.clientX || u.clientY) && (h = u.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, g = u.clientY + document.body.scrollTop + document.documentElement.scrollTop), {\n          x: h,\n          y: g\n        };\n      }\n    }, c;\n  }(e);\n  e.$services.setService(\"dnd\", function () {\n    return a;\n  });\n  var r = /* @__PURE__ */function (l) {\n    var d = {};\n    function c(u, h, g) {\n      g = g || u;\n      var f = l.config,\n        y = l.templates;\n      l.config[u] && d[g] != f[u] && (h && y[g] || (y[g] = l.date.date_to_str(f[u]), d[g] = f[u]));\n    }\n    return {\n      initTemplates: function () {\n        var u = l.date,\n          h = u.date_to_str,\n          g = l.config,\n          f = h(g.xml_date || g.date_format, g.server_utc),\n          y = u.str_to_date(g.xml_date || g.date_format, g.server_utc);\n        c(\"date_scale\", !0, void 0, l.config, l.templates), c(\"date_grid\", !0, \"grid_date_format\", l.config, l.templates), c(\"task_date\", !0, void 0, l.config, l.templates), l.mixin(l.templates, {\n          xml_format: void 0,\n          format_date: f,\n          xml_date: void 0,\n          parse_date: y,\n          progress_text: function (v, b, _) {\n            return \"\";\n          },\n          grid_header_class: function (v, b) {\n            return \"\";\n          },\n          task_text: function (v, b, _) {\n            return _.text;\n          },\n          task_class: function (v, b, _) {\n            return \"\";\n          },\n          task_end_date: function (v) {\n            return l.templates.task_date(v);\n          },\n          grid_row_class: function (v, b, _) {\n            return \"\";\n          },\n          task_row_class: function (v, b, _) {\n            return \"\";\n          },\n          timeline_cell_class: function (v, b) {\n            return \"\";\n          },\n          timeline_cell_content: function (v, b) {\n            return \"\";\n          },\n          scale_cell_class: function (v) {\n            return \"\";\n          },\n          scale_row_class: function (v) {\n            return \"\";\n          },\n          grid_indent: function (v) {\n            return \"<div class='gantt_tree_indent'></div>\";\n          },\n          grid_folder: function (v) {\n            return \"<div class='gantt_tree_icon gantt_folder_\" + (v.$open ? \"open\" : \"closed\") + \"'></div>\";\n          },\n          grid_file: function (v) {\n            return \"<div class='gantt_tree_icon gantt_file'></div>\";\n          },\n          grid_open: function (v) {\n            return \"<div class='gantt_tree_icon gantt_\" + (v.$open ? \"close\" : \"open\") + \"'></div>\";\n          },\n          grid_blank: function (v) {\n            return \"<div class='gantt_tree_icon gantt_blank'></div>\";\n          },\n          date_grid: function (v, b, _) {\n            return b && l.isUnscheduledTask(b) && l.config.show_unscheduled ? l.templates.task_unscheduled_time(b) : l.templates.grid_date_format(v, _);\n          },\n          task_time: function (v, b, _) {\n            return l.isUnscheduledTask(_) && l.config.show_unscheduled ? l.templates.task_unscheduled_time(_) : l.templates.task_date(v) + \" - \" + l.templates.task_end_date(b);\n          },\n          task_unscheduled_time: function (v) {\n            return \"\";\n          },\n          time_picker: h(g.time_picker),\n          link_class: function (v) {\n            return \"\";\n          },\n          link_description: function (v) {\n            var b = l.getTask(v.source),\n              _ = l.getTask(v.target);\n            return \"<b>\" + b.text + \"</b> &ndash;  <b>\" + _.text + \"</b>\";\n          },\n          drag_link: function (v, b, _, m) {\n            v = l.getTask(v);\n            var p = l.locale.labels,\n              k = \"<b>\" + v.text + \"</b> \" + (b ? p.link_start : p.link_end) + \"<br/>\";\n            return _ && (k += \"<b> \" + (_ = l.getTask(_)).text + \"</b> \" + (m ? p.link_start : p.link_end) + \"<br/>\"), k;\n          },\n          drag_link_class: function (v, b, _, m) {\n            var p = \"\";\n            return v && _ && (p = \" \" + (l.isLinkAllowed(v, _, b, m) ? \"gantt_link_allow\" : \"gantt_link_deny\")), \"gantt_link_tooltip\" + p;\n          },\n          tooltip_date_format: u.date_to_str(\"%Y-%m-%d\"),\n          tooltip_text: function (v, b, _) {\n            return `<div>Task: ${_.text}</div>\n\t\t\t\t<div>Start date: ${l.templates.tooltip_date_format(v)}</div>\n\t\t\t\t<div>End date: ${l.templates.tooltip_date_format(b)}</div>`;\n          },\n          baseline_text: function (v, b, _) {\n            return \"\";\n          }\n        });\n      },\n      initTemplate: c\n    };\n  }(e);\n  e.$services.setService(\"templateLoader\", function () {\n    return r;\n  }), ot(e);\n  var s = new Qn();\n  s.registerProvider(\"global\", function () {\n    var l = {\n      min_date: e._min_date,\n      max_date: e._max_date,\n      selected_task: null\n    };\n    return e.$data && e.$data.tasksStore && (l.selected_task = e.$data.tasksStore.getSelectedId()), l;\n  }), e.getState = s.getState, e.$services.setService(\"state\", function () {\n    return s;\n  }), L(e, Wn), e.Promise = ti, e.env = mt, function (l) {\n    var d = ni.create();\n    L(l, d);\n    var c,\n      u = l.createDatastore({\n        name: \"task\",\n        type: \"treeDatastore\",\n        rootId: function () {\n          return l.config.root_id;\n        },\n        initItem: R(function (_) {\n          this.defined(_.id) || (_.id = this.uid()), _.start_date && (_.start_date = l.date.parseDate(_.start_date, \"parse_date\")), _.end_date && (_.end_date = l.date.parseDate(_.end_date, \"parse_date\"));\n          var m = null;\n          (_.duration || _.duration === 0) && (_.duration = m = 1 * _.duration), m && (_.start_date && !_.end_date ? _.end_date = this.calculateEndDate(_) : !_.start_date && _.end_date && (_.start_date = this.calculateEndDate({\n            start_date: _.end_date,\n            duration: -_.duration,\n            task: _\n          }))), l.config.deadlines !== !1 && _.deadline && (_.deadline = l.date.parseDate(_.deadline, \"parse_date\")), _.progress = Number(_.progress) || 0, this._isAllowedUnscheduledTask(_) && this._set_default_task_timing(_), this._init_task_timing(_), _.start_date && _.end_date && this.correctTaskWorkTime(_), _.$source = [], _.$target = [];\n          var p = this.$data.tasksStore.getItem(_.id);\n          return p && !j(_.open) && (_.$open = p.$open), _.parent === void 0 && (_.parent = this.config.root_id), _.open && (_.$open = !0), _;\n        }, l),\n        getConfig: function () {\n          return l.config;\n        }\n      }),\n      h = l.createDatastore({\n        name: \"link\",\n        initItem: R(function (_) {\n          return this.defined(_.id) || (_.id = this.uid()), _;\n        }, l)\n      });\n    function g(_) {\n      var m = l.isTaskVisible(_);\n      if (!m && l.isTaskExists(_)) {\n        var p = l.getParent(_);\n        l.isTaskExists(p) && l.isTaskVisible(p) && (p = l.getTask(p), l.isSplitTask(p) && (m = !0));\n      }\n      return m;\n    }\n    function f(_) {\n      if (l.isTaskExists(_.source)) {\n        var m = l.getTask(_.source);\n        m.$source = m.$source || [], m.$source.push(_.id);\n      }\n      if (l.isTaskExists(_.target)) {\n        var p = l.getTask(_.target);\n        p.$target = p.$target || [], p.$target.push(_.id);\n      }\n    }\n    function y(_) {\n      if (l.isTaskExists(_.source)) {\n        for (var m = l.getTask(_.source), p = 0; p < m.$source.length; p++) if (m.$source[p] == _.id) {\n          m.$source.splice(p, 1);\n          break;\n        }\n      }\n      if (l.isTaskExists(_.target)) {\n        var k = l.getTask(_.target);\n        for (p = 0; p < k.$target.length; p++) if (k.$target[p] == _.id) {\n          k.$target.splice(p, 1);\n          break;\n        }\n      }\n    }\n    function v() {\n      for (var _ = null, m = l.$data.tasksStore.getItems(), p = 0, k = m.length; p < k; p++) (_ = m[p]).$source = [], _.$target = [];\n      var x = l.$data.linksStore.getItems();\n      for (p = 0, k = x.length; p < k; p++) f(x[p]);\n    }\n    function b(_) {\n      var m = _.source,\n        p = _.target;\n      for (var k in _.events) (function (x, $) {\n        m.attachEvent(x, function () {\n          return p.callEvent($, Array.prototype.slice.call(arguments));\n        }, $);\n      })(k, _.events[k]);\n    }\n    l.attachEvent(\"onDestroy\", function () {\n      u.destructor(), h.destructor();\n    }), l.attachEvent(\"onLinkValidation\", function (_) {\n      if (l.isLinkExists(_.id) || _.id === \"predecessor_generated\") return !0;\n      for (var m = l.getTask(_.source).$source, p = 0; p < m.length; p++) {\n        var k = l.getLink(m[p]),\n          x = _.source == k.source,\n          $ = _.target == k.target,\n          w = _.type == k.type;\n        if (x && $ && w) return !1;\n      }\n      return !0;\n    }), u.attachEvent(\"onBeforeRefreshAll\", function () {\n      if (!u._skipTaskRecalculation) for (var _ = u.getVisibleItems(), m = 0; m < _.length; m++) {\n        var p = _[m];\n        p.$index = m, p.$local_index = l.getTaskIndex(p.id), l.resetProjectDates(p);\n      }\n    }), u.attachEvent(\"onFilterItem\", function (_, m) {\n      if (l.config.show_tasks_outside_timescale) return !0;\n      var p = null,\n        k = null;\n      if (l.config.start_date && l.config.end_date) {\n        if (l._isAllowedUnscheduledTask(m)) return !0;\n        if (p = l.config.start_date.valueOf(), k = l.config.end_date.valueOf(), +m.start_date > k || +m.end_date < +p) return !1;\n      }\n      return !0;\n    }), u.attachEvent(\"onIdChange\", function (_, m) {\n      l._update_flags(_, m);\n      var p = l.getTask(m);\n      u.isSilent() || (p.$split_subtask || p.rollup) && l.eachParent(function (k) {\n        l.refreshTask(k.id);\n      }, m);\n    }), u.attachEvent(\"onAfterUpdate\", function (_) {\n      if (l._update_parents(_), l.getState(\"batchUpdate\").batch_update) return !0;\n      var m = u.getItem(_);\n      m.$source || (m.$source = []);\n      for (var p = 0; p < m.$source.length; p++) h.refresh(m.$source[p]);\n      for (m.$target || (m.$target = []), p = 0; p < m.$target.length; p++) h.refresh(m.$target[p]);\n    }), u.attachEvent(\"onBeforeItemMove\", function (_, m, p) {\n      return !Rt(_, l, u) || (console.log(\"The placeholder task cannot be moved to another position.\"), !1);\n    }), u.attachEvent(\"onAfterItemMove\", function (_, m, p) {\n      var k = l.getTask(_);\n      this.getNextSibling(_) !== null ? k.$drop_target = this.getNextSibling(_) : this.getPrevSibling(_) !== null ? k.$drop_target = \"next:\" + this.getPrevSibling(_) : k.$drop_target = \"next:null\";\n    }), u.attachEvent(\"onStoreUpdated\", function (_, m, p) {\n      if (p == \"delete\" && l._update_flags(_, null), !l.$services.getService(\"state\").getState(\"batchUpdate\").batch_update) {\n        if (l.config.fit_tasks && p !== \"paint\") {\n          var k = l.getState();\n          me(l);\n          var x = l.getState();\n          if (+k.min_date != +x.min_date || +k.max_date != +x.max_date) return l.render(), l.callEvent(\"onScaleAdjusted\", []), !0;\n        }\n        p == \"add\" || p == \"move\" || p == \"delete\" ? l.$layout && (this.$config.name != \"task\" || p != \"add\" && p != \"delete\" || this._skipTaskRecalculation != \"lightbox\" && (this._skipTaskRecalculation = !0), l.$layout.resize()) : _ || h.refresh();\n      }\n    }), h.attachEvent(\"onAfterAdd\", function (_, m) {\n      f(m);\n    }), h.attachEvent(\"onAfterUpdate\", function (_, m) {\n      v();\n    }), h.attachEvent(\"onAfterDelete\", function (_, m) {\n      y(m);\n    }), h.attachEvent(\"onAfterSilentDelete\", function (_, m) {\n      y(m);\n    }), h.attachEvent(\"onBeforeIdChange\", function (_, m) {\n      y(l.mixin({\n        id: _\n      }, l.$data.linksStore.getItem(m))), f(l.$data.linksStore.getItem(m));\n    }), h.attachEvent(\"onFilterItem\", function (_, m) {\n      if (!l.config.show_links) return !1;\n      var p = g(m.source),\n        k = g(m.target);\n      return !(!p || !k || l._isAllowedUnscheduledTask(l.getTask(m.source)) || l._isAllowedUnscheduledTask(l.getTask(m.target))) && l.callEvent(\"onBeforeLinkDisplay\", [_, m]);\n    }), c = {}, l.attachEvent(\"onBeforeTaskDelete\", function (_, m) {\n      return c[_] = ve.getSubtreeLinks(l, _), !0;\n    }), l.attachEvent(\"onAfterTaskDelete\", function (_, m) {\n      c[_] && l.$data.linksStore.silent(function () {\n        for (var p in c[_]) l.isLinkExists(p) && l.$data.linksStore.removeItem(p), y(c[_][p]);\n        c[_] = null;\n      });\n    }), l.attachEvent(\"onAfterLinkDelete\", function (_, m) {\n      l.isTaskExists(m.source) && l.refreshTask(m.source), l.isTaskExists(m.target) && l.refreshTask(m.target);\n    }), l.attachEvent(\"onParse\", v), b({\n      source: h,\n      target: l,\n      events: {\n        onItemLoading: \"onLinkLoading\",\n        onBeforeAdd: \"onBeforeLinkAdd\",\n        onAfterAdd: \"onAfterLinkAdd\",\n        onBeforeUpdate: \"onBeforeLinkUpdate\",\n        onAfterUpdate: \"onAfterLinkUpdate\",\n        onBeforeDelete: \"onBeforeLinkDelete\",\n        onAfterDelete: \"onAfterLinkDelete\",\n        onIdChange: \"onLinkIdChange\"\n      }\n    }), b({\n      source: u,\n      target: l,\n      events: {\n        onItemLoading: \"onTaskLoading\",\n        onBeforeAdd: \"onBeforeTaskAdd\",\n        onAfterAdd: \"onAfterTaskAdd\",\n        onBeforeUpdate: \"onBeforeTaskUpdate\",\n        onAfterUpdate: \"onAfterTaskUpdate\",\n        onBeforeDelete: \"onBeforeTaskDelete\",\n        onAfterDelete: \"onAfterTaskDelete\",\n        onIdChange: \"onTaskIdChange\",\n        onBeforeItemMove: \"onBeforeTaskMove\",\n        onAfterItemMove: \"onAfterTaskMove\",\n        onFilterItem: \"onBeforeTaskDisplay\",\n        onItemOpen: \"onTaskOpened\",\n        onItemClose: \"onTaskClosed\",\n        onBeforeSelect: \"onBeforeTaskSelected\",\n        onAfterSelect: \"onTaskSelected\",\n        onAfterUnselect: \"onTaskUnselected\"\n      }\n    }), l.$data = {\n      tasksStore: u,\n      linksStore: h\n    };\n  }(e), e.dataProcessor = Be.DEPRECATED_api, e.createDataProcessor = Be.createDataProcessor, function (l) {\n    l.ext || (l.ext = {});\n    for (var d = [si, li, ci, ui, hi, _i, gi, fi, vi], c = 0; c < d.length; c++) d[c] && d[c](l);\n  }(e), function (l) {\n    l.getGridColumn = function (d) {\n      for (var c = l.config.columns, u = 0; u < c.length; u++) if (c[u].name == d) return c[u];\n      return null;\n    }, l.getGridColumns = function () {\n      return l.config.columns.slice();\n    };\n  }(e), function (l) {\n    l.isReadonly = function (d) {\n      return typeof d != \"number\" && typeof d != \"string\" || !l.isTaskExists(d) || (d = l.getTask(d)), (!d || !d[this.config.editable_property]) && (d && d[this.config.readonly_property] || this.config.readonly);\n    };\n  }(e), ki(e), function (l) {\n    var d = new pn(l),\n      c = new mn(d);\n    L(l, Ti.create(d, c));\n  }(e), Ei(e), function (l) {\n    l.getTaskType = function (d) {\n      return \"task\";\n    };\n  }(e), function (l) {\n    function d() {\n      return l._cached_functions.update_if_changed(l), l._cached_functions.active || l._cached_functions.activate(), !0;\n    }\n    l._cached_functions = {\n      cache: {},\n      mode: !1,\n      critical_path_mode: !1,\n      wrap_methods: function (u, h) {\n        if (h._prefetch_originals) for (var g in h._prefetch_originals) h[g] = h._prefetch_originals[g];\n        for (h._prefetch_originals = {}, g = 0; g < u.length; g++) this.prefetch(u[g], h);\n      },\n      prefetch: function (u, h) {\n        var g = h[u];\n        if (g) {\n          var f = this;\n          h._prefetch_originals[u] = g, h[u] = function () {\n            for (var y = new Array(arguments.length), v = 0, b = arguments.length; v < b; v++) y[v] = arguments[v];\n            if (f.active) {\n              var _ = f.get_arguments_hash(Array.prototype.slice.call(y));\n              f.cache[u] || (f.cache[u] = {});\n              var m = f.cache[u];\n              if (f.has_cached_value(m, _)) return f.get_cached_value(m, _);\n              var p = g.apply(this, y);\n              return f.cache_value(m, _, p), p;\n            }\n            return g.apply(this, y);\n          };\n        }\n        return g;\n      },\n      cache_value: function (u, h, g) {\n        this.is_date(g) && (g = new Date(g)), u[h] = g;\n      },\n      has_cached_value: function (u, h) {\n        return u.hasOwnProperty(h);\n      },\n      get_cached_value: function (u, h) {\n        var g = u[h];\n        return this.is_date(g) && (g = new Date(g)), g;\n      },\n      is_date: function (u) {\n        return u && u.getUTCDate;\n      },\n      get_arguments_hash: function (u) {\n        for (var h = [], g = 0; g < u.length; g++) h.push(this.stringify_argument(u[g]));\n        return \"(\" + h.join(\";\") + \")\";\n      },\n      stringify_argument: function (u) {\n        return (u.id ? u.id : this.is_date(u) ? u.valueOf() : u) + \"\";\n      },\n      activate: function () {\n        this.clear(), this.active = !0;\n      },\n      deactivate: function () {\n        this.clear(), this.active = !1;\n      },\n      clear: function () {\n        this.cache = {};\n      },\n      setup: function (u) {\n        var h = [],\n          g = [\"_isProjectEnd\", \"_getProjectEnd\", \"_getSlack\"];\n        this.mode == \"auto\" ? u.config.highlight_critical_path && (h = g) : this.mode === !0 && (h = g), this.wrap_methods(h, u);\n      },\n      update_if_changed: function (u) {\n        (this.critical_path_mode != u.config.highlight_critical_path || this.mode !== u.config.optimize_render) && (this.critical_path_mode = u.config.highlight_critical_path, this.mode = u.config.optimize_render, this.setup(u));\n      }\n    }, l.attachEvent(\"onBeforeGanttRender\", d), l.attachEvent(\"onBeforeDataRender\", d), l.attachEvent(\"onBeforeSmartRender\", function () {\n      d();\n    }), l.attachEvent(\"onBeforeParse\", d), l.attachEvent(\"onDataRender\", function () {\n      l._cached_functions.deactivate();\n    });\n    var c = null;\n    l.attachEvent(\"onSmartRender\", function () {\n      c && clearTimeout(c), c = setTimeout(function () {\n        l._cached_functions.deactivate();\n      }, 1e3);\n    }), l.attachEvent(\"onBeforeGanttReady\", function () {\n      return l._cached_functions.update_if_changed(l), !0;\n    });\n  }(e), Ci(e), function (l) {\n    l.destructor = function () {\n      for (var d in this.clearAll(), this.callEvent(\"onDestroy\", []), this.$root && delete this.$root.gantt, this._eventRemoveAll && this._eventRemoveAll(), this.$layout && this.$layout.destructor(), this.resetLightbox && this.resetLightbox(), this.ext.inlineEditors && this.ext.inlineEditors.destructor(), this._dp && this._dp.destructor && this._dp.destructor(), this.$services.destructor(), this.detachAllEvents(), this) d.indexOf(\"$\") === 0 && delete this[d];\n      this.$destroyed = !0;\n    };\n  }(e);\n  var o = new Ji({\n    en: Hi,\n    ar: Di,\n    be: Ai,\n    ca: Ii,\n    cn: Mi,\n    cs: Ni,\n    da: Li,\n    de: Pi,\n    el: Ri,\n    es: Oi,\n    fa: Bi,\n    fi: zi,\n    fr: Wi,\n    he: ji,\n    hr: Fi,\n    hu: Vi,\n    id: Ui,\n    it: qi,\n    jp: Gi,\n    kr: Yi,\n    nb: Ki,\n    nl: Xi,\n    no: Zi,\n    pl: Qi,\n    pt: ta,\n    ro: ea,\n    ru: na,\n    si: ia,\n    sk: aa,\n    sv: ra,\n    tr: sa,\n    ua: oa\n  });\n  return e.i18n = {\n    addLocale: o.addLocale,\n    setLocale: function (l) {\n      if (typeof l == \"string\") {\n        var d = o.getLocale(l);\n        d || (d = o.getLocale(\"en\")), e.locale = d;\n      } else if (l) if (e.locale) for (var c in l) l[c] && typeof l[c] == \"object\" ? (e.locale[c] || (e.locale[c] = {}), e.mixin(e.locale[c], l[c], !0)) : e.locale[c] = l[c];else e.locale = l;\n      const u = e.locale.labels;\n      u.gantt_save_btn = u.gantt_save_btn || u.icon_save, u.gantt_cancel_btn = u.gantt_cancel_btn || u.icon_cancel, u.gantt_delete_btn = u.gantt_delete_btn || u.icon_delete;\n    },\n    getLocale: o.getLocale\n  }, e.i18n.setLocale(\"en\"), e;\n}\nfunction ca(t) {\n  var e = \"data-dhxbox\",\n    n = null;\n  function i(_, m) {\n    var p = _.callback;\n    y.hide(_.box), n = _.box = null, p && p(m);\n  }\n  function a(_) {\n    if (n) {\n      var m = _.which || _.keyCode,\n        p = !1;\n      if (v.keyboard) {\n        if (m == 13 || m == 32) {\n          var k = _.target || _.srcElement;\n          X(k).indexOf(\"gantt_popup_button\") > -1 && k.click ? k.click() : (i(n, !0), p = !0);\n        }\n        m == 27 && (i(n, !1), p = !0);\n      }\n      return p ? (_.preventDefault && _.preventDefault(), !(_.cancelBubble = !0)) : void 0;\n    }\n  }\n  var r = vt(t.$root) || document;\n  function s(_) {\n    s.cover || (s.cover = document.createElement(\"div\"), s.cover.onkeydown = a, s.cover.className = \"dhx_modal_cover\", document.body.appendChild(s.cover)), s.cover.style.display = _ ? \"inline-block\" : \"none\";\n  }\n  function o(_, m, p) {\n    return \"<div \" + t._waiAria.messageButtonAttrString(_) + \" class='gantt_popup_button \" + (\"gantt_\" + m.toLowerCase().replace(/ /g, \"_\") + \"_button\") + \"' data-result='\" + p + \"' result='\" + p + \"' ><div>\" + _ + \"</div></div>\";\n  }\n  function l() {\n    for (var _ = [].slice.apply(arguments, [0]), m = 0; m < _.length; m++) if (_[m]) return _[m];\n  }\n  function d(_, m, p) {\n    var k = _.tagName ? _ : function (w, S, T) {\n      var E = document.createElement(\"div\"),\n        C = st();\n      t._waiAria.messageModalAttr(E, C), E.className = \" gantt_modal_box gantt-\" + w.type, E.setAttribute(e, 1);\n      var D = \"\";\n      if (w.width && (E.style.width = w.width), w.height && (E.style.height = w.height), w.title && (D += '<div class=\"gantt_popup_title\">' + w.title + \"</div>\"), D += '<div class=\"gantt_popup_text\" id=\"' + C + '\"><span>' + (w.content ? \"\" : w.text) + '</span></div><div  class=\"gantt_popup_controls\">', S && (D += o(l(w.ok, t.locale.labels.message_ok, \"OK\"), \"ok\", !0)), T && (D += o(l(w.cancel, t.locale.labels.message_cancel, \"Cancel\"), \"cancel\", !1)), w.buttons) for (var M = 0; M < w.buttons.length; M++) {\n        var A = w.buttons[M];\n        D += typeof A == \"object\" ? o(A.label, A.css || \"gantt_\" + A.label.toLowerCase() + \"_button\", A.value || M) : o(A, A, M);\n      }\n      if (D += \"</div>\", E.innerHTML = D, w.content) {\n        var I = w.content;\n        typeof I == \"string\" && (I = document.getElementById(I)), I.style.display == \"none\" && (I.style.display = \"\"), E.childNodes[w.title ? 1 : 0].appendChild(I);\n      }\n      return E.onclick = function (N) {\n        var P = N.target || N.srcElement;\n        if (P.className || (P = P.parentNode), ct(P, \".gantt_popup_button\")) {\n          var O = P.getAttribute(\"data-result\");\n          i(w, O = O == \"true\" || O != \"false\" && O);\n        }\n      }, w.box = E, (S || T) && (n = w), E;\n    }(_, m, p);\n    _.hidden || s(!0), document.body.appendChild(k);\n    var x = Math.abs(Math.floor(((window.innerWidth || document.documentElement.offsetWidth) - k.offsetWidth) / 2)),\n      $ = Math.abs(Math.floor(((window.innerHeight || document.documentElement.offsetHeight) - k.offsetHeight) / 2));\n    return _.position == \"top\" ? k.style.top = \"-3px\" : k.style.top = $ + \"px\", k.style.left = x + \"px\", k.onkeydown = a, y.focus(k), _.hidden && y.hide(k), t.callEvent(\"onMessagePopup\", [k]), k;\n  }\n  function c(_) {\n    return d(_, !0, !1);\n  }\n  function u(_) {\n    return d(_, !0, !0);\n  }\n  function h(_) {\n    return d(_);\n  }\n  function g(_, m, p) {\n    return typeof _ != \"object\" && (typeof m == \"function\" && (p = m, m = \"\"), _ = {\n      text: _,\n      type: m,\n      callback: p\n    }), _;\n  }\n  function f(_, m, p, k) {\n    return typeof _ != \"object\" && (_ = {\n      text: _,\n      type: m,\n      expire: p,\n      id: k\n    }), _.id = _.id || st(), _.expire = _.expire || v.expire, _;\n  }\n  t.event(r, \"keydown\", a, !0);\n  var y = function () {\n    var _ = g.apply(this, arguments);\n    return _.type = _.type || \"alert\", h(_);\n  };\n  y.hide = function (_) {\n    for (; _ && _.getAttribute && !_.getAttribute(e);) _ = _.parentNode;\n    _ && (_.parentNode.removeChild(_), s(!1), t.callEvent(\"onAfterMessagePopup\", [_]));\n  }, y.focus = function (_) {\n    setTimeout(function () {\n      var m = Lt(_);\n      m.length && m[0].focus && m[0].focus();\n    }, 1);\n  };\n  var v = function (_, m, p, k) {\n    switch ((_ = f.apply(this, arguments)).type = _.type || \"info\", _.type.split(\"-\")[0]) {\n      case \"alert\":\n        return c(_);\n      case \"confirm\":\n        return u(_);\n      case \"modalbox\":\n        return h(_);\n      default:\n        return function (x) {\n          v.area || (v.area = document.createElement(\"div\"), v.area.className = \"gantt_message_area\", v.area.style[v.position] = \"5px\", document.body.appendChild(v.area)), v.hide(x.id);\n          var $ = document.createElement(\"div\");\n          return $.innerHTML = \"<div>\" + x.text + \"</div>\", $.className = \"gantt-info gantt-\" + x.type, $.onclick = function () {\n            v.hide(x.id), x = null;\n          }, t._waiAria.messageInfoAttr($), v.position == \"bottom\" && v.area.firstChild ? v.area.insertBefore($, v.area.firstChild) : v.area.appendChild($), x.expire > 0 && (v.timers[x.id] = window.setTimeout(function () {\n            v && v.hide(x.id);\n          }, x.expire)), v.pull[x.id] = $, $ = null, x.id;\n        }(_);\n    }\n  };\n  v.seed = /* @__PURE__ */new Date().valueOf(), v.uid = st, v.expire = 4e3, v.keyboard = !0, v.position = \"top\", v.pull = {}, v.timers = {}, v.hideAll = function () {\n    for (var _ in v.pull) v.hide(_);\n  }, v.hide = function (_) {\n    var m = v.pull[_];\n    m && m.parentNode && (window.setTimeout(function () {\n      m.parentNode.removeChild(m), m = null;\n    }, 2e3), m.className += \" hidden\", v.timers[_] && window.clearTimeout(v.timers[_]), delete v.pull[_]);\n  };\n  var b = [];\n  return t.attachEvent(\"onMessagePopup\", function (_) {\n    b.push(_);\n  }), t.attachEvent(\"onAfterMessagePopup\", function (_) {\n    for (var m = 0; m < b.length; m++) b[m] === _ && (b.splice(m, 1), m--);\n  }), t.attachEvent(\"onDestroy\", function () {\n    s.cover && s.cover.parentNode && s.cover.parentNode.removeChild(s.cover);\n    for (var _ = 0; _ < b.length; _++) b[_].parentNode && b[_].parentNode.removeChild(b[_]);\n    b = null, v.area && v.area.parentNode && v.area.parentNode.removeChild(v.area), v = null;\n  }), {\n    alert: function () {\n      var _ = g.apply(this, arguments);\n      return _.type = _.type || \"confirm\", c(_);\n    },\n    confirm: function () {\n      var _ = g.apply(this, arguments);\n      return _.type = _.type || \"alert\", u(_);\n    },\n    message: v,\n    modalbox: y\n  };\n}\nfunction je(t, e) {\n  var n = this.$config[t];\n  return n ? (n.$extendedConfig || (n.$extendedConfig = !0, Object.setPrototypeOf(n, e)), n) : e;\n}\nfunction ua(t, e) {\n  var n, i, a;\n  L(t, (n = e, {\n    $getConfig: function () {\n      return i || (i = n ? n.$getConfig() : this.$gantt.config), this.$config.config ? je.call(this, \"config\", i) : i;\n    },\n    $getTemplates: function () {\n      return a || (a = n ? n.$getTemplates() : this.$gantt.templates), this.$config.templates ? je.call(this, \"templates\", a) : a;\n    }\n  }));\n}\nconst ha = function (t) {\n  var e = {},\n    n = {};\n  function i(a, r, s, o) {\n    var l = e[a];\n    if (!l || !l.create) return !1;\n    a != \"resizer\" || s.mode || (o.$config.cols ? s.mode = \"x\" : s.mode = \"y\"), a != \"viewcell\" || s.view != \"scrollbar\" || s.scroll || (o.$config.cols ? s.scroll = \"y\" : s.scroll = \"x\"), (s = G(s)).id || n[s.view] || (s.id = s.view), s.id && !s.css && (s.css = s.id + \"_cell\");\n    var d = new l.create(r, s, this, t);\n    return l.configure && l.configure(d), ua(d, o), d.$id || (d.$id = s.id || t.uid()), d.$parent || typeof r != \"object\" || (d.$parent = r), d.$config || (d.$config = s), n[d.$id] && (d.$id = t.uid()), n[d.$id] = d, d;\n  }\n  return {\n    initUI: function (a, r) {\n      var s = \"cell\";\n      return a.view ? s = \"viewcell\" : a.resizer ? s = \"resizer\" : a.rows || a.cols ? s = \"layout\" : a.views && (s = \"multiview\"), i.call(this, s, null, a, r);\n    },\n    reset: function () {\n      n = {};\n    },\n    registerView: function (a, r, s) {\n      e[a] = {\n        create: r,\n        configure: s\n      };\n    },\n    createView: i,\n    getView: function (a) {\n      return n[a];\n    }\n  };\n};\nvar _a = /* @__PURE__ */function (t) {\n  return function (e) {\n    var n = {\n      click: {},\n      doubleclick: {},\n      contextMenu: {}\n    };\n    function i(h, g, f, y) {\n      n[h][g] || (n[h][g] = []), n[h][g].push({\n        handler: f,\n        root: y\n      });\n    }\n    function a(h) {\n      h = h || window.event;\n      var g = e.locate(h),\n        f = s(h, n.click),\n        y = !0;\n      if (g !== null ? y = !e.checkEvent(\"onTaskClick\") || e.callEvent(\"onTaskClick\", [g, h]) : e.callEvent(\"onEmptyClick\", [h]), y) {\n        if (!o(f, h, g)) return;\n        switch (h.target.nodeName) {\n          case \"SELECT\":\n          case \"INPUT\":\n            return;\n        }\n        g && e.getTask(g) && !e._multiselect && e.config.select_task && e.selectTask(g);\n      }\n    }\n    function r(h) {\n      var g = (h = h || window.event).target || h.srcElement,\n        f = e.locate(g),\n        y = e.locate(g, e.config.link_attribute),\n        v = !e.checkEvent(\"onContextMenu\") || e.callEvent(\"onContextMenu\", [f, y, h]);\n      return v || (h.preventDefault ? h.preventDefault() : h.returnValue = !1), v;\n    }\n    function s(h, g) {\n      for (var f = h.target || h.srcElement, y = []; f;) {\n        var v = t.getClassName(f);\n        if (v) {\n          v = v.split(\" \");\n          for (var b = 0; b < v.length; b++) if (v[b] && g[v[b]]) for (var _ = g[v[b]], m = 0; m < _.length; m++) _[m].root && !t.isChildOf(f, _[m].root) || y.push(_[m].handler);\n        }\n        f = f.parentNode;\n      }\n      return y;\n    }\n    function o(h, g, f) {\n      for (var y = !0, v = 0; v < h.length; v++) {\n        var b = h[v].call(e, g, f, g.target || g.srcElement);\n        y = y && !(b !== void 0 && b !== !0);\n      }\n      return y;\n    }\n    function l(h) {\n      h = h || window.event;\n      var g = e.locate(h),\n        f = s(h, n.doubleclick),\n        y = !e.checkEvent(\"onTaskDblClick\") || g === null || e.callEvent(\"onTaskDblClick\", [g, h]);\n      if (y) {\n        if (!o(f, h, g)) return;\n        g !== null && e.getTask(g) && y && e.config.details_on_dblclick && !e.isReadonly(g) && e.showLightbox(g);\n      }\n    }\n    function d(h) {\n      if (e.checkEvent(\"onMouseMove\")) {\n        var g = e.locate(h);\n        e._last_move_event = h, e.callEvent(\"onMouseMove\", [g, h]);\n      }\n    }\n    var c = e._createDomEventScope();\n    function u(h) {\n      c.detachAll(), h && (c.attach(h, \"click\", a), c.attach(h, \"dblclick\", l), c.attach(h, \"mousemove\", d), c.attach(h, \"contextmenu\", r));\n    }\n    return {\n      reset: u,\n      global: function (h, g, f) {\n        i(h, g, f, null);\n      },\n      delegate: i,\n      detach: function (h, g, f, y) {\n        if (n[h] && n[h][g]) {\n          for (var v = n[h], b = v[g], _ = 0; _ < b.length; _++) b[_].root == y && (b.splice(_, 1), _--);\n          b.length || delete v[g];\n        }\n      },\n      callHandler: function (h, g, f, y) {\n        var v = n[h][g];\n        if (v) for (var b = 0; b < v.length; b++) (f || v[b].root) && v[b].root !== f || v[b].handler.apply(this, y);\n      },\n      onDoubleClick: l,\n      onMouseMove: d,\n      onContextMenu: r,\n      onClick: a,\n      destructor: function () {\n        u(), n = null, c = null;\n      }\n    };\n  };\n}(on);\nconst ga = {\n  init: _a\n};\nfunction Fe(t, e, n) {\n  return !!e && !(e.left > t.x_end || e.left + e.width < t.x) && !(e.top > t.y_end || e.top + e.height < t.y);\n}\nfunction Nt(t) {\n  return t.config.smart_rendering && t._smart_render;\n}\nfunction Kt(t, e, n) {\n  return {\n    top: e.getItemTop(t.id),\n    height: e.getItemHeight(t.id),\n    left: 0,\n    right: 1 / 0\n  };\n}\nfunction ft(t, e, n, i, a) {\n  var r = e.getItemIndexByTopPosition(a.y) || 0,\n    s = e.getItemIndexByTopPosition(a.y_end) || i.count(),\n    o = Math.max(0, r - 1),\n    l = Math.min(i.count(), s + 1);\n  const d = [];\n  if (t.config.keyboard_navigation && t.getSelectedId() && t.getTask(t.getSelectedId()).$expanded_branch && d.push(t.getSelectedId()), t.$ui.getView(\"grid\") && t.ext.inlineEditors && t.ext.inlineEditors.getState().id) {\n    let c = t.ext.inlineEditors.getState().id;\n    i.exists(c) && d.push(c);\n  }\n  return {\n    start: o,\n    end: l,\n    ids: d\n  };\n}\nvar fa = function (t) {\n  var e = /* @__PURE__ */function (n) {\n    var i = {},\n      a = {};\n    function r(o) {\n      var l = null;\n      return typeof o.view == \"string\" ? l = n.$ui.getView(o.view) : o.view && (l = o.view), l;\n    }\n    function s(o, l, d) {\n      if (a[o]) return a[o];\n      l.renderer || n.assert(!1, \"Invalid renderer call\");\n      var c = null,\n        u = null,\n        h = null,\n        g = null,\n        f = null;\n      typeof l.renderer == \"function\" ? (c = l.renderer, h = Kt) : (c = l.renderer.render, u = l.renderer.update, g = l.renderer.onrender, l.renderer.isInViewPort ? f = l.renderer.isInViewPort : h = l.renderer.getRectangle, h || h === null || (h = Kt));\n      var y = l.filter;\n      return d && d.setAttribute(n.config.layer_attribute, !0), a[o] = {\n        render_item: function (v, b, _, m, p) {\n          if (b = b || d, !y || y(v)) {\n            var k = m || r(l),\n              x = p || (k ? k.$getConfig() : null),\n              $ = _;\n            !$ && x && x.smart_rendering && ($ = k.getViewPort());\n            var w = null;\n            !Nt(n) && (h || f) && $ ? (f ? f(v, $, k, x, n) : Fe($, h(v, k, x, n))) && (w = c.call(n, v, k, x, $)) : w = c.call(n, v, k, x, $), this.append(v, w, b);\n            var S = b.nodeType == 11;\n            g && !S && w && g.call(n, v, w, k);\n          } else this.remove_item(v.id);\n        },\n        clear: function (v) {\n          this.rendered = i[o] = {}, l.append || this.clear_container(v);\n        },\n        clear_container: function (v) {\n          (v = v || d) && (v.innerHTML = \"\");\n        },\n        get_visible_range: function (v) {\n          var b,\n            _,\n            m = r(l),\n            p = m ? m.$getConfig() : null;\n          return p && p.smart_rendering && (b = m.getViewPort()), m && b && (typeof l.renderer == \"function\" ? _ = ft(n, m, 0, v, b) : l.renderer && l.renderer.getVisibleRange && (_ = l.renderer.getVisibleRange(n, m, p, v, b))), _ || (_ = {\n            start: 0,\n            end: v.count()\n          }), _;\n        },\n        prepare_data: function (v) {\n          if (l.renderer && l.renderer.prepareData) return l.renderer.prepareData(v, n, l);\n        },\n        render_items: function (v, b) {\n          b = b || d;\n          var _ = document.createDocumentFragment();\n          this.clear(b);\n          var m = null,\n            p = r(l),\n            k = p ? p.$getConfig() : null;\n          k && k.smart_rendering && (m = p.getViewPort());\n          for (var x = 0, $ = v.length; x < $; x++) this.render_item(v[x], _, m, p, k);\n          b.appendChild(_, b);\n          var w = {};\n          v.forEach(function (E) {\n            w[E.id] = E;\n          });\n          var S = {};\n          if (g) {\n            var T = {};\n            for (var x in this.rendered) S[x] || (T[x] = this.rendered[x], g.call(n, w[x], this.rendered[x], p));\n          }\n        },\n        update_items: function (v, b) {\n          var _ = r(l),\n            m = _ ? _.$getConfig() : null;\n          if (_ && _.$getConfig().smart_rendering && !Nt(n) && this.rendered && (h || f)) {\n            b = b || d;\n            var p = document.createDocumentFragment(),\n              k = null;\n            _ && (k = _.getViewPort());\n            var x = {};\n            v.forEach(function (A) {\n              x[A.id] = A;\n            });\n            var $ = {},\n              w = {};\n            for (var S in this.rendered) w[S] = !0, $[S] = !0;\n            for (var T = {}, E = (S = 0, v.length); S < E; S++) {\n              var C = v[S],\n                D = this.rendered[C.id];\n              w[C.id] = !1, D && D.parentNode ? (f ? f(C, k, _, m, n) : Fe(k, h(C, _, m, n))) ? (u && u.call(n, C, D, _, m, k), this.restore(C, p)) : w[C.id] = !0 : (T[v[S].id] = !0, this.render_item(v[S], p, k, _, m));\n            }\n            for (var S in w) w[S] && this.hide(S);\n            if (p.childNodes.length && b.appendChild(p, b), g) {\n              var M = {};\n              for (var S in this.rendered) $[S] && !T[S] || (M[S] = this.rendered[S], g.call(n, x[S], this.rendered[S], _));\n            }\n          }\n        },\n        append: function (v, b, _) {\n          this.rendered && (b ? (this.rendered[v.id] && this.rendered[v.id].parentNode ? this.replace_item(v.id, b) : _.appendChild(b), this.rendered[v.id] = b) : this.rendered[v.id] && this.remove_item(v.id));\n        },\n        replace_item: function (v, b) {\n          var _ = this.rendered[v];\n          _ && _.parentNode && _.parentNode.replaceChild(b, _), this.rendered[v] = b;\n        },\n        remove_item: function (v) {\n          this.hide(v), delete this.rendered[v];\n        },\n        hide: function (v) {\n          var b = this.rendered[v];\n          b && b.parentNode && b.parentNode.removeChild(b);\n        },\n        restore: function (v, b) {\n          var _ = this.rendered[v.id];\n          _ ? _.parentNode || this.append(v, _, b || d) : this.render_item(v, b || d);\n        },\n        change_id: function (v, b) {\n          this.rendered[b] = this.rendered[v], delete this.rendered[v];\n        },\n        rendered: i[o],\n        node: d,\n        destructor: function () {\n          this.clear(), delete a[o], delete i[o];\n        }\n      }, a[o];\n    }\n    return {\n      getRenderer: s,\n      clearRenderers: function () {\n        for (var o in a) s(o).destructor();\n      }\n    };\n  }(t);\n  return {\n    createGroup: function (n, i, a, r) {\n      var s = {\n        tempCollection: [],\n        renderers: {},\n        container: n,\n        filters: [],\n        getLayers: function () {\n          this._add();\n          var o = [];\n          for (var l in this.renderers) o.push(this.renderers[l]);\n          return o;\n        },\n        getLayer: function (o) {\n          return this.renderers[o];\n        },\n        _add: function (o) {\n          o && (o.id = o.id || st(), this.tempCollection.push(o));\n          for (var l = this.container(), d = this.tempCollection, c = 0; c < d.length; c++) if (o = d[c], this.container() || o && o.container && Y(o.container, document.body)) {\n            var u = o.container,\n              h = o.id,\n              g = o.topmost;\n            if (!u.parentNode) if (g) l.appendChild(u);else {\n              var f = i ? i() : l.firstChild;\n              f && f.parentNode == l ? l.insertBefore(u, f) : l.appendChild(u);\n            }\n            this.renderers[h] = e.getRenderer(h, o, u), r && r(o, t), this.tempCollection.splice(c, 1), c--;\n          }\n        },\n        addLayer: function (o) {\n          if (o) {\n            typeof o == \"function\" && (o = {\n              renderer: o\n            }), o.filter === void 0 ? o.filter = Ve(a || []) : o.filter instanceof Array && (o.filter.push(a), o.filter = Ve(o.filter)), o.container || (o.container = document.createElement(\"div\"));\n            var l = this;\n            o.requestUpdate = function () {\n              t.config.smart_rendering && !Nt(t) && l.renderers[o.id] && l.onUpdateRequest(l.renderers[o.id]);\n            };\n          }\n          return this._add(o), o ? o.id : void 0;\n        },\n        onUpdateRequest: function (o) {},\n        eachLayer: function (o) {\n          for (var l in this.renderers) o(this.renderers[l]);\n        },\n        removeLayer: function (o) {\n          this.renderers[o] && (this.renderers[o].destructor(), delete this.renderers[o]);\n        },\n        clear: function () {\n          for (var o in this.renderers) this.renderers[o].destructor();\n          this.renderers = {};\n        }\n      };\n      return t.attachEvent(\"onDestroy\", function () {\n        s.clear(), s = null;\n      }), s;\n    }\n  };\n};\nfunction Ve(t) {\n  return t instanceof Array || (t = Array.prototype.slice.call(arguments, 0)), function (e) {\n    for (var n = !0, i = 0, a = t.length; i < a; i++) {\n      var r = t[i];\n      r && (n = n && r(e.id, e) !== !1);\n    }\n    return n;\n  };\n}\nfunction Ue(t, e, n) {\n  if (!t.start_date || !t.end_date) return null;\n  var i = e.posFromDate(t.start_date),\n    a = e.posFromDate(t.end_date),\n    r = Math.min(i, a) - 200,\n    s = Math.max(i, a) + 200;\n  return {\n    top: e.getItemTop(t.id),\n    height: e.getItemHeight(t.id),\n    left: r,\n    width: s - r\n  };\n}\nfunction vn() {\n  var t = [],\n    e = !1;\n  function n() {\n    t = [], e = !1;\n  }\n  function i(r, s, o) {\n    s.$getConfig(), r.getVisibleItems().forEach(function (l) {\n      var d = function (c, u, h, g) {\n        if (!g.isTaskExists(c.source) || !g.isTaskExists(c.target)) return null;\n        var f = Ue(g.getTask(c.source), u),\n          y = Ue(g.getTask(c.target), u);\n        if (!f || !y) return null;\n        var v = 100,\n          b = Math.min(f.left, y.left) - v,\n          _ = Math.max(f.left + f.width, y.left + y.width) + v,\n          m = Math.min(f.top, y.top) - v,\n          p = Math.max(f.top + f.height, y.top + y.height) + v;\n        return {\n          top: m,\n          height: p - m,\n          bottom: p,\n          left: b,\n          width: _ - b,\n          right: _\n        };\n      }(l, s, 0, o);\n      d && t.push({\n        id: l.id,\n        rec: d\n      });\n    }), t.sort(function (l, d) {\n      return l.rec.right < d.rec.right ? -1 : 1;\n    }), e = !0;\n  }\n  var a = !1;\n  return function (r, s, o, l, d) {\n    (function (f) {\n      a || (a = !0, f.attachEvent(\"onPreFilter\", n), f.attachEvent(\"onStoreUpdated\", n), f.attachEvent(\"onClearAll\", n), f.attachEvent(\"onBeforeStoreUpdate\", n));\n    })(l), e || i(l, s, r);\n    for (var c = [], u = 0; u < t.length; u++) {\n      var h = t[u],\n        g = h.rec;\n      g.right < d.x || g.left < d.x_end && g.right > d.x && g.top < d.y_end && g.bottom > d.y && c.push(h.id);\n    }\n    return {\n      ids: c\n    };\n  };\n}\nfunction kn(t, e, n, i, a) {\n  var r = n.$gantt.getTask(t.source),\n    s = n.$gantt.getTask(t.target),\n    o = n.getItemTop(r.id),\n    l = n.getItemHeight(r.id),\n    d = n.getItemTop(s.id),\n    c = n.getItemHeight(s.id);\n  if (e.y > o + l && e.y > d + c || e.y_end < d && e.y_end < o) return !1;\n  var u = 100,\n    h = n.posFromDate(r.start_date),\n    g = n.posFromDate(r.end_date),\n    f = n.posFromDate(s.start_date),\n    y = n.posFromDate(s.end_date);\n  if (h > g) {\n    var v = g;\n    g = h, h = v;\n  }\n  return f > y && (v = y, y = f, f = v), h += -100, g += u, f += -100, y += u, !(e.x > g && e.x > y) && !(e.x_end < h && e.x_end < f);\n}\nfunction pa(t, e) {\n  if (t.view) {\n    var n = t.view;\n    typeof n == \"string\" && (n = e.$ui.getView(n)), n && n.attachEvent && n.attachEvent(\"onScroll\", function () {\n      e.$services.getService(\"state\").getState(\"batchUpdate\").batch_update || n.$config.$skipSmartRenderOnScroll || t.requestUpdate && t.requestUpdate();\n    });\n  }\n}\nvar Ht = function () {\n  function t(e, n, i, a) {\n    e && (this.$container = we(e), this.$parent = e), this.$config = L(n, {\n      headerHeight: 33\n    }), this.$gantt = a, this.$domEvents = a._createDomEventScope(), this.$id = n.id || \"c\" + st(), this.$name = \"cell\", this.$factory = i, ot(this);\n  }\n  return t.prototype.destructor = function () {\n    this.$parent = this.$container = this.$view = null, this.$gantt.$services.getService(\"mouseEvents\").detach(\"click\", \"gantt_header_arrow\", this._headerClickHandler), this.$domEvents.detachAll(), this.callEvent(\"onDestroy\", []), this.detachAllEvents();\n  }, t.prototype.cell = function (e) {\n    return null;\n  }, t.prototype.scrollTo = function (e, n) {\n    var i = this.$view;\n    this.$config.html && (i = this.$view.firstChild), 1 * e == e && (i.scrollLeft = e), 1 * n == n && (i.scrollTop = n);\n  }, t.prototype.clear = function () {\n    this.getNode().innerHTML = \"\", this.getNode().className = \"gantt_layout_content\", this.getNode().style.padding = \"0\";\n  }, t.prototype.resize = function (e) {\n    if (this.$parent) return this.$parent.resize(e);\n    e === !1 && (this.$preResize = !0);\n    var n = this.$container,\n      i = n.offsetWidth,\n      a = n.offsetHeight,\n      r = this.getSize();\n    n === document.body && (i = document.body.offsetWidth, a = document.body.offsetHeight), i < r.minWidth && (i = r.minWidth), i > r.maxWidth && (i = r.maxWidth), a < r.minHeight && (a = r.minHeight), a > r.maxHeight && (a = r.maxHeight), this.setSize(i, a), this.$preResize, this.$preResize = !1;\n  }, t.prototype.hide = function () {\n    this._hide(!0), this.resize();\n  }, t.prototype.show = function (e) {\n    this._hide(!1), e && this.$parent && this.$parent.show(), this.resize();\n  }, t.prototype._hide = function (e) {\n    if (e === !0 && this.$view.parentNode) this.$view.parentNode.removeChild(this.$view);else if (e === !1 && !this.$view.parentNode) {\n      var n = this.$parent.cellIndex(this.$id);\n      this.$parent.moveView(this, n);\n    }\n    this.$config.hidden = e;\n  }, t.prototype.$toHTML = function (e, n) {\n    e === void 0 && (e = \"\"), n = [n || \"\", this.$config.css || \"\"].join(\" \");\n    var i = this.$config,\n      a = \"\";\n    return i.raw ? e = typeof i.raw == \"string\" ? i.raw : \"\" : (e || (e = \"<div class='gantt_layout_content' \" + (n ? \" class='\" + n + \"' \" : \"\") + \" >\" + (i.html || \"\") + \"</div>\"), i.header && (a = \"<div class='gantt_layout_header'>\" + (i.canCollapse ? \"<div class='gantt_layout_header_arrow'></div>\" : \"\") + \"<div class='gantt_layout_header_content'>\" + i.header + \"</div></div>\")), \"<div class='gantt_layout_cell \" + n + \"' data-cell-id='\" + this.$id + \"'>\" + a + e + \"</div>\";\n  }, t.prototype.$fill = function (e, n) {\n    this.$view = e, this.$parent = n, this.init();\n  }, t.prototype.getNode = function () {\n    return this.$view.querySelector(\"gantt_layout_cell\") || this.$view;\n  }, t.prototype.init = function () {\n    var e = this;\n    this._headerClickHandler = function (n) {\n      et(n, \"data-cell-id\") == e.$id && e.toggle();\n    }, this.$gantt.$services.getService(\"mouseEvents\").delegate(\"click\", \"gantt_header_arrow\", this._headerClickHandler), this.callEvent(\"onReady\", []);\n  }, t.prototype.toggle = function () {\n    this.$config.collapsed = !this.$config.collapsed, this.resize();\n  }, t.prototype.getSize = function () {\n    var e = {\n      height: this.$config.height || 0,\n      width: this.$config.width || 0,\n      gravity: this.$config.gravity || 1,\n      minHeight: this.$config.minHeight || 0,\n      minWidth: this.$config.minWidth || 0,\n      maxHeight: this.$config.maxHeight || 1e11,\n      maxWidth: this.$config.maxWidth || 1e11\n    };\n    if (this.$config.collapsed) {\n      var n = this.$config.mode === \"x\";\n      e[n ? \"width\" : \"height\"] = e[n ? \"maxWidth\" : \"maxHeight\"] = this.$config.headerHeight;\n    }\n    return e;\n  }, t.prototype.getContentSize = function () {\n    var e = this.$lastSize.contentX;\n    e !== 1 * e && (e = this.$lastSize.width);\n    var n = this.$lastSize.contentY;\n    return n !== 1 * n && (n = this.$lastSize.height), {\n      width: e,\n      height: n\n    };\n  }, t.prototype._getBorderSizes = function () {\n    var e = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      horizontal: 0,\n      vertical: 0\n    };\n    return this._currentBorders && (this._currentBorders[this._borders.left] && (e.left = 1, e.horizontal++), this._currentBorders[this._borders.right] && (e.right = 1, e.horizontal++), this._currentBorders[this._borders.top] && (e.top = 1, e.vertical++), this._currentBorders[this._borders.bottom] && (e.bottom = 1, e.vertical++)), e;\n  }, t.prototype.setSize = function (e, n) {\n    this.$view.style.width = e + \"px\", this.$view.style.height = n + \"px\";\n    var i = this._getBorderSizes(),\n      a = n - i.vertical,\n      r = e - i.horizontal;\n    this.$lastSize = {\n      x: e,\n      y: n,\n      contentX: r,\n      contentY: a\n    }, this.$config.header ? this._sizeHeader() : this._sizeContent();\n  }, t.prototype._borders = {\n    left: \"gantt_layout_cell_border_left\",\n    right: \"gantt_layout_cell_border_right\",\n    top: \"gantt_layout_cell_border_top\",\n    bottom: \"gantt_layout_cell_border_bottom\"\n  }, t.prototype._setBorders = function (e, n) {\n    n || (n = this);\n    var i = n.$view;\n    for (var a in this._borders) Gt(i, this._borders[a]);\n    typeof e == \"string\" && (e = [e]);\n    var r = {};\n    for (a = 0; a < e.length; a++) wt(i, e[a]), r[e[a]] = !0;\n    n._currentBorders = r;\n  }, t.prototype._sizeContent = function () {\n    var e = this.$view.childNodes[0];\n    e && e.className == \"gantt_layout_content\" && (e.style.height = this.$lastSize.contentY + \"px\");\n  }, t.prototype._sizeHeader = function () {\n    var e = this.$lastSize;\n    e.contentY -= this.$config.headerHeight;\n    var n = this.$view.childNodes[0],\n      i = this.$view.childNodes[1],\n      a = this.$config.mode === \"x\";\n    if (this.$config.collapsed) {\n      if (i.style.display = \"none\", a) {\n        n.className = \"gantt_layout_header collapsed_x\", n.style.width = e.y + \"px\";\n        var r = Math.floor(e.y / 2 - e.x / 2);\n        n.style.transform = \"rotate(90deg) translate(\" + r + \"px, \" + r + \"px)\", i.style.display = \"none\";\n      } else n.className = \"gantt_layout_header collapsed_y\";\n    } else n.className = a ? \"gantt_layout_header\" : \"gantt_layout_header vertical\", n.style.width = \"auto\", n.style.transform = \"\", i.style.display = \"\", i.style.height = e.contentY + \"px\";\n    n.style.height = this.$config.headerHeight + \"px\";\n  }, t;\n}();\nfunction W(t, e) {\n  for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);\n  function i() {\n    this.constructor = t;\n  }\n  t.prototype = e === null ? Object.create(e) : (i.prototype = e.prototype, new i());\n}\nvar yn = function (t) {\n    function e(n, i, a) {\n      var r = t.apply(this, arguments) || this;\n      return n && (r.$root = !0), r._parseConfig(i), r.$name = \"layout\", r;\n    }\n    return W(e, t), e.prototype.destructor = function () {\n      this.$container && this.$view && en(this.$view);\n      for (var n = 0; n < this.$cells.length; n++) this.$cells[n].destructor();\n      this.$cells = [], t.prototype.destructor.call(this);\n    }, e.prototype._resizeScrollbars = function (n, i) {\n      var a = !1,\n        r = [],\n        s = [];\n      const o = [];\n      function l(f) {\n        f.$parent.show(), a = !0, r.push(f);\n      }\n      function d(f) {\n        f.$parent.hide(), a = !0, s.push(f);\n      }\n      for (var c, u = 0; u < i.length; u++) n[(c = i[u]).$config.scroll] ? d(c) : c.shouldHide() ? o.push(c) : c.shouldShow() ? l(c) : c.isVisible() ? r.push(c) : s.push(c);\n      var h = {};\n      for (u = 0; u < r.length; u++) r[u].$config.group && (h[r[u].$config.group] = !0);\n      for (o.forEach(function (f) {\n        f.$config.group && h[f.$config.group] || d(f);\n      }), u = 0; u < s.length; u++) if ((c = s[u]).$config.group && h[c.$config.group]) {\n        l(c);\n        for (var g = 0; g < r.length; g++) if (r[g] == c) {\n          this.$gantt.$scrollbarRepaint = !0;\n          break;\n        }\n      }\n      return a;\n    }, e.prototype.getScrollbarsInfo = function () {\n      const n = this.getCellsByType(\"scroller\"),\n        i = [];\n      return n.forEach(a => {\n        let r = {};\n        const {\n          visible: s,\n          direction: o,\n          size: l,\n          scrollSize: d,\n          position: c\n        } = a.getScrollState();\n        let u = a._getLinkedViews().map(h => h.$config.id);\n        r.id = a.$id, r.visible = s, r.boundViews = u, o === \"x\" ? (r.x = l, r.x_inner = d, r.x_pos = c || 0) : (r.y = l, r.y_inner = d, r.y_pos = c || 0), i.push(r);\n      }), i;\n    }, e.prototype._syncCellSizes = function (n, i) {\n      if (n) {\n        var a = {};\n        return this._eachChild(function (r) {\n          r.$config.group && r.$name != \"scrollbar\" && r.$name != \"resizer\" && (a[r.$config.group] || (a[r.$config.group] = []), a[r.$config.group].push(r));\n        }), a[n] && this._syncGroupSize(a[n], i), a[n];\n      }\n    }, e.prototype._syncGroupSize = function (n, i) {\n      if (n.length) for (var a = n[0].$parent._xLayout ? \"width\" : \"height\", r = n[0].$parent.getNextSibling(n[0].$id) ? 1 : -1, s = i.value, o = i.isGravity, l = 0; l < n.length; l++) {\n        var d = n[l].getSize(),\n          c = r > 0 ? n[l].$parent.getNextSibling(n[l].$id) : n[l].$parent.getPrevSibling(n[l].$id);\n        c.$name == \"resizer\" && (c = r > 0 ? c.$parent.getNextSibling(c.$id) : c.$parent.getPrevSibling(c.$id));\n        var u = c.getSize();\n        if (o) n[l].$config.gravity = s;else if (c[a]) {\n          var h = d.gravity + u.gravity,\n            g = d[a] + u[a],\n            f = h / g;\n          n[l].$config.gravity = f * s, c.$config[a] = g - s, c.$config.gravity = h - f * s;\n        } else n[l].$config[a] = s;\n        var y = this.$gantt.$ui.getView(\"grid\");\n        !y || n[l].$content !== y || y.$config.scrollable || o || (this.$gantt.config.grid_width = s);\n      }\n    }, e.prototype.resize = function (n) {\n      var i = !1;\n      if (this.$root && !this._resizeInProgress && (this.callEvent(\"onBeforeResize\", []), i = !0, this._resizeInProgress = !0), t.prototype.resize.call(this, !0), t.prototype.resize.call(this, !1), i) {\n        var a = [];\n        a = (a = (a = a.concat(this.getCellsByType(\"viewCell\"))).concat(this.getCellsByType(\"viewLayout\"))).concat(this.getCellsByType(\"hostCell\"));\n        for (var r = this.getCellsByType(\"scroller\"), s = 0; s < a.length; s++) a[s].$config.hidden || a[s].setContentSize();\n        var o = this._getAutosizeMode(this.$config.autosize),\n          l = this._resizeScrollbars(o, r);\n        if (this.$config.autosize && (this.autosize(this.$config.autosize), a.forEach(function (d) {\n          const c = d.$parent,\n            u = c.getContentSize(o);\n          o.x && (c.$config.$originalWidthStored || (c.$config.$originalWidthStored = !0, c.$config.$originalWidth = c.$config.width), c.$config.width = u.width), o.y && (c.$config.$originalHeightStored || (c.$config.$originalHeightStored = !0, c.$config.$originalHeight = c.$config.height), c.$config.height = u.height);\n        }), l = !0), l) for (this.resize(), s = 0; s < a.length; s++) a[s].$config.hidden || a[s].setContentSize();\n        this.callEvent(\"onResize\", []);\n      }\n      i && (this._resizeInProgress = !1);\n    }, e.prototype._eachChild = function (n, i) {\n      if (n(i = i || this), i.$cells) for (var a = 0; a < i.$cells.length; a++) this._eachChild(n, i.$cells[a]);\n    }, e.prototype.isChild = function (n) {\n      var i = !1;\n      return this._eachChild(function (a) {\n        a !== n && a.$content !== n || (i = !0);\n      }), i;\n    }, e.prototype.getCellsByType = function (n) {\n      var i = [];\n      if (n === this.$name && i.push(this), this.$content && this.$content.$name == n && i.push(this.$content), this.$cells) for (var a = 0; a < this.$cells.length; a++) {\n        var r = e.prototype.getCellsByType.call(this.$cells[a], n);\n        r.length && i.push.apply(i, r);\n      }\n      return i;\n    }, e.prototype.getNextSibling = function (n) {\n      var i = this.cellIndex(n);\n      return i >= 0 && this.$cells[i + 1] ? this.$cells[i + 1] : null;\n    }, e.prototype.getPrevSibling = function (n) {\n      var i = this.cellIndex(n);\n      return i >= 0 && this.$cells[i - 1] ? this.$cells[i - 1] : null;\n    }, e.prototype.cell = function (n) {\n      for (var i = 0; i < this.$cells.length; i++) {\n        var a = this.$cells[i];\n        if (a.$id === n) return a;\n        var r = a.cell(n);\n        if (r) return r;\n      }\n    }, e.prototype.cellIndex = function (n) {\n      for (var i = 0; i < this.$cells.length; i++) if (this.$cells[i].$id === n) return i;\n      return -1;\n    }, e.prototype.moveView = function (n, i) {\n      if (this.$cells[i] !== n) return window.alert(\"Not implemented\");\n      i += this.$config.header ? 1 : 0;\n      var a = this.$view;\n      i >= a.childNodes.length ? a.appendChild(n.$view) : a.insertBefore(n.$view, a.childNodes[i]);\n    }, e.prototype._parseConfig = function (n) {\n      this.$cells = [], this._xLayout = !n.rows;\n      for (var i = n.rows || n.cols || n.views, a = 0; a < i.length; a++) {\n        var r = i[a];\n        r.mode = this._xLayout ? \"x\" : \"y\";\n        var s = this.$factory.initUI(r, this);\n        s ? (s.$parent = this, this.$cells.push(s)) : (i.splice(a, 1), a--);\n      }\n    }, e.prototype.getCells = function () {\n      return this.$cells;\n    }, e.prototype.render = function () {\n      var n = tn(this.$container, this.$toHTML());\n      this.$fill(n, null), this.callEvent(\"onReady\", []), this.resize(), this.render = this.resize;\n    }, e.prototype.$fill = function (n, i) {\n      this.$view = n, this.$parent = i;\n      for (var a = nn(n, \"gantt_layout_cell\"), r = a.length - 1; r >= 0; r--) {\n        var s = this.$cells[r];\n        s.$fill(a[r], this), s.$config.hidden && s.$view.parentNode.removeChild(s.$view);\n      }\n    }, e.prototype.$toHTML = function () {\n      for (var n = this._xLayout ? \"x\" : \"y\", i = [], a = 0; a < this.$cells.length; a++) i.push(this.$cells[a].$toHTML());\n      return t.prototype.$toHTML.call(this, i.join(\"\"), (this.$root ? \"gantt_layout_root \" : \"\") + \"gantt_layout gantt_layout_\" + n);\n    }, e.prototype.getContentSize = function (n) {\n      for (var i, a, r, s = 0, o = 0, l = 0; l < this.$cells.length; l++) (a = this.$cells[l]).$config.hidden || (i = a.getContentSize(n), a.$config.view === \"scrollbar\" && n[a.$config.scroll] && (i.height = 0, i.width = 0), a.$config.resizer && (this._xLayout ? i.height = 0 : i.width = 0), r = a._getBorderSizes(), this._xLayout ? (s += i.width + r.horizontal, o = Math.max(o, i.height + r.vertical)) : (s = Math.max(s, i.width + r.horizontal), o += i.height + r.vertical));\n      return {\n        width: s += (r = this._getBorderSizes()).horizontal,\n        height: o += r.vertical\n      };\n    }, e.prototype._cleanElSize = function (n) {\n      return 1 * (n || \"\").toString().replace(\"px\", \"\") || 0;\n    }, e.prototype._getBoxStyles = function (n) {\n      var i = null,\n        a = [\"width\", \"height\", \"paddingTop\", \"paddingBottom\", \"paddingLeft\", \"paddingRight\", \"borderLeftWidth\", \"borderRightWidth\", \"borderTopWidth\", \"borderBottomWidth\"],\n        r = {\n          boxSizing: (i = window.getComputedStyle ? window.getComputedStyle(n, null) : {\n            width: n.clientWidth,\n            height: n.clientHeight\n          }).boxSizing == \"border-box\"\n        };\n      i.MozBoxSizing && (r.boxSizing = i.MozBoxSizing == \"border-box\");\n      for (var s = 0; s < a.length; s++) r[a[s]] = i[a[s]] ? this._cleanElSize(i[a[s]]) : 0;\n      var o = {\n        horPaddings: r.paddingLeft + r.paddingRight + r.borderLeftWidth + r.borderRightWidth,\n        vertPaddings: r.paddingTop + r.paddingBottom + r.borderTopWidth + r.borderBottomWidth,\n        borderBox: r.boxSizing,\n        innerWidth: r.width,\n        innerHeight: r.height,\n        outerWidth: r.width,\n        outerHeight: r.height\n      };\n      return o.borderBox ? (o.innerWidth -= o.horPaddings, o.innerHeight -= o.vertPaddings) : (o.outerWidth += o.horPaddings, o.outerHeight += o.vertPaddings), o;\n    }, e.prototype._getAutosizeMode = function (n) {\n      var i = {\n        x: !1,\n        y: !1\n      };\n      return n === \"xy\" ? i.x = i.y = !0 : n === \"y\" || n === !0 ? i.y = !0 : n === \"x\" && (i.x = !0), i;\n    }, e.prototype.autosize = function (n) {\n      var i = this._getAutosizeMode(n),\n        a = this._getBoxStyles(this.$container),\n        r = this.getContentSize(n),\n        s = this.$container;\n      i.x && (a.borderBox && (r.width += a.horPaddings), s.style.width = r.width + \"px\"), i.y && (a.borderBox && (r.height += a.vertPaddings), s.style.height = r.height + \"px\");\n    }, e.prototype.getSize = function () {\n      this._sizes = [];\n      for (var n = 0, i = 0, a = 1e11, r = 0, s = 1e11, o = 0, l = 0; l < this.$cells.length; l++) {\n        var d = this._sizes[l] = this.$cells[l].getSize();\n        this.$cells[l].$config.hidden || (this._xLayout ? (!d.width && d.minWidth ? n += d.minWidth : n += d.width, a += d.maxWidth, i += d.minWidth, r = Math.max(r, d.height), s = Math.min(s, d.maxHeight), o = Math.max(o, d.minHeight)) : (!d.height && d.minHeight ? r += d.minHeight : r += d.height, s += d.maxHeight, o += d.minHeight, n = Math.max(n, d.width), a = Math.min(a, d.maxWidth), i = Math.max(i, d.minWidth)));\n      }\n      var c = t.prototype.getSize.call(this);\n      return c.maxWidth >= 1e5 && (c.maxWidth = a), c.maxHeight >= 1e5 && (c.maxHeight = s), c.minWidth = c.minWidth != c.minWidth ? 0 : c.minWidth, c.minHeight = c.minHeight != c.minHeight ? 0 : c.minHeight, this._xLayout ? (c.minWidth += this.$config.margin * this.$cells.length || 0, c.minWidth += 2 * this.$config.padding || 0, c.minHeight += 2 * this.$config.padding || 0) : (c.minHeight += this.$config.margin * this.$cells.length || 0, c.minHeight += 2 * this.$config.padding || 0), c;\n    }, e.prototype._calcFreeSpace = function (n, i, a) {\n      var r = a ? i.minWidth : i.minHeight,\n        s = i.maxWidth,\n        o = n;\n      return o ? (o > s && (o = s), o < r && (o = r), this._free -= o) : ((o = Math.floor(this._free / this._gravity * i.gravity)) > s && (o = s, this._free -= o, this._gravity -= i.gravity), o < r && (o = r, this._free -= o, this._gravity -= i.gravity)), o;\n    }, e.prototype._calcSize = function (n, i, a) {\n      var r = n,\n        s = a ? i.minWidth : i.minHeight,\n        o = a ? i.maxWidth : i.maxHeight;\n      return r || (r = Math.floor(this._free / this._gravity * i.gravity)), r > o && (r = o), r < s && (r = s), r;\n    }, e.prototype._configureBorders = function () {\n      this.$root && this._setBorders([this._borders.left, this._borders.top, this._borders.right, this._borders.bottom], this);\n      for (var n = this._xLayout ? this._borders.right : this._borders.bottom, i = this.$cells, a = i.length - 1, r = a; r >= 0; r--) if (!i[r].$config.hidden) {\n        a = r;\n        break;\n      }\n      for (r = 0; r < i.length; r++) if (!i[r].$config.hidden) {\n        var s = r >= a,\n          o = \"\";\n        !s && i[r + 1] && i[r + 1].$config.view == \"scrollbar\" && (this._xLayout ? s = !0 : o = \"gantt_layout_cell_border_transparent\"), this._setBorders(s ? [] : [n, o], i[r]);\n      }\n    }, e.prototype._updateCellVisibility = function () {\n      for (var n = this._visibleCells || {}, i = !this._visibleCells, a = {}, r = null, s = [], o = 0; o < this._sizes.length; o++) (r = this.$cells[o]).$config.hide_empty && s.push(r), !i && r.$config.hidden && n[r.$id] ? r._hide(!0) : r.$config.hidden || n[r.$id] || r._hide(!1), r.$config.hidden || (a[r.$id] = !0);\n      for (this._visibleCells = a, o = 0; o < s.length; o++) {\n        var l = (r = s[o]).$cells,\n          d = !0;\n        l.forEach(function (c) {\n          c.$config.hidden || c.$config.resizer || (d = !1);\n        }), r.$config.hidden = d;\n      }\n    }, e.prototype.setSize = function (n, i) {\n      this._configureBorders(), t.prototype.setSize.call(this, n, i), i = this.$lastSize.contentY, n = this.$lastSize.contentX;\n      var a,\n        r,\n        s = this.$config.padding || 0;\n      this.$view.style.padding = s + \"px\", this._gravity = 0, this._free = this._xLayout ? n : i, this._free -= 2 * s, this._updateCellVisibility();\n      for (var o = 0; o < this._sizes.length; o++) if (!(a = this.$cells[o]).$config.hidden) {\n        var l = this.$config.margin || 0;\n        a.$name != \"resizer\" || l || (l = -1);\n        var d = a.$view,\n          c = this._xLayout ? \"marginRight\" : \"marginBottom\";\n        o !== this.$cells.length - 1 && (d.style[c] = l + \"px\", this._free -= l), r = this._sizes[o], this._xLayout ? r.width || (this._gravity += r.gravity) : r.height || (this._gravity += r.gravity);\n      }\n      for (o = 0; o < this._sizes.length; o++) if (!(a = this.$cells[o]).$config.hidden) {\n        var u = (r = this._sizes[o]).width,\n          h = r.height;\n        this._xLayout ? this._calcFreeSpace(u, r, !0) : this._calcFreeSpace(h, r, !1);\n      }\n      for (o = 0; o < this.$cells.length; o++) if (!(a = this.$cells[o]).$config.hidden) {\n        r = this._sizes[o];\n        var g = void 0,\n          f = void 0;\n        this._xLayout ? (g = this._calcSize(r.width, r, !0), f = i - 2 * s) : (g = n - 2 * s, f = this._calcSize(r.height, r, !1)), a.setSize(g, f);\n      }\n    }, e;\n  }(Ht),\n  ma = function (t) {\n    function e(n, i, a) {\n      for (var r = t.apply(this, arguments) || this, s = 0; s < r.$cells.length; s++) r.$cells[s].$config.hidden = s !== 0;\n      return r.$cell = r.$cells[0], r.$name = \"viewLayout\", r;\n    }\n    return W(e, t), e.prototype.cell = function (n) {\n      var i = t.prototype.cell.call(this, n);\n      return i.$view || this.$fill(null, this), i;\n    }, e.prototype.moveView = function (n) {\n      var i = this.$view;\n      this.$cell && (this.$cell.$config.hidden = !0, i.removeChild(this.$cell.$view)), this.$cell = n, i.appendChild(n.$view);\n    }, e.prototype.setSize = function (n, i) {\n      Ht.prototype.setSize.call(this, n, i);\n    }, e.prototype.setContentSize = function () {\n      var n = this.$lastSize;\n      this.$cell.setSize(n.contentX, n.contentY);\n    }, e.prototype.getSize = function () {\n      var n = t.prototype.getSize.call(this);\n      if (this.$cell) {\n        var i = this.$cell.getSize();\n        if (this.$config.byMaxSize) for (var a = 0; a < this.$cells.length; a++) {\n          var r = this.$cells[a].getSize();\n          for (var s in i) i[s] = Math.max(i[s], r[s]);\n        }\n        for (var o in n) n[o] = n[o] || i[o];\n        n.gravity = Math.max(n.gravity, i.gravity);\n      }\n      return n;\n    }, e;\n  }(yn),\n  va = function (t) {\n    function e(n, i, a) {\n      var r = t.apply(this, arguments) || this;\n      if (i.view) {\n        i.id && (this.$id = st());\n        var s = G(i);\n        if (delete s.config, delete s.templates, this.$content = this.$factory.createView(i.view, this, s, this), !this.$content) return !1;\n      }\n      return r.$name = \"viewCell\", r;\n    }\n    return W(e, t), e.prototype.destructor = function () {\n      this.clear(), t.prototype.destructor.call(this);\n    }, e.prototype.clear = function () {\n      if (this.$initialized = !1, this.$content) {\n        var n = this.$content.unload || this.$content.destructor;\n        n && n.call(this.$content);\n      }\n      t.prototype.clear.call(this);\n    }, e.prototype.scrollTo = function (n, i) {\n      this.$content && this.$content.scrollTo ? this.$content.scrollTo(n, i) : t.prototype.scrollTo.call(this, n, i);\n    }, e.prototype._setContentSize = function (n, i) {\n      var a = this._getBorderSizes();\n      if (typeof n == \"number\") {\n        var r = n + a.horizontal;\n        this.$config.width = r;\n      }\n      if (typeof i == \"number\") {\n        var s = i + a.vertical;\n        this.$config.height = s;\n      }\n    }, e.prototype.setSize = function (n, i) {\n      if (t.prototype.setSize.call(this, n, i), !this.$preResize && this.$content && !this.$initialized) {\n        this.$initialized = !0;\n        var a = this.$view.childNodes[0],\n          r = this.$view.childNodes[1];\n        r || (r = a), this.$content.init(r);\n      }\n    }, e.prototype.setContentSize = function () {\n      !this.$preResize && this.$content && this.$initialized && this.$content.setSize(this.$lastSize.contentX, this.$lastSize.contentY);\n    }, e.prototype.getContentSize = function () {\n      var n = t.prototype.getContentSize.call(this);\n      if (this.$content && this.$initialized) {\n        var i = this.$content.getSize();\n        n.width = i.contentX === void 0 ? i.width : i.contentX, n.height = i.contentY === void 0 ? i.height : i.contentY;\n      }\n      var a = this._getBorderSizes();\n      return n.width += a.horizontal, n.height += a.vertical, n;\n    }, e;\n  }(Ht),\n  ka = function (t) {\n    var e = [\"altKey\", \"shiftKey\", \"metaKey\"];\n    function n(a, r, s, o) {\n      var l = t.apply(this, arguments) || this;\n      this.$config = L(r, {\n        scroll: \"x\"\n      }), l._scrollHorizontalHandler = R(l._scrollHorizontalHandler, l), l._scrollVerticalHandler = R(l._scrollVerticalHandler, l), l._outerScrollVerticalHandler = R(l._outerScrollVerticalHandler, l), l._outerScrollHorizontalHandler = R(l._outerScrollHorizontalHandler, l), l._mouseWheelHandler = R(l._mouseWheelHandler, l), this.$config.hidden = !0;\n      var d = o.config.scroll_size;\n      return o.env.isIE && (d += 1), this._isHorizontal() ? (l.$config.height = d, l.$parent.$config.height = d) : (l.$config.width = d, l.$parent.$config.width = d), this.$config.scrollPosition = 0, l.$name = \"scroller\", l;\n    }\n    function i(a, r) {\n      if (r.push(a), a.$cells) for (var s = 0; s < a.$cells.length; s++) i(a.$cells[s], r);\n    }\n    return W(n, t), n.prototype.init = function (a) {\n      a.innerHTML = this.$toHTML(), this.$view = a.firstChild, this.$view || this.init(), this._isVertical() ? this._initVertical() : this._initHorizontal(), this._initMouseWheel(), this._initLinkedViews();\n    }, n.prototype.$toHTML = function () {\n      return \"<div class='gantt_layout_cell \" + (this._isHorizontal() ? \"gantt_hor_scroll\" : \"gantt_ver_scroll\") + \"'><div style='\" + (this._isHorizontal() ? \"width:2000px\" : \"height:2000px\") + \"'></div></div>\";\n    }, n.prototype._getRootParent = function () {\n      for (var a = this.$parent; a && a.$parent;) a = a.$parent;\n      if (a) return a;\n    }, n.prototype._eachView = function () {\n      var a = [];\n      return i(this._getRootParent(), a), a;\n    }, n.prototype._getLinkedViews = function () {\n      for (var a = this._eachView(), r = [], s = 0; s < a.length; s++) a[s].$config && (this._isVertical() && a[s].$config.scrollY == this.$id || this._isHorizontal() && a[s].$config.scrollX == this.$id) && r.push(a[s]);\n      return r;\n    }, n.prototype._initHorizontal = function () {\n      this.$scroll_hor = this.$view, this.$domEvents.attach(this.$view, \"scroll\", this._scrollHorizontalHandler);\n    }, n.prototype._initLinkedViews = function () {\n      for (var a = this._getLinkedViews(), r = this._isVertical() ? \"gantt_layout_outer_scroll gantt_layout_outer_scroll_vertical\" : \"gantt_layout_outer_scroll gantt_layout_outer_scroll_horizontal\", s = 0; s < a.length; s++) wt(a[s].$view || a[s].getNode(), r);\n    }, n.prototype._initVertical = function () {\n      this.$scroll_ver = this.$view, this.$domEvents.attach(this.$view, \"scroll\", this._scrollVerticalHandler);\n    }, n.prototype._updateLinkedViews = function () {}, n.prototype._initMouseWheel = function () {\n      mt.isFF ? this.$domEvents.attach(this._getRootParent().$view, \"wheel\", this._mouseWheelHandler, {\n        passive: !1\n      }) : this.$domEvents.attach(this._getRootParent().$view, \"mousewheel\", this._mouseWheelHandler, {\n        passive: !1\n      });\n    }, n.prototype.scrollHorizontally = function (a) {\n      if (!this._scrolling) {\n        this._scrolling = !0, this.$scroll_hor.scrollLeft = a, this.$config.codeScrollLeft = a, a = this.$scroll_hor.scrollLeft;\n        for (var r = this._getLinkedViews(), s = 0; s < r.length; s++) r[s].scrollTo && r[s].scrollTo(a, void 0);\n        var o = this.$config.scrollPosition;\n        this.$config.scrollPosition = a, this.callEvent(\"onScroll\", [o, a, this.$config.scroll]), this._scrolling = !1;\n      }\n    }, n.prototype.scrollVertically = function (a) {\n      if (!this._scrolling) {\n        this._scrolling = !0, this.$scroll_ver.scrollTop = a, a = this.$scroll_ver.scrollTop;\n        for (var r = this._getLinkedViews(), s = 0; s < r.length; s++) r[s].scrollTo && r[s].scrollTo(void 0, a);\n        var o = this.$config.scrollPosition;\n        this.$config.scrollPosition = a, this.callEvent(\"onScroll\", [o, a, this.$config.scroll]), this._scrolling = !1;\n      }\n    }, n.prototype._isVertical = function () {\n      return this.$config.scroll == \"y\";\n    }, n.prototype._isHorizontal = function () {\n      return this.$config.scroll == \"x\";\n    }, n.prototype._scrollHorizontalHandler = function (a) {\n      if (!this._isVertical() && !this._scrolling) {\n        if ( /* @__PURE__ */new Date() - (this._wheel_time || 0) < 100) return !0;\n        var r = this.$scroll_hor.scrollLeft;\n        this.scrollHorizontally(r), this._oldLeft = this.$scroll_hor.scrollLeft;\n      }\n    }, n.prototype._outerScrollHorizontalHandler = function (a) {\n      this._isVertical();\n    }, n.prototype.show = function () {\n      this.$parent.show();\n    }, n.prototype.hide = function () {\n      this.$parent.hide();\n    }, n.prototype._getScrollSize = function () {\n      for (var a, r = 0, s = 0, o = this._isHorizontal(), l = this._getLinkedViews(), d = o ? \"scrollWidth\" : \"scrollHeight\", c = o ? \"contentX\" : \"contentY\", u = o ? \"x\" : \"y\", h = this._getScrollOffset(), g = 0; g < l.length; g++) if ((a = l[g]) && a.$content && a.$content.getSize && !a.$config.hidden) {\n        var f,\n          y = a.$content.getSize();\n        if (f = y.hasOwnProperty(d) ? y[d] : y[c], h) y[c] > y[u] && y[c] > r && f > y[u] - h + 2 && (r = f + (o ? 0 : 2), s = y[u]);else {\n          var v = Math.max(y[c] - f, 0);\n          (f += v) > Math.max(y[u] - v, 0) && f > r && (r = f, s = y[u]);\n        }\n      }\n      return {\n        outerScroll: s,\n        innerScroll: r\n      };\n    }, n.prototype.scroll = function (a) {\n      this._isHorizontal() ? this.scrollHorizontally(a) : this.scrollVertically(a);\n    }, n.prototype.getScrollState = function () {\n      return {\n        visible: this.isVisible(),\n        direction: this.$config.scroll,\n        size: this.$config.outerSize,\n        scrollSize: this.$config.scrollSize || 0,\n        position: this.$config.scrollPosition || 0\n      };\n    }, n.prototype.setSize = function (a, r) {\n      t.prototype.setSize.apply(this, arguments);\n      var s = this._getScrollSize(),\n        o = (this._isVertical() ? r : a) - this._getScrollOffset() + (this._isHorizontal() ? 1 : 0);\n      s.innerScroll && o > s.outerScroll && (s.innerScroll += o - s.outerScroll), this.$config.scrollSize = s.innerScroll, this.$config.width = a, this.$config.height = r, this._setScrollSize(s.innerScroll);\n    }, n.prototype.isVisible = function () {\n      return !(!this.$parent || !this.$parent.$view.parentNode);\n    }, n.prototype.shouldShow = function () {\n      var a = this._getScrollSize();\n      return !(!a.innerScroll && this.$parent && this.$parent.$view.parentNode) && !(!a.innerScroll || this.$parent && this.$parent.$view.parentNode);\n    }, n.prototype.shouldHide = function () {\n      return !(this._getScrollSize().innerScroll || !this.$parent || !this.$parent.$view.parentNode);\n    }, n.prototype.toggleVisibility = function () {\n      this.shouldHide() ? this.hide() : this.shouldShow() && this.show();\n    }, n.prototype._getScaleOffset = function (a) {\n      var r = 0;\n      return !a || a.$config.view != \"timeline\" && a.$config.view != \"grid\" || (r = a.$content.$getConfig().scale_height), r;\n    }, n.prototype._getScrollOffset = function () {\n      var a = 0;\n      if (this._isVertical()) {\n        var r = this.$parent.$parent;\n        a = Math.max(this._getScaleOffset(r.getPrevSibling(this.$parent.$id)), this._getScaleOffset(r.getNextSibling(this.$parent.$id)));\n      } else for (var s = this._getLinkedViews(), o = 0; o < s.length; o++) {\n        var l = s[o].$parent.$cells,\n          d = l[l.length - 1];\n        if (d && d.$config.view == \"scrollbar\" && d.$config.hidden === !1) {\n          a = d.$config.width;\n          break;\n        }\n      }\n      return a || 0;\n    }, n.prototype._setScrollSize = function (a) {\n      var r = this._isHorizontal() ? \"width\" : \"height\",\n        s = this._isHorizontal() ? this.$scroll_hor : this.$scroll_ver,\n        o = this._getScrollOffset(),\n        l = s.firstChild;\n      o ? this._isVertical() ? (this.$config.outerSize = this.$config.height - o + 3, s.style.height = this.$config.outerSize + \"px\", s.style.top = o - 1 + \"px\", wt(s, this.$parent._borders.top), wt(s.parentNode, \"gantt_task_vscroll\")) : (this.$config.outerSize = this.$config.width - o + 1, s.style.width = this.$config.outerSize + \"px\") : (s.style.top = \"auto\", Gt(s, this.$parent._borders.top), Gt(s.parentNode, \"gantt_task_vscroll\"), this.$config.outerSize = this.$config.height), l.style[r] = a + \"px\";\n    }, n.prototype._scrollVerticalHandler = function (a) {\n      if (!this._scrollHorizontalHandler() && !this._scrolling) {\n        var r = this.$scroll_ver.scrollTop;\n        r != this._oldTop && (this.scrollVertically(r), this._oldTop = this.$scroll_ver.scrollTop);\n      }\n    }, n.prototype._outerScrollVerticalHandler = function (a) {\n      this._scrollHorizontalHandler();\n    }, n.prototype._checkWheelTarget = function (a) {\n      for (var r = this._getLinkedViews().concat(this), s = 0; s < r.length; s++) if (Y(a, r[s].$view)) return !0;\n      return !1;\n    }, n.prototype._mouseWheelHandler = function (a) {\n      var r = a.target || a.srcElement;\n      if (this._checkWheelTarget(r)) {\n        this._wheel_time = /* @__PURE__ */new Date();\n        var s = {},\n          o = {\n            x: 1,\n            y: 1\n          },\n          l = this.$gantt.config.wheel_scroll_sensitivity;\n        typeof l == \"number\" && l ? o = {\n          x: l,\n          y: l\n        } : {}.toString.apply(l) == \"[object Object]\" && (o = {\n          x: l.x,\n          y: l.y\n        });\n        var d = mt.isFF,\n          c = d ? a.deltaX : a.wheelDeltaX,\n          u = d ? a.deltaY : a.wheelDelta,\n          h = -20;\n        d && (h = a.deltaMode !== 0 ? -40 : -10);\n        var g = d ? c * h * o.x : 2 * c * o.x,\n          f = d ? u * h * o.y : u * o.y,\n          y = this.$gantt.config.horizontal_scroll_key;\n        if (y !== !1 && e.indexOf(y) >= 0 && (!a[y] || a.deltaX || a.wheelDeltaX || (g = 2 * f, f = 0)), g && Math.abs(g) > Math.abs(f)) {\n          if (this._isVertical()) return;\n          if (s.x || !this.$scroll_hor || !this.$scroll_hor.offsetWidth) return !0;\n          var v = g / -40,\n            b = this._oldLeft,\n            _ = b + 30 * v;\n          if (this.scrollHorizontally(_), this.$scroll_hor.scrollLeft = _, b == this.$scroll_hor.scrollLeft) return !0;\n          this._oldLeft = this.$scroll_hor.scrollLeft;\n        } else {\n          if (this._isHorizontal()) return;\n          if (s.y || !this.$scroll_ver || !this.$scroll_ver.offsetHeight) return !0;\n          v = f / -40, f === void 0 && (v = a.detail);\n          var m = this._oldTop,\n            p = this.$scroll_ver.scrollTop + 30 * v;\n          if (this.scrollVertically(p), this.$scroll_ver.scrollTop = p, m == this.$scroll_ver.scrollTop) return !0;\n          this._oldTop = this.$scroll_ver.scrollTop;\n        }\n        return a.preventDefault && a.preventDefault(), a.cancelBubble = !0, !1;\n      }\n    }, n;\n  }(Ht);\nfunction bn(t) {\n  var e = {},\n    n = {},\n    i = null,\n    a = -1,\n    r = null,\n    s = /* @__PURE__ */function (o) {\n      var l = -1,\n        d = -1;\n      return {\n        resetCache: function () {\n          l = -1, d = -1;\n        },\n        _getRowHeight: function () {\n          return l === -1 && (l = o.$getConfig().row_height), l;\n        },\n        _refreshState: function () {\n          this.resetCache(), d = !0;\n          var c = o.$config.rowStore;\n          if (c) for (var u = this._getRowHeight(), h = 0; h < c.fullOrder.length; h++) {\n            var g = c.getItem(c.fullOrder[h]);\n            if (g && g.row_height && g.row_height !== u) {\n              d = !1;\n              break;\n            }\n          }\n        },\n        canUseSimpleCalculation: function () {\n          return d === -1 && this._refreshState(), d;\n        },\n        getRowTop: function (c) {\n          return o.$config.rowStore ? c * this._getRowHeight() : 0;\n        },\n        getItemHeight: function (c) {\n          return this._getRowHeight();\n        },\n        getTotalHeight: function () {\n          return o.$config.rowStore ? o.$config.rowStore.countVisible() * this._getRowHeight() : 0;\n        },\n        getItemIndexByTopPosition: function (c) {\n          return o.$config.rowStore ? Math.floor(c / this._getRowHeight()) : 0;\n        }\n      };\n    }(t);\n  return {\n    _resetTopPositionHeight: function () {\n      e = {}, n = {}, s.resetCache();\n    },\n    _resetHeight: function () {\n      var o = this.$config.rowStore,\n        l = this.getCacheStateTotalHeight(o);\n      r ? this.shouldClearHeightCache(r, l) && (r = l, i = null) : r = l, a = -1, s.resetCache();\n    },\n    getRowTop: function (o) {\n      if (s.canUseSimpleCalculation()) return s.getRowTop(o);\n      var l = this.$config.rowStore;\n      if (!l) return 0;\n      if (n[o] !== void 0) return n[o];\n      for (var d = l.getIndexRange(), c = 0, u = 0, h = 0; h < d.length; h++) n[h] = c, c += this.getItemHeight(d[h].id), h < o && (u = c);\n      return u;\n    },\n    getItemTop: function (o) {\n      if (this.$config.rowStore) {\n        if (e[o] !== void 0) return e[o];\n        var l = this.$config.rowStore;\n        if (!l) return 0;\n        var d = l.getIndexById(o);\n        if (d === -1 && l.getParent && l.exists(o)) {\n          var c = l.getParent(o);\n          if (l.exists(c)) {\n            var u = l.getItem(c);\n            if (this.$gantt.isSplitTask(u)) return this.getItemTop(c);\n          }\n        }\n        return e[o] = this.getRowTop(d), e[o];\n      }\n      return 0;\n    },\n    getItemHeight: function (o) {\n      if (s.canUseSimpleCalculation()) return s.getItemHeight(o);\n      if (!i && this.$config.rowStore && this._fillHeightCache(this.$config.rowStore), i[o] !== void 0) return i[o];\n      var l = this.$getConfig().row_height;\n      if (this.$config.rowStore) {\n        var d = this.$config.rowStore;\n        if (!d) return l;\n        var c = d.getItem(o);\n        return i[o] = c && c.row_height || l;\n      }\n      return l;\n    },\n    _fillHeightCache: function (o) {\n      if (o) {\n        i = {};\n        var l = this.$getConfig().row_height;\n        o.eachItem(function (d) {\n          return i[d.id] = d && d.row_height || l;\n        });\n      }\n    },\n    getCacheStateTotalHeight: function (o) {\n      var l = this.$getConfig().row_height,\n        d = {},\n        c = [],\n        u = 0;\n      return o && o.eachItem(function (h) {\n        c.push(h), d[h.id] = h.row_height, u += h.row_height || l;\n      }), {\n        globalHeight: l,\n        items: c,\n        count: c.length,\n        sumHeight: u\n      };\n    },\n    shouldClearHeightCache: function (o, l) {\n      if (o.count != l.count || o.globalHeight != l.globalHeight || o.sumHeight != l.sumHeight) return !0;\n      for (var d in o.items) {\n        var c = l.items[d];\n        if (c !== void 0 && c != o.items[d]) return !0;\n      }\n      return !1;\n    },\n    getTotalHeight: function () {\n      if (s.canUseSimpleCalculation()) return s.getTotalHeight();\n      if (a != -1) return a;\n      if (this.$config.rowStore) {\n        var o = this.$config.rowStore;\n        this._fillHeightCache(o);\n        var l = this.getItemHeight.bind(this),\n          d = o.getVisibleItems(),\n          c = 0;\n        return d.forEach(function (u) {\n          c += l(u.id);\n        }), a = c, c;\n      }\n      return 0;\n    },\n    getItemIndexByTopPosition: function (o) {\n      if (this.$config.rowStore) {\n        if (s.canUseSimpleCalculation()) return s.getItemIndexByTopPosition(o);\n        for (var l = this.$config.rowStore, d = 0; d < l.countVisible(); d++) {\n          var c = this.getRowTop(d),\n            u = this.getRowTop(d + 1);\n          if (!u) {\n            var h = l.getIdByIndex(d);\n            u = c + this.getItemHeight(h);\n          }\n          if (o >= c && o < u) return d;\n        }\n        return l.countVisible() + 2;\n      }\n      return 0;\n    }\n  };\n}\nconst ya = function () {\n  return {\n    render: function () {},\n    destroy: function () {}\n  };\n};\nvar Ut = function (t, e, n, i) {\n  this.$config = L({}, e || {}), this.$scaleHelper = new pe(i), this.$gantt = i, this._posFromDateCache = {}, this._timelineDragScroll = null, L(this, bn(this)), ot(this);\n};\nUt.prototype = {\n  init: function (t) {\n    t.innerHTML += \"<div class='gantt_task' style='width:inherit;height:inherit;'></div>\", this.$task = t.childNodes[0], this.$task.innerHTML = \"<div class='gantt_task_scale'></div><div class='gantt_data_area'></div>\", this.$task_scale = this.$task.childNodes[0], this.$task_data = this.$task.childNodes[1], this.$task_data.innerHTML = \"<div class='gantt_task_bg'></div><div class='gantt_task_baselines'></div><div class='gantt_links_area'></div><div class='gantt_bars_area'></div><div class='gantt_task_constraints'></div><div class='gantt_task_deadlines'></div>\", this.$task_bg = this.$task_data.childNodes[0], this.$task_baselines = this.$task_data.childNodes[1], this.$task_links = this.$task_data.childNodes[2], this.$task_bars = this.$task_data.childNodes[3], this.$task_constraints = this.$task_data.childNodes[4], this.$task_deadlines = this.$task_data.childNodes[5], this._tasks = {\n      col_width: 0,\n      width: [],\n      full_width: 0,\n      trace_x: [],\n      rendered: {}\n    };\n    var e = this.$getConfig(),\n      n = e[this.$config.bind + \"_attribute\"],\n      i = e[this.$config.bindLinks + \"_attribute\"];\n    !n && this.$config.bind && (n = \"data-\" + this.$config.bind + \"-id\"), !i && this.$config.bindLinks && (i = \"data-\" + this.$config.bindLinks + \"-id\"), this.$config.item_attribute = n || null, this.$config.link_attribute = i || null;\n    var a = this._createLayerConfig();\n    this.$config.layers || (this.$config.layers = a.tasks), this.$config.linkLayers || (this.$config.linkLayers = a.links), this._attachLayers(this.$gantt), this.callEvent(\"onReady\", []), this.$gantt.ext.dragTimeline && (this._timelineDragScroll = this.$gantt.ext.dragTimeline.create(), this._timelineDragScroll.attach(this));\n  },\n  setSize: function (t, e) {\n    var n = this.$getConfig();\n    if (1 * t === t && (this.$config.width = t), 1 * e === e) {\n      this.$config.height = e;\n      var i = Math.max(this.$config.height - n.scale_height);\n      this.$task_data.style.height = i + \"px\";\n    }\n    this.refresh(), this.$task_bg.style.backgroundImage = \"\", n.smart_rendering && this.$config.rowStore ? this.$task_bg.style.height = this.getTotalHeight() + \"px\" : this.$task_bg.style.height = \"\";\n    for (var a = this._tasks, r = this.$task_data.childNodes, s = 0, o = r.length; s < o; s++) {\n      var l = r[s];\n      l.hasAttribute(\"data-layer\") && l.style && (l.style.width = a.full_width + \"px\");\n    }\n  },\n  isVisible: function () {\n    return this.$parent && this.$parent.$config ? !this.$parent.$config.hidden : this.$task.offsetWidth;\n  },\n  getSize: function () {\n    var t = this.$getConfig(),\n      e = this.$config.rowStore ? this.getTotalHeight() : 0,\n      n = this.isVisible() ? this._tasks.full_width : 0;\n    return {\n      x: this.isVisible() ? this.$config.width : 0,\n      y: this.isVisible() ? this.$config.height : 0,\n      contentX: this.isVisible() ? n : 0,\n      contentY: this.isVisible() ? t.scale_height + e : 0,\n      scrollHeight: this.isVisible() ? e : 0,\n      scrollWidth: this.isVisible() ? n : 0\n    };\n  },\n  scrollTo: function (t, e) {\n    if (this.isVisible()) {\n      var n = !1;\n      this.$config.scrollTop = this.$config.scrollTop || 0, this.$config.scrollLeft = this.$config.scrollLeft || 0, 1 * e === e && (this.$config.scrollTop = e, this.$task_data.scrollTop = this.$config.scrollTop, n = !0), 1 * t === t && (this.$task.scrollLeft = t, this.$config.scrollLeft = this.$task.scrollLeft, this._refreshScales(), n = !0), n && this.callEvent(\"onScroll\", [this.$config.scrollLeft, this.$config.scrollTop]);\n    }\n  },\n  _refreshScales: function () {\n    if (this.isVisible() && this.$getConfig().smart_scales) {\n      var t = this.getViewPort(),\n        e = this._scales;\n      this.$task_scale.innerHTML = this._getScaleChunkHtml(e, t.x, t.x_end);\n    }\n  },\n  getViewPort: function () {\n    var t = this.$config.scrollLeft || 0,\n      e = this.$config.scrollTop || 0,\n      n = this.$config.height || 0,\n      i = this.$config.width || 0;\n    return {\n      y: e,\n      y_end: e + n,\n      x: t,\n      x_end: t + i,\n      height: n,\n      width: i\n    };\n  },\n  _createLayerConfig: function () {\n    var t = this,\n      e = function () {\n        return t.isVisible();\n      };\n    this.$gantt;\n    var n = [{\n      expose: !0,\n      renderer: this.$gantt.$ui.layers.taskBar(),\n      container: this.$task_bars,\n      filter: [e, function (i, a) {\n        return !a.hide_bar;\n      }]\n    }];\n    return n.push({\n      renderer: this.$gantt.$ui.layers.taskBg(),\n      container: this.$task_bg,\n      filter: [e]\n    }), {\n      tasks: n,\n      links: [{\n        expose: !0,\n        renderer: this.$gantt.$ui.layers.link(),\n        container: this.$task_links,\n        filter: [e]\n      }]\n    };\n  },\n  _attachLayers: function (t) {\n    this._taskLayers = [], this._linkLayers = [];\n    var e = this,\n      n = this.$gantt.$services.getService(\"layers\");\n    if (this.$config.bind) {\n      this._bindStore();\n      var i = n.getDataRender(this.$config.bind);\n      i || (i = n.createDataRender({\n        name: this.$config.bind,\n        defaultContainer: function () {\n          return e.$task_data;\n        }\n      })), i.container = function () {\n        return e.$task_data;\n      };\n      for (var a = this.$config.layers, r = 0; a && r < a.length; r++) {\n        typeof (d = a[r]) == \"string\" && (d = this.$gantt.$ui.layers[d]()), (typeof d == \"function\" || d && d.render && d.update) && (d = {\n          renderer: d\n        }), d.view = this;\n        var s = i.addLayer(d);\n        this._taskLayers.push(s), d.expose && (this._taskRenderer = i.getLayer(s));\n      }\n      this._initStaticBackgroundRender();\n    }\n    if (this.$config.bindLinks) {\n      e.$config.linkStore = e.$gantt.getDatastore(e.$config.bindLinks);\n      var o = n.getDataRender(this.$config.bindLinks);\n      o || (o = n.createDataRender({\n        name: this.$config.bindLinks,\n        defaultContainer: function () {\n          return e.$task_data;\n        }\n      }));\n      var l = this.$config.linkLayers;\n      for (r = 0; l && r < l.length; r++) {\n        var d;\n        typeof d == \"string\" && (d = this.$gantt.$ui.layers[d]()), (d = l[r]).view = this;\n        var c = o.addLayer(d);\n        this._taskLayers.push(c), l[r].expose && (this._linkRenderer = o.getLayer(c));\n      }\n    }\n  },\n  _initStaticBackgroundRender: function () {\n    var t = this,\n      e = ya(),\n      n = t.$config.rowStore;\n    n && (this._staticBgHandler = n.attachEvent(\"onStoreUpdated\", function (i, a, r) {\n      if (i === null && t.isVisible()) {\n        var s = t.$getConfig();\n        if (s.static_background || s.timeline_placeholder) {\n          var o = t.$gantt.getDatastore(t.$config.bind),\n            l = t.$task_bg_static;\n          if (l || ((l = document.createElement(\"div\")).className = \"gantt_task_bg\", t.$task_bg_static = l, t.$task_bg.nextSibling ? t.$task_data.insertBefore(l, t.$task_bg.nextSibling) : t.$task_data.appendChild(l)), o) {\n            var d = t.getTotalHeight();\n            s.timeline_placeholder && (d = s.timeline_placeholder.height || t.$task_data.offsetHeight || 99999), e.render(l, s, t.getScale(), d, t.getItemHeight(a ? a.id : null));\n          }\n        } else s.static_background && t.$task_bg_static && t.$task_bg_static.parentNode && t.$task_bg_static.parentNode.removeChild(t.$task_bg_static);\n      }\n    }), this.attachEvent(\"onDestroy\", function () {}), this._initStaticBackgroundRender = function () {});\n  },\n  _clearLayers: function (t) {\n    var e = this.$gantt.$services.getService(\"layers\"),\n      n = e.getDataRender(this.$config.bind),\n      i = e.getDataRender(this.$config.bindLinks);\n    if (this._taskLayers) for (var a = 0; a < this._taskLayers.length; a++) n.removeLayer(this._taskLayers[a]);\n    if (this._linkLayers) for (a = 0; a < this._linkLayers.length; a++) i.removeLayer(this._linkLayers[a]);\n    this._linkLayers = [], this._taskLayers = [];\n  },\n  _render_tasks_scales: function () {\n    var t = this.$getConfig(),\n      e = \"\",\n      n = 0,\n      i = 0,\n      a = this.$gantt.getState();\n    if (this.isVisible()) {\n      var r = this.$scaleHelper,\n        s = this._getScales();\n      i = t.scale_height;\n      var o = this.$config.width;\n      t.autosize != \"x\" && t.autosize != \"xy\" || (o = Math.max(t.autosize_min_width, 0));\n      var l = r.prepareConfigs(s, t.min_column_width, o, i - 1, a.min_date, a.max_date, t.rtl),\n        d = this._tasks = l[l.length - 1];\n      this._scales = l, this._posFromDateCache = {}, e = this._getScaleChunkHtml(l, 0, this.$config.width), n = d.full_width + \"px\", i += \"px\";\n    }\n    this.$task_scale.style.height = i, this.$task_data.style.width = this.$task_scale.style.width = n, this.$task_scale.innerHTML = e;\n  },\n  _getScaleChunkHtml: function (t, e, n) {\n    for (var i = [], a = this.$gantt.templates.scale_row_class, r = 0; r < t.length; r++) {\n      var s = \"gantt_scale_line\",\n        o = a(t[r]);\n      o && (s += \" \" + o), i.push('<div class=\"' + s + '\" style=\"height:' + t[r].height + \"px;position:relative;line-height:\" + t[r].height + 'px\">' + this._prepareScaleHtml(t[r], e, n, r) + \"</div>\");\n    }\n    return i.join(\"\");\n  },\n  _prepareScaleHtml: function (t, e, n, i) {\n    var a = this.$getConfig(),\n      r = this.$gantt.templates,\n      s = [],\n      o = null,\n      l = null,\n      d = t.format || t.template || t.date;\n    typeof d == \"string\" && (d = this.$gantt.date.date_to_str(d));\n    var c = 0,\n      u = t.count;\n    !a.smart_scales || isNaN(e) || isNaN(n) || (c = At(t.left, e), u = At(t.left, n) + 1), l = t.css || function () {}, !t.css && a.inherit_scale_class && (l = r.scale_cell_class);\n    for (var h = c; h < u && t.trace_x[h]; h++) {\n      o = new Date(t.trace_x[h]);\n      var g = d.call(this, o),\n        f = t.width[h];\n      t.height;\n      var y = t.left[h],\n        v = \"\",\n        b = \"\",\n        _ = \"\";\n      if (f) {\n        v = \"width:\" + f + \"px;\" + (a.smart_scales ? \"position:absolute;left:\" + y + \"px\" : \"\");\n        const p = this.getViewPort(),\n          k = (a.scales[i] || {}).sticky;\n        let x = \"\";\n        const $ = 70;\n        if (k !== !1 && f > $ || k === !0) {\n          if (y < p.x && y + f / 2 - $ / 2 < p.x) x = ` style='position:absolute;left: ${p.x - y + 10}px;' `;else if (y + f / 2 + $ / 2 > p.x_end && f > $) {\n            let w = p.x_end - y - 10,\n              S = \"-100%\";\n            w < $ && (w = $, S = `-${w}px`), x = ` style='position:absolute;left: ${w}px;transform: translate(${S},0);' `;\n          }\n        }\n        _ = \"gantt_scale_cell\" + (h == t.count - 1 ? \" gantt_last_cell\" : \"\"), (b = l.call(this, o)) && (_ += \" \" + b);\n        var m = `<div class='${_}' ${this.$gantt._waiAria.getTimelineCellAttr(g)} style='${v}'><span ${x}>${g}</span></div>`;\n        s.push(m);\n      }\n    }\n    return s.join(\"\");\n  },\n  dateFromPos: function (t) {\n    var e = this._tasks;\n    if (t < 0 || t > e.full_width || !e.full_width) return null;\n    var n = At(this._tasks.left, t),\n      i = this._tasks.left[n],\n      a = e.width[n] || e.col_width,\n      r = 0;\n    a && (r = (t - i) / a, e.rtl && (r = 1 - r));\n    var s = 0;\n    return r && (s = this._getColumnDuration(e, e.trace_x[n])), new Date(e.trace_x[n].valueOf() + Math.round(r * s));\n  },\n  posFromDate: function (t) {\n    if (!this.isVisible() || !t) return 0;\n    var e = String(t.valueOf());\n    if (this._posFromDateCache[e] !== void 0) return this._posFromDateCache[e];\n    var n = this.columnIndexByDate(t);\n    this.$gantt.assert(n >= 0, \"Invalid day index\");\n    var i = Math.floor(n),\n      a = n % 1,\n      r = this._tasks.left[Math.min(i, this._tasks.width.length - 1)];\n    i == this._tasks.width.length && (r += this._tasks.width[this._tasks.width.length - 1]), a && (i < this._tasks.width.length ? r += this._tasks.width[i] * (a % 1) : r += 1);\n    var s = Math.round(r);\n    return this._posFromDateCache[e] = s, Math.round(s);\n  },\n  _getNextVisibleColumn: function (t, e, n) {\n    for (var i = +e[t], a = t; n[i];) i = +e[++a];\n    return a;\n  },\n  _getPrevVisibleColumn: function (t, e, n) {\n    for (var i = +e[t], a = t; n[i];) i = +e[--a];\n    return a;\n  },\n  _getClosestVisibleColumn: function (t, e, n) {\n    var i = this._getNextVisibleColumn(t, e, n);\n    return e[i] || (i = this._getPrevVisibleColumn(t, e, n)), i;\n  },\n  columnIndexByDate: function (t) {\n    var e = new Date(t).valueOf(),\n      n = this._tasks.trace_x_ascending,\n      i = this._tasks.ignore_x,\n      a = this.$gantt.getState();\n    if (e <= a.min_date) return this._tasks.rtl ? n.length : 0;\n    if (e >= a.max_date) return this._tasks.rtl ? 0 : n.length;\n    var r = At(n, e),\n      s = this._getClosestVisibleColumn(r, n, i),\n      o = n[s],\n      l = this._tasks.trace_index_transition;\n    if (!o) return l ? l[0] : 0;\n    var d = (t - n[s]) / this._getColumnDuration(this._tasks, n[s]);\n    return l ? l[s] + (1 - d) : s + d;\n  },\n  getItemPosition: function (t, e, n) {\n    var i, a, r;\n    let s = e || t.start_date || t.$auto_start_date,\n      o = n || t.end_date || t.$auto_end_date;\n    return this._tasks.rtl ? (a = this.posFromDate(s), i = this.posFromDate(o)) : (i = this.posFromDate(s), a = this.posFromDate(o)), r = Math.max(a - i, 0), {\n      left: i,\n      top: this.getItemTop(t.id),\n      height: this.getBarHeight(t.id),\n      width: r,\n      rowHeight: this.getItemHeight(t.id)\n    };\n  },\n  getBarHeight: function (t, e) {\n    var n = this.$getConfig(),\n      i = this.$config.rowStore.getItem(t),\n      a = i.task_height || i.bar_height || n.bar_height || n.task_height,\n      r = this.getItemHeight(t);\n    return a == \"full\" && (a = r - (n.bar_height_padding || 3)), a = Math.min(a, r), e && (a = Math.round(a / Math.sqrt(2))), Math.max(a, 0);\n  },\n  getScale: function () {\n    return this._tasks;\n  },\n  _getScales: function () {\n    var t = this.$getConfig(),\n      e = this.$scaleHelper,\n      n = [e.primaryScale(t)].concat(e.getSubScales(t));\n    return e.sortScales(n), n;\n  },\n  _getColumnDuration: function (t, e) {\n    return this.$gantt.date.add(e, t.step, t.unit) - e;\n  },\n  _bindStore: function () {\n    if (this.$config.bind) {\n      var t = this.$gantt.getDatastore(this.$config.bind);\n      if (this.$config.rowStore = t, t && !t._timelineCacheAttached) {\n        var e = this;\n        t._timelineCacheAttached = t.attachEvent(\"onBeforeFilter\", function () {\n          e._resetTopPositionHeight();\n        });\n      }\n    }\n  },\n  _unbindStore: function () {\n    if (this.$config.bind) {\n      var t = this.$gantt.getDatastore(this.$config.bind);\n      t && t._timelineCacheAttached && (t.detachEvent(t._timelineCacheAttached), t._timelineCacheAttached = !1);\n    }\n  },\n  refresh: function () {\n    this._bindStore(), this.$config.bindLinks && (this.$config.linkStore = this.$gantt.getDatastore(this.$config.bindLinks)), this._resetTopPositionHeight(), this._resetHeight(), this._initStaticBackgroundRender(), this._render_tasks_scales();\n  },\n  destructor: function () {\n    var t = this.$gantt;\n    this._clearLayers(t), this._unbindStore(), this.$task = null, this.$task_scale = null, this.$task_data = null, this.$task_bg = null, this.$task_links = null, this.$task_bars = null, this.$gantt = null, this.$config.rowStore && (this.$config.rowStore.detachEvent(this._staticBgHandler), this.$config.rowStore = null), this.$config.linkStore && (this.$config.linkStore = null), this._timelineDragScroll && (this._timelineDragScroll.destructor(), this._timelineDragScroll = null), this.callEvent(\"onDestroy\", []), this.detachAllEvents();\n  }\n};\nclass ba {\n  constructor(e) {\n    this._scrollOrder = 0;\n    const {\n      gantt: n,\n      grid: i,\n      dnd: a,\n      getCurrentX: r\n    } = e;\n    this.$gantt = n, this.$grid = i, this._dnd = a, this.getCurrentX = r, this._scrollView = this.$gantt.$ui.getView(this.$grid.$config.scrollX), this.attachEvents();\n  }\n  attachEvents() {\n    this.isScrollable() && (this._dnd.attachEvent(\"onDragMove\", (e, n) => {\n      const i = this.$grid.$grid.getBoundingClientRect(),\n        a = i.right,\n        r = i.left,\n        s = this.getCurrentX(n.clientX);\n      return s >= a - 20 && (this.autoscrollRight(), this.autoscrollStart()), s <= r + 20 && (this.autoscrollLeft(), this.autoscrollStart()), s < a - 20 && s > r + 20 && this.autoscrollStop(), !0;\n    }), this._dnd.attachEvent(\"onDragEnd\", () => {\n      this.autoscrollStop();\n    }));\n  }\n  autoscrollStart() {\n    if (this._scrollOrder === 0) return;\n    const e = 10 * this._scrollOrder,\n      n = this._scrollView.getScrollState();\n    this._scrollView.scrollTo(n.position + e), setTimeout(() => {\n      this.autoscrollStart();\n    }, 50);\n  }\n  autoscrollRight() {\n    this._scrollOrder = 1;\n  }\n  autoscrollLeft() {\n    this._scrollOrder = -1;\n  }\n  autoscrollStop() {\n    this._scrollOrder = 0;\n  }\n  getCorrection() {\n    return this.isScrollable() ? this._scrollView.getScrollState().position : 0;\n  }\n  isScrollable() {\n    return !!this.$grid.$config.scrollable;\n  }\n}\nconst qe = \"data-column-id\";\nclass xa {\n  constructor(e, n) {\n    this._targetMarker = null, this.calculateCurrentPosition = i => {\n      const a = this.$grid.$grid.getBoundingClientRect(),\n        r = a.right,\n        s = a.left;\n      let o = i;\n      return o > r && (o = r), o < s && (o = s), o;\n    }, this.$gantt = e, this.$grid = n;\n  }\n  init() {\n    const e = this.$gantt.$services.getService(\"dnd\");\n    this._dnd = new e(this.$grid.$grid_scale, {\n      updates_per_second: 60\n    }), this._scrollableGrid = new ba({\n      gantt: this.$gantt,\n      grid: this.$grid,\n      dnd: this._dnd,\n      getCurrentX: this.calculateCurrentPosition\n    }), this.attachEvents();\n  }\n  attachEvents() {\n    this._dnd.attachEvent(\"onBeforeDragStart\", (e, n) => {\n      if (this._draggedCell = this.$gantt.utils.dom.closest(n.target, \".gantt_grid_head_cell\"), !this._draggedCell) return;\n      const i = this.$grid.$getConfig().columns,\n        a = this._draggedCell.getAttribute(qe);\n      let r, s;\n      return i.map(function (o, l) {\n        o.name === a && (r = o, s = l);\n      }), this.$grid.callEvent(\"onBeforeColumnDragStart\", [{\n        draggedColumn: r,\n        draggedIndex: s\n      }]) !== !1 && !(!this._draggedCell || !r) && (this._gridConfig = this.$grid.$getConfig(), this._originAutoscroll = this.$gantt.config.autoscroll, this.$gantt.config.autoscroll = !1, !0);\n    }), this._dnd.attachEvent(\"onAfterDragStart\", (e, n) => {\n      this._draggedCell && (this._dnd.config.column = this._draggedCell.getAttribute(qe), this._dnd.config.marker.innerHTML = this._draggedCell.outerHTML, this._dnd.config.marker.classList.add(\"gantt_column_drag_marker\"), this._dnd.config.marker.style.height = this._gridConfig.scale_height + \"px\", this._dnd.config.marker.style.lineHeight = this._gridConfig.scale_height + \"px\", this._draggedCell.classList.add(\"gantt_grid_head_cell_dragged\"));\n    }), this._dnd.attachEvent(\"onDragMove\", (e, n) => {\n      if (!this._draggedCell) return;\n      this._dragX = n.clientX;\n      const i = this.calculateCurrentPosition(n.clientX),\n        a = this.findColumnsIndexes();\n      return this.setMarkerPosition(i), this.drawTargetMarker(a), !0;\n    }), this._dnd.attachEvent(\"onDragEnd\", () => {\n      if (!this._draggedCell) return;\n      const e = this.findColumnsIndexes(),\n        n = e.targetIndex,\n        i = e.draggedIndex,\n        a = this.$grid.$getConfig().columns,\n        r = a[i],\n        s = a[n];\n      if (this.$grid.callEvent(\"onColumnDragMove\", [{\n        draggedColumn: r,\n        targetColumn: s,\n        draggedIndex: i,\n        targetIndex: n\n      }]) === !1) return this.cleanTargetMarker(), void this.$gantt.render();\n      this.$gantt.config.autoscroll = this._originAutoscroll, this._draggedCell.classList.remove(\"gantt_grid_head_cell_dragged\"), this.cleanTargetMarker(), this.reorderColumns();\n    });\n  }\n  reorderColumns() {\n    const {\n        targetIndex: e,\n        draggedIndex: n\n      } = this.findColumnsIndexes(),\n      i = this.$grid.$getConfig().columns,\n      a = i[n],\n      r = i[e];\n    this.$grid.callEvent(\"onBeforeColumnReorder\", [{\n      draggedColumn: a,\n      targetColumn: r,\n      draggedIndex: n,\n      targetIndex: e\n    }]) !== !1 && e !== n && (i.splice(n, 1), i.splice(e, 0, a), this.$gantt.render(), this.$grid.callEvent(\"onAfterColumnReorder\", [{\n      draggedColumn: a,\n      targetColumn: r,\n      draggedIndex: n,\n      targetIndex: e\n    }]));\n  }\n  findColumnsIndexes() {\n    const e = this._dnd.config.column,\n      n = this.$grid.$getConfig().columns;\n    let i, a, r, s;\n    const o = {\n      startX: 0,\n      endX: 0\n    };\n    let l,\n      d = 0,\n      c = n.length - 1,\n      u = (f, y) => f <= y,\n      h = f => ++f;\n    this.$gantt.config.rtl && (d = n.length - 1, c = 0, u = (f, y) => f >= y, h = f => --f);\n    const g = this._dragX - this.$grid.$grid.getBoundingClientRect().left + this._scrollableGrid.getCorrection();\n    for (let f = d; u(f, c) && (i === void 0 || a === void 0); f = h(f)) n[f].hide || (o.startX = o.endX, o.endX += n[f].width, g >= o.startX && (g <= o.endX || !u(h(f), c)) && (i = f, r = o.startX, s = o.endX, l = (g - o.startX) / (o.endX - o.startX)), e === n[f].name && (a = f));\n    return {\n      targetIndex: i,\n      draggedIndex: a,\n      xBefore: r,\n      xAfter: s,\n      columnRelativePos: l\n    };\n  }\n  setMarkerPosition(e, n = 10) {\n    const {\n        marker: i\n      } = this._dnd.config,\n      a = this._dnd._obj.getBoundingClientRect();\n    i.style.top = `${a.y + n}px`, i.style.left = `${e}px`;\n  }\n  drawTargetMarker({\n    targetIndex: e,\n    draggedIndex: n,\n    xBefore: i,\n    xAfter: a,\n    columnRelativePos: r\n  }) {\n    let s;\n    this._targetMarker || (this._targetMarker = document.createElement(\"div\"), wt(this._targetMarker, \"gantt_grid_target_marker\"), this._targetMarker.style.display = \"none\", this._targetMarker.style.height = `${this._gridConfig.scale_height}px`), this._targetMarker.parentNode || this.$grid.$grid_scale.appendChild(this._targetMarker), s = e > n ? a : e < n ? i : r > 0.5 ? a : i, this._targetMarker.style.left = `${s}px`, this._targetMarker.style.display = \"block\";\n  }\n  cleanTargetMarker() {\n    this._targetMarker && this._targetMarker.parentNode && this.$grid.$grid_scale.removeChild(this._targetMarker), this._targetMarker = null;\n  }\n}\nfunction Te(t) {\n  var e = [];\n  return {\n    delegate: function (n, i, a, r) {\n      e.push([n, i, a, r]), t.$services.getService(\"mouseEvents\").delegate(n, i, a, r);\n    },\n    destructor: function () {\n      for (var n = t.$services.getService(\"mouseEvents\"), i = 0; i < e.length; i++) {\n        var a = e[i];\n        n.detach(a[0], a[1], a[2], a[3]);\n      }\n      e = [];\n    }\n  };\n}\nvar xe = function (t, e, n, i) {\n  this.$config = L({}, e || {}), this.$gantt = i, this.$parent = t, ot(this), this.$state = {}, L(this, bn(this));\n};\nxe.prototype = {\n  init: function (t) {\n    var e = this.$gantt,\n      n = e._waiAria.gridAttrString(),\n      i = e._waiAria.gridDataAttrString(),\n      a = this.$getConfig(),\n      r = a.reorder_grid_columns || !1;\n    this.$config.reorder_grid_columns !== void 0 && (r = this.$config.reorder_grid_columns), t.innerHTML = \"<div class='gantt_grid' style='height:inherit;width:inherit;' \" + n + \"></div>\", this.$grid = t.childNodes[0], this.$grid.innerHTML = \"<div class='gantt_grid_scale' \" + e._waiAria.gridScaleRowAttrString() + \"></div><div class='gantt_grid_data' \" + i + \"></div>\", this.$grid_scale = this.$grid.childNodes[0], this.$grid_data = this.$grid.childNodes[1];\n    var s = a[this.$config.bind + \"_attribute\"];\n    if (!s && this.$config.bind && (s = \"data-\" + this.$config.bind + \"-id\"), this.$config.item_attribute = s || null, !this.$config.layers) {\n      var o = this._createLayerConfig();\n      this.$config.layers = o;\n    }\n    var l = {\n      init: function () {},\n      doOnRender: function () {}\n    };\n    this._renderHeaderResizers = l.doOnRender, this._mouseDelegates = Te(e);\n    var d = function (c, u) {\n      var h = {\n        row_before_start: c.bind(function (g, f, y) {\n          var v = u.$getConfig(),\n            b = u.$config.rowStore;\n          if (!et(y, v.task_grid_row_resizer_attribute)) return !1;\n          var _ = this.locate(y, v.task_grid_row_resizer_attribute),\n            m = b.getItem(_);\n          return u.callEvent(\"onBeforeRowResize\", [m]) !== !1 && void 0;\n        }, c),\n        row_after_start: c.bind(function (g, f, y) {\n          var v = u.$getConfig(),\n            b = this.locate(y, v.task_grid_row_resizer_attribute);\n          g.config.marker.innerHTML = \"\", g.config.marker.className += \" gantt_row_grid_resize_area\", g.config.marker.style.width = u.$grid.offsetWidth + \"px\", g.config.drag_id = b;\n        }, c),\n        row_drag_move: c.bind(function (g, f, y) {\n          var v = u.$config.rowStore,\n            b = u.$getConfig(),\n            _ = g.config,\n            m = _.drag_id,\n            p = u.getItemHeight(m),\n            k = u.getItemTop(m) - f.scrollTop,\n            x = U(u.$grid_data),\n            $ = parseInt(_.marker.style.top, 10),\n            w = k + x.y,\n            S = 0,\n            T = b.min_task_grid_row_height;\n          return (S = $ - w) < T && (S = T), _.marker.style.left = x.x + \"px\", _.marker.style.top = w - 1 + \"px\", _.marker.style.height = Math.abs(S) + 1 + \"px\", _.marker_height = S, u.callEvent(\"onRowResize\", [m, v.getItem(m), S + p]), !0;\n        }, c),\n        row_drag_end: c.bind(function (g, f, y) {\n          var v = u.$config.rowStore,\n            b = g.config,\n            _ = b.drag_id,\n            m = v.getItem(_),\n            p = u.getItemHeight(_),\n            k = b.marker_height;\n          u.callEvent(\"onBeforeRowResizeEnd\", [_, m, k]) !== !1 && m.row_height != k && (m.row_height = k, v.updateItem(_), u.callEvent(\"onAfterRowResize\", [_, m, p, k]), this.render());\n        }, c)\n      };\n      return {\n        init: function () {\n          var g = c.$services.getService(\"dnd\"),\n            f = u.$getConfig(),\n            y = new g(u.$grid_data, {\n              updates_per_second: 60\n            });\n          c.defined(f.dnd_sensitivity) && (y.config.sensitivity = f.dnd_sensitivity), y.attachEvent(\"onBeforeDragStart\", function (v, b) {\n            return h.row_before_start(y, v, b);\n          }), y.attachEvent(\"onAfterDragStart\", function (v, b) {\n            return h.row_after_start(y, v, b);\n          }), y.attachEvent(\"onDragMove\", function (v, b) {\n            return h.row_drag_move(y, v, b);\n          }), y.attachEvent(\"onDragEnd\", function (v, b) {\n            return h.row_drag_end(y, v, b);\n          });\n        }\n      };\n    }(e, this);\n    d.init(), this._addLayers(this.$gantt), this._initEvents(), r && (this._columnDND = new xa(e, this), this._columnDND.init()), this.callEvent(\"onReady\", []);\n  },\n  _validateColumnWidth: function (t, e) {\n    var n = t[e];\n    if (n && n != \"*\") {\n      var i = this.$gantt,\n        a = 1 * n;\n      isNaN(a) ? i.assert(!1, \"Wrong \" + e + \" value of column \" + t.name) : t[e] = a;\n    }\n  },\n  setSize: function (t, e) {\n    this.$config.width = this.$state.width = t, this.$config.height = this.$state.height = e;\n    for (var n, i = this.getGridColumns(), a = 0, r = (d = this.$getConfig()).grid_elastic_columns, s = 0, o = i.length; s < o; s++) this._validateColumnWidth(i[s], \"min_width\"), this._validateColumnWidth(i[s], \"max_width\"), this._validateColumnWidth(i[s], \"width\"), a += 1 * i[s].width;\n    if (!isNaN(a) && this.$config.scrollable || (a = n = this._setColumnsWidth(t + 1)), this.$config.scrollable && r && !isNaN(a)) {\n      let u = \"width\";\n      r == \"min_width\" && (u = \"min_width\");\n      let h = 0;\n      i.forEach(function (g) {\n        h += g[u] || d.min_grid_column_width;\n      });\n      var l = Math.max(h, t);\n      a = this._setColumnsWidth(l), n = t;\n    }\n    this.$config.scrollable ? (this.$grid_scale.style.width = a + \"px\", this.$grid_data.style.width = a + \"px\") : (this.$grid_scale.style.width = \"inherit\", this.$grid_data.style.width = \"inherit\"), this.$config.width -= 1;\n    var d = this.$getConfig();\n    n !== t && (n !== void 0 ? (d.grid_width = n, this.$config.width = n - 1) : isNaN(a) || (this._setColumnsWidth(a), d.grid_width = a, this.$config.width = a - 1));\n    var c = Math.max(this.$state.height - d.scale_height, 0);\n    this.$grid_data.style.height = c + \"px\", this.refresh();\n  },\n  getSize: function () {\n    var t = this.$getConfig(),\n      e = this.$config.rowStore ? this.getTotalHeight() : 0,\n      n = this._getGridWidth();\n    return {\n      x: this.$state.width,\n      y: this.$state.height,\n      contentX: this.isVisible() ? n : 0,\n      contentY: this.isVisible() ? t.scale_height + e : 0,\n      scrollHeight: this.isVisible() ? e : 0,\n      scrollWidth: this.isVisible() ? n : 0\n    };\n  },\n  _bindStore: function () {\n    if (this.$config.bind) {\n      var t = this.$gantt.getDatastore(this.$config.bind);\n      if (this.$config.rowStore = t, t && !t._gridCacheAttached) {\n        var e = this;\n        t._gridCacheAttached = t.attachEvent(\"onBeforeFilter\", function () {\n          e._resetTopPositionHeight();\n        });\n      }\n    }\n  },\n  _unbindStore: function () {\n    if (this.$config.bind) {\n      var t = this.$gantt.getDatastore(this.$config.bind);\n      t && t._gridCacheAttached && (t.detachEvent(t._gridCacheAttached), t._gridCacheAttached = !1);\n    }\n  },\n  refresh: function () {\n    this._bindStore(), this._resetTopPositionHeight(), this._resetHeight(), this._initSmartRenderingPlaceholder(), this._calculateGridWidth(), this._renderGridHeader();\n  },\n  getViewPort: function () {\n    var t = this.$config.scrollLeft || 0,\n      e = this.$config.scrollTop || 0,\n      n = this.$config.height || 0,\n      i = this.$config.width || 0;\n    return {\n      y: e,\n      y_end: e + n,\n      x: t,\n      x_end: t + i,\n      height: n,\n      width: i\n    };\n  },\n  scrollTo: function (t, e) {\n    if (this.isVisible()) {\n      var n = !1;\n      this.$config.scrollTop = this.$config.scrollTop || 0, this.$config.scrollLeft = this.$config.scrollLeft || 0, 1 * t == t && (this.$config.scrollLeft = this.$state.scrollLeft = this.$grid.scrollLeft = t, n = !0), 1 * e == e && (this.$config.scrollTop = this.$state.scrollTop = this.$grid_data.scrollTop = e, n = !0), n && this.callEvent(\"onScroll\", [this.$config.scrollLeft, this.$config.scrollTop]);\n    }\n  },\n  getColumnIndex: function (t, e) {\n    for (var n = this.$getConfig().columns, i = 0, a = 0; a < n.length; a++) if (e && n[a].hide && i++, n[a].name == t) return a - i;\n    return null;\n  },\n  getColumn: function (t) {\n    var e = this.getColumnIndex(t);\n    return e === null ? null : this.$getConfig().columns[e];\n  },\n  getGridColumns: function () {\n    return this.$getConfig().columns.slice();\n  },\n  isVisible: function () {\n    return this.$parent && this.$parent.$config ? !this.$parent.$config.hidden : this.$grid.offsetWidth;\n  },\n  _createLayerConfig: function () {\n    var t = this.$gantt,\n      e = this;\n    return [{\n      renderer: t.$ui.layers.gridLine(),\n      container: this.$grid_data,\n      filter: [function () {\n        return e.isVisible();\n      }]\n    }, {\n      renderer: t.$ui.layers.gridTaskRowResizer(),\n      container: this.$grid_data,\n      append: !0,\n      filter: [function () {\n        return t.config.resize_rows;\n      }]\n    }];\n  },\n  _addLayers: function (t) {\n    if (this.$config.bind) {\n      this._taskLayers = [];\n      var e = this,\n        n = this.$gantt.$services.getService(\"layers\"),\n        i = n.getDataRender(this.$config.bind);\n      i || (i = n.createDataRender({\n        name: this.$config.bind,\n        defaultContainer: function () {\n          return e.$grid_data;\n        }\n      }));\n      for (var a = this.$config.layers, r = 0; a && r < a.length; r++) {\n        var s = a[r];\n        s.view = this;\n        var o = i.addLayer(s);\n        this._taskLayers.push(o);\n      }\n      this._bindStore(), this._initSmartRenderingPlaceholder();\n    }\n  },\n  _refreshPlaceholderOnStoreUpdate: function (t) {\n    var e = this.$getConfig(),\n      n = this.$config.rowStore;\n    if (n && t === null && this.isVisible() && e.smart_rendering) {\n      var i;\n      if (this.$config.scrollY) {\n        var a = this.$gantt.$ui.getView(this.$config.scrollY);\n        a && (i = a.getScrollState().scrollSize);\n      }\n      if (i || (i = n ? this.getTotalHeight() : 0), i) {\n        this.$rowsPlaceholder && this.$rowsPlaceholder.parentNode && this.$rowsPlaceholder.parentNode.removeChild(this.$rowsPlaceholder);\n        var r = this.$rowsPlaceholder = document.createElement(\"div\");\n        r.style.visibility = \"hidden\", r.style.height = i + \"px\", r.style.width = \"1px\", this.$grid_data.appendChild(r);\n      }\n    }\n  },\n  _initSmartRenderingPlaceholder: function () {\n    var t = this.$config.rowStore;\n    t && (this._initSmartRenderingPlaceholder = function () {}, this._staticBgHandler = t.attachEvent(\"onStoreUpdated\", R(this._refreshPlaceholderOnStoreUpdate, this)));\n  },\n  _initEvents: function () {\n    var t = this.$gantt;\n    this._mouseDelegates.delegate(\"click\", \"gantt_close\", t.bind(function (e, n, i) {\n      var a = this.$config.rowStore;\n      if (!a) return !0;\n      var r = et(e, this.$config.item_attribute);\n      return r && a.close(r.getAttribute(this.$config.item_attribute)), !1;\n    }, this), this.$grid), this._mouseDelegates.delegate(\"click\", \"gantt_open\", t.bind(function (e, n, i) {\n      var a = this.$config.rowStore;\n      if (!a) return !0;\n      var r = et(e, this.$config.item_attribute);\n      return r && a.open(r.getAttribute(this.$config.item_attribute)), !1;\n    }, this), this.$grid);\n  },\n  _clearLayers: function (t) {\n    var e = this.$gantt.$services.getService(\"layers\").getDataRender(this.$config.bind);\n    if (this._taskLayers) for (var n = 0; n < this._taskLayers.length; n++) e.removeLayer(this._taskLayers[n]);\n    this._taskLayers = [];\n  },\n  _getColumnWidth: function (t, e, n) {\n    var i = t.min_width || e.min_grid_column_width,\n      a = Math.max(n, i || 10);\n    return t.max_width && (a = Math.min(a, t.max_width)), a;\n  },\n  _checkGridColumnMinWidthLimits: function (t, e) {\n    for (var n = 0, i = t.length; n < i; n++) {\n      var a = 1 * t[n].width;\n      !t[n].min_width && a < e.min_grid_column_width && (t[n].min_width = a);\n    }\n  },\n  _getGridWidthLimits: function () {\n    for (var t = this.$getConfig(), e = this.getGridColumns(), n = 0, i = 0, a = 0; a < e.length; a++) n += e[a].min_width ? e[a].min_width : t.min_grid_column_width, i !== void 0 && (i = e[a].max_width ? i + e[a].max_width : void 0);\n    return this._checkGridColumnMinWidthLimits(e, t), [n, i];\n  },\n  _setColumnsWidth: function (t, e) {\n    var n = this.$getConfig(),\n      i = this.getGridColumns(),\n      a = 0,\n      r = t;\n    e = window.isNaN(e) ? -1 : e;\n    for (var s = 0, o = i.length; s < o; s++) a += 1 * i[s].width;\n    if (window.isNaN(a)) for (this._calculateGridWidth(), a = 0, s = 0, o = i.length; s < o; s++) a += 1 * i[s].width;\n    var l = r - a,\n      d = 0;\n    for (s = 0; s < e + 1; s++) d += i[s].width;\n    for (a -= d, s = e + 1; s < i.length; s++) {\n      var c = i[s],\n        u = Math.round(l * (c.width / a));\n      l < 0 ? c.min_width && c.width + u < c.min_width ? u = c.min_width - c.width : !c.min_width && n.min_grid_column_width && c.width + u < n.min_grid_column_width && (u = n.min_grid_column_width - c.width) : c.max_width && c.width + u > c.max_width && (u = c.max_width - c.width), a -= c.width, c.width += u, l -= u;\n    }\n    for (var h = l > 0 ? 1 : -1; l > 0 && h === 1 || l < 0 && h === -1;) {\n      var g = l;\n      for (s = e + 1; s < i.length; s++) {\n        var f;\n        if ((f = i[s].width + h) == this._getColumnWidth(i[s], n, f) && (l -= h, i[s].width = f), !l) break;\n      }\n      if (g == l) break;\n    }\n    return l && e > -1 && (f = i[e].width + l) == this._getColumnWidth(i[e], n, f) && (i[e].width = f), this._getColsTotalWidth();\n  },\n  _getColsTotalWidth: function () {\n    for (var t = this.getGridColumns(), e = 0, n = 0; n < t.length; n++) {\n      var i = parseFloat(t[n].width);\n      if (window.isNaN(i)) return !1;\n      e += i;\n    }\n    return e;\n  },\n  _calculateGridWidth: function () {\n    for (var t = this.$getConfig(), e = this.getGridColumns(), n = 0, i = [], a = [], r = 0; r < e.length; r++) {\n      var s = parseFloat(e[r].width);\n      window.isNaN(s) && (s = t.min_grid_column_width || 10, i.push(r)), a[r] = s, n += s;\n    }\n    var o = this._getGridWidth() + 1;\n    if (t.autofit || i.length) {\n      var l = o - n;\n      if (t.autofit && !t.grid_elastic_columns) for (r = 0; r < a.length; r++) {\n        var d = Math.round(l / (a.length - r));\n        a[r] += d, (c = this._getColumnWidth(e[r], t, a[r])) != a[r] && (d = c - a[r], a[r] = c), l -= d;\n      } else if (i.length) for (r = 0; r < i.length; r++) {\n        d = Math.round(l / (i.length - r));\n        var c,\n          u = i[r];\n        a[u] += d, (c = this._getColumnWidth(e[u], t, a[u])) != a[u] && (d = c - a[u], a[u] = c), l -= d;\n      }\n      for (r = 0; r < a.length; r++) e[r].width = a[r];\n    } else {\n      var h = o != n;\n      this.$config.width = n - 1, t.grid_width = n, h && this.$parent._setContentSize(this.$config.width, null);\n    }\n  },\n  _renderGridHeader: function () {\n    var t = this.$gantt,\n      e = this.$getConfig(),\n      n = this.$gantt.locale,\n      i = this.$gantt.templates,\n      a = this.getGridColumns();\n    e.rtl && (a = a.reverse());\n    for (var r = [], s = 0, o = n.labels, l = e.scale_height - 1, d = 0; d < a.length; d++) {\n      var c = d == a.length - 1,\n        u = a[d];\n      u.name || (u.name = t.uid() + \"\");\n      var h = 1 * u.width,\n        g = this._getGridWidth();\n      c && g > s + h && (u.width = h = g - s), s += h;\n      var f = t._sort && u.name == t._sort.name ? `<div data-column-id=\"${u.name}\" class=\"gantt_sort gantt_${t._sort.direction}\"></div>` : \"\",\n        y = [\"gantt_grid_head_cell\", \"gantt_grid_head_\" + u.name, c ? \"gantt_last_cell\" : \"\", i.grid_header_class(u.name, u)].join(\" \"),\n        v = \"width:\" + (h - (c ? 1 : 0)) + \"px;\",\n        b = u.label || o[\"column_\" + u.name] || o[u.name];\n      b = b || \"\";\n      var _ = \"<div class='\" + y + \"' style='\" + v + \"' \" + t._waiAria.gridScaleCellAttrString(u, b) + \" data-column-id='\" + u.name + \"' column_id='\" + u.name + \"' data-column-name='\" + u.name + \"' data-column-index='\" + d + \"'>\" + b + f + \"</div>\";\n      r.push(_);\n    }\n    this.$grid_scale.style.height = e.scale_height + \"px\", this.$grid_scale.style.lineHeight = l + \"px\", this.$grid_scale.innerHTML = r.join(\"\"), this._renderHeaderResizers && this._renderHeaderResizers();\n  },\n  _getGridWidth: function () {\n    return this.$config.width;\n  },\n  destructor: function () {\n    this._clearLayers(this.$gantt), this._mouseDelegates && (this._mouseDelegates.destructor(), this._mouseDelegates = null), this._unbindStore(), this.$grid = null, this.$grid_scale = null, this.$grid_data = null, this.$gantt = null, this.$config.rowStore && (this.$config.rowStore.detachEvent(this._staticBgHandler), this.$config.rowStore = null), this.callEvent(\"onDestroy\", []), this.detachAllEvents();\n  }\n};\nconst $a = {\n    init: function (t, e) {\n      var n = e.$gantt;\n      n.attachEvent(\"onTaskClick\", function (i, a) {\n        if (n._is_icon_open_click(a)) return !0;\n        var r = t.getState(),\n          s = t.locateCell(a.target);\n        return !s || !t.getEditorConfig(s.columnName) || (t.isVisible() && r.id == s.id && r.columnName == s.columnName || t.startEdit(s.id, s.columnName), !1);\n      }), n.attachEvent(\"onEmptyClick\", function () {\n        return t.isVisible() && t.isChanged() ? t.save() : t.hide(), !0;\n      }), n.attachEvent(\"onTaskDblClick\", function (i, a) {\n        var r = t.getState(),\n          s = t.locateCell(a.target);\n        return !s || !t.isVisible() || s.columnName != r.columnName;\n      });\n    },\n    onShow: function (t, e, n) {\n      var i = n.$gantt;\n      i.ext && i.ext.keyboardNavigation && i.ext.keyboardNavigation.attachEvent(\"onKeyDown\", function (a, r) {\n        var s = i.constants.KEY_CODES,\n          o = !1;\n        return r.keyCode === s.SPACE && t.isVisible() && (o = !0), !o;\n      }), e.onkeydown = function (a) {\n        a = a || window.event;\n        var r = i.constants.KEY_CODES;\n        if (!(a.defaultPrevented || a.shiftKey && a.keyCode != r.TAB)) {\n          var s = !0;\n          switch (a.keyCode) {\n            case i.keys.edit_save:\n              t.save();\n              break;\n            case i.keys.edit_cancel:\n              t.hide();\n              break;\n            case r.UP:\n            case r.DOWN:\n              t.isVisible() && (t.hide(), s = !1);\n              break;\n            case r.TAB:\n              a.shiftKey ? t.editPrevCell(!0) : t.editNextCell(!0);\n              break;\n            default:\n              s = !1;\n          }\n          s && a.preventDefault();\n        }\n      };\n    },\n    onHide: function () {},\n    destroy: function () {}\n  },\n  wa = {\n    init: function (t, e) {\n      var n = t,\n        i = e.$gantt,\n        a = null,\n        r = i.ext.keyboardNavigation;\n      r.attachEvent(\"onBeforeFocus\", function (s) {\n        var o = t.locateCell(s);\n        if (clearTimeout(a), o) {\n          var l = o.columnName,\n            d = o.id,\n            c = n.getState();\n          if (n.isVisible() && c.id == d && c.columnName === l) return !1;\n        }\n        return !0;\n      }), r.attachEvent(\"onFocus\", function (s) {\n        var o = t.locateCell(s),\n          l = t.getState();\n        return clearTimeout(a), !o || o.id == l.id && o.columnName == l.columnName || n.isVisible() && n.save(), !0;\n      }), t.attachEvent(\"onHide\", function () {\n        clearTimeout(a);\n      }), r.attachEvent(\"onBlur\", function () {\n        return a = setTimeout(function () {\n          n.save();\n        }), !0;\n      }), i.attachEvent(\"onTaskDblClick\", function (s, o) {\n        var l = t.getState(),\n          d = t.locateCell(o.target);\n        return !d || !t.isVisible() || d.columnName != l.columnName;\n      }), i.attachEvent(\"onTaskClick\", function (s, o) {\n        if (i._is_icon_open_click(o)) return !0;\n        var l = t.getState(),\n          d = t.locateCell(o.target);\n        return !d || !t.getEditorConfig(d.columnName) || (t.isVisible() && l.id == d.id && l.columnName == d.columnName || t.startEdit(d.id, d.columnName), !1);\n      }), i.attachEvent(\"onEmptyClick\", function () {\n        return n.save(), !0;\n      }), r.attachEvent(\"onKeyDown\", function (s, o) {\n        var l = t.locateCell(o.target),\n          d = !!l && t.getEditorConfig(l.columnName),\n          c = t.getState(),\n          u = i.constants.KEY_CODES,\n          h = o.keyCode,\n          g = !1;\n        switch (h) {\n          case u.ENTER:\n            t.isVisible() ? (t.save(), o.preventDefault(), g = !0) : d && !(o.ctrlKey || o.metaKey || o.shiftKey) && (n.startEdit(l.id, l.columnName), o.preventDefault(), g = !0);\n            break;\n          case u.ESC:\n            t.isVisible() && (t.hide(), o.preventDefault(), g = !0);\n            break;\n          case u.UP:\n          case u.DOWN:\n            break;\n          case u.LEFT:\n          case u.RIGHT:\n            (d && t.isVisible() || c.editorType === \"date\") && (g = !0);\n            break;\n          case u.SPACE:\n            t.isVisible() && (g = !0), d && !t.isVisible() && (n.startEdit(l.id, l.columnName), o.preventDefault(), g = !0);\n            break;\n          case u.DELETE:\n            d && !t.isVisible() ? (n.startEdit(l.id, l.columnName), g = !0) : d && t.isVisible() && (g = !0);\n            break;\n          case u.TAB:\n            if (t.isVisible()) {\n              o.shiftKey ? t.editPrevCell(!0) : t.editNextCell(!0);\n              var f = t.getState();\n              f.id && r.focus({\n                type: \"taskCell\",\n                id: f.id,\n                column: f.columnName\n              }), o.preventDefault(), g = !0;\n            }\n            break;\n          default:\n            if (t.isVisible()) g = !0;else if (h >= 48 && h <= 57 || h > 95 && h < 112 || h >= 64 && h <= 91 || h > 185 && h < 193 || h > 218 && h < 223) {\n              var y = s.modifiers,\n                v = y.alt || y.ctrl || y.meta || y.shift;\n              y.alt || v && r.getCommandHandler(s, \"taskCell\") || d && !t.isVisible() && (n.startEdit(l.id, l.columnName), g = !0);\n            }\n        }\n        return !g;\n      });\n    },\n    onShow: function (t, e, n) {},\n    onHide: function (t, e, n) {\n      const i = n.$gantt;\n      i && i.focus();\n    },\n    destroy: function () {}\n  };\nfunction St(t) {\n  var e = function () {};\n  return e.prototype = {\n    show: function (n, i, a, r) {},\n    hide: function () {},\n    set_value: function (n, i, a, r) {\n      this.get_input(r).value = n;\n    },\n    get_value: function (n, i, a) {\n      return this.get_input(a).value || \"\";\n    },\n    is_changed: function (n, i, a, r) {\n      var s = this.get_value(i, a, r);\n      return s && n && s.valueOf && n.valueOf ? s.valueOf() != n.valueOf() : s != n;\n    },\n    is_valid: function (n, i, a, r) {\n      return !0;\n    },\n    save: function (n, i, a) {},\n    get_input: function (n) {\n      return n.querySelector(\"input\");\n    },\n    focus: function (n) {\n      var i = this.get_input(n);\n      i && (i.focus && i.focus(), i.select && i.select());\n    }\n  }, e;\n}\nfunction Sa(t) {\n  var e = St();\n  function n() {\n    return e.apply(this, arguments) || this;\n  }\n  return W(n, e), L(n.prototype, {\n    show: function (i, a, r, s) {\n      var o = `<div role='cell'><input type='text' name='${a.name}' title='${a.name}'></div>`;\n      s.innerHTML = o;\n    }\n  }, !0), n;\n}\nfunction Ta(t) {\n  var e = St();\n  function n() {\n    return e.apply(this, arguments) || this;\n  }\n  return W(n, e), L(n.prototype, {\n    show: function (i, a, r, s) {\n      var o = r.min || 0,\n        l = r.max || 100,\n        d = `<div role='cell'><input type='number' min='${o}' max='${l}' name='${a.name}' title='${a.name}'></div>`;\n      s.innerHTML = d, s.oninput = function (c) {\n        +c.target.value < o && (c.target.value = o), +c.target.value > l && (c.target.value = l);\n      };\n    },\n    get_value: function (i, a, r) {\n      return this.get_input(r).value || \"\";\n    },\n    is_valid: function (i, a, r, s) {\n      return !isNaN(parseInt(i, 10));\n    }\n  }, !0), n;\n}\nfunction Ea(t) {\n  var e = St();\n  function n() {\n    return e.apply(this, arguments) || this;\n  }\n  return W(n, e), L(n.prototype, {\n    show: function (i, a, r, s) {\n      for (var o = `<div role='cell'><select name='${a.name}' title='${a.name}'>`, l = [], d = r.options || [], c = 0; c < d.length; c++) l.push(\"<option value='\" + r.options[c].key + \"'>\" + d[c].label + \"</option>\");\n      o += l.join(\"\") + \"</select></div>\", s.innerHTML = o;\n    },\n    get_input: function (i) {\n      return i.querySelector(\"select\");\n    }\n  }, !0), n;\n}\nfunction Ca(t) {\n  var e = St(),\n    n = \"%Y-%m-%d\",\n    i = null,\n    a = null;\n  function r() {\n    return e.apply(this, arguments) || this;\n  }\n  return W(r, e), L(r.prototype, {\n    show: function (s, o, l, d) {\n      i || (i = t.date.date_to_str(n)), a || (a = t.date.str_to_date(n));\n      var c = null,\n        u = null;\n      c = typeof l.min == \"function\" ? l.min(s, o) : l.min, u = typeof l.max == \"function\" ? l.max(s, o) : l.max;\n      var h = `<div style='width:140px' role='cell'><input type='date' ${c ? \" min='\" + i(c) + \"' \" : \"\"} ${u ? \" max='\" + i(u) + \"' \" : \"\"} name='${o.name}' title='${o.name}'></div>`;\n      d.innerHTML = h, d.oninput = function (g) {\n        g.target.value && (c || u) && (+t.date.str_to_date(\"%Y-%m-%d\")(g.target.value) < +c && (g.target.value = t.date.date_to_str(\"%Y-%m-%d\")(c)), +t.date.str_to_date(\"%Y-%m-%d\")(g.target.value) > +u && (g.target.value = t.date.date_to_str(\"%Y-%m-%d\")(u)));\n      };\n    },\n    set_value: function (s, o, l, d) {\n      s && s.getFullYear ? this.get_input(d).value = i(s) : this.get_input(d).value = s;\n    },\n    is_valid: function (s, o, l, d) {\n      return !(!s || isNaN(s.getTime()));\n    },\n    get_value: function (s, o, l) {\n      var d;\n      try {\n        d = a(this.get_input(l).value || \"\");\n      } catch {\n        d = null;\n      }\n      return d;\n    }\n  }, !0), r;\n}\nfunction Da(t) {\n  var e = St();\n  function n() {\n    return e.apply(this, arguments) || this;\n  }\n  function i(l) {\n    return l.formatter || t.ext.formatters.linkFormatter();\n  }\n  function a(l, d) {\n    for (var c = (l || \"\").split(d.delimiter || \",\"), u = 0; u < c.length; u++) {\n      var h = c[u].trim();\n      h ? c[u] = h : (c.splice(u, 1), u--);\n    }\n    return c.sort(), c;\n  }\n  function r(l, d, c) {\n    for (var u = l.$target, h = [], g = 0; g < u.length; g++) {\n      var f = c.getLink(u[g]);\n      h.push(i(d).format(f));\n    }\n    return h.join((d.delimiter || \",\") + \" \");\n  }\n  function s(l) {\n    return l.source + \"_\" + l.target + \"_\" + l.type + \"_\" + (l.lag || 0);\n  }\n  function o(l, d, c) {\n    var u = function (v, b, _) {\n        var m = [];\n        return [...new Set(b)].forEach(function (p) {\n          var k = i(_).parse(p);\n          k && (k.target = v, k.id = \"predecessor_generated\", t.isLinkAllowed(k) && (k.id = void 0, m.push(k)));\n        }), m;\n      }(l.id, d, c),\n      h = {};\n    l.$target.forEach(function (v) {\n      var b = t.getLink(v);\n      h[s(b)] = b.id;\n    });\n    var g = [];\n    u.forEach(function (v) {\n      var b = s(v);\n      h[b] ? delete h[b] : g.push(v);\n    });\n    var f = [];\n    for (var y in h) f.push(h[y]);\n    return {\n      add: g,\n      remove: f\n    };\n  }\n  return W(n, e), L(n.prototype, {\n    show: function (l, d, c, u) {\n      var h = `<div role='cell'><input type='text' name='${d.name}' title='${d.name}'></div>`;\n      u.innerHTML = h;\n    },\n    hide: function () {},\n    set_value: function (l, d, c, u) {\n      this.get_input(u).value = r(l, c.editor, t);\n    },\n    get_value: function (l, d, c) {\n      return a(this.get_input(c).value || \"\", d.editor);\n    },\n    save: function (l, d, c) {\n      var u = o(t.getTask(l), this.get_value(l, d, c), d.editor);\n      (u.add.length || u.remove.length) && t.batchUpdate(function () {\n        u.add.forEach(function (h) {\n          t.addLink(h);\n        }), u.remove.forEach(function (h) {\n          t.deleteLink(h);\n        }), t.autoSchedule && t.autoSchedule();\n      });\n    },\n    is_changed: function (l, d, c, u) {\n      var h = this.get_value(d, c, u),\n        g = a(r(l, c.editor, t), c.editor);\n      return h.join() !== g.join();\n    }\n  }, !0), n;\n}\nfunction Aa(t) {\n  var e = St();\n  function n() {\n    return e.apply(this, arguments) || this;\n  }\n  function i(a) {\n    return a.formatter || t.ext.formatters.durationFormatter();\n  }\n  return W(n, e), L(n.prototype, {\n    show: function (a, r, s, o) {\n      var l = `<div role='cell'><input type='text' name='${r.name}' title='${r.name}'></div>`;\n      o.innerHTML = l;\n    },\n    set_value: function (a, r, s, o) {\n      this.get_input(o).value = i(s.editor).format(a);\n    },\n    get_value: function (a, r, s) {\n      return i(r.editor).parse(this.get_input(s).value || \"\");\n    }\n  }, !0), n;\n}\nfunction Ia(t) {\n  return function (n, i, a) {\n    a == \"keepDates\" ? function (r, s) {\n      s == \"duration\" ? r.end_date = t.calculateEndDate(r) : s != \"end_date\" && s != \"start_date\" || (r.duration = t.calculateDuration(r));\n    }(n, i) : a == \"keepDuration\" ? function (r, s) {\n      s == \"end_date\" ? r.start_date = e(r) : s != \"start_date\" && s != \"duration\" || (r.end_date = t.calculateEndDate(r));\n    }(n, i) : function (r, s) {\n      t.config.schedule_from_end ? s == \"end_date\" || s == \"duration\" ? r.start_date = e(r) : s == \"start_date\" && (r.duration = t.calculateDuration(r)) : s == \"start_date\" || s == \"duration\" ? r.end_date = t.calculateEndDate(r) : s == \"end_date\" && (r.duration = t.calculateDuration(r));\n    }(n, i);\n  };\n  function e(n) {\n    return t.calculateEndDate({\n      start_date: n.end_date,\n      duration: -n.duration,\n      task: n\n    });\n  }\n}\nfunction Ma(t) {\n  t.config.editor_types = {\n    text: new (Sa())(),\n    number: new (Ta())(),\n    select: new (Ea())(),\n    date: new (Ca(t))(),\n    predecessor: new (Da(t))(),\n    duration: new (Aa(t))()\n  };\n}\nfunction Na(t) {\n  var e = /* @__PURE__ */function (a) {\n      var r = null;\n      return {\n        setMapping: function (s) {\n          r = s;\n        },\n        getMapping: function () {\n          return r || (a.config.keyboard_navigation_cells && a.ext.keyboardNavigation ? wa : $a);\n        }\n      };\n    }(t),\n    n = {};\n  ot(n);\n  var i = {\n    init: Ma,\n    createEditors: function (a) {\n      function r(u, h) {\n        var g = a.$getConfig(),\n          f = function (b, _) {\n            for (var m = a.$getConfig(), p = a.getItemTop(b), k = a.getItemHeight(b), x = a.getGridColumns(), $ = 0, w = 0, S = 0, T = 0; T < x.length; T++) {\n              if (x[T].name == _) {\n                S = x[T].width;\n                break;\n              }\n              m.rtl ? w += x[T].width : $ += x[T].width;\n            }\n            return m.rtl ? {\n              top: p,\n              right: w,\n              height: k,\n              width: S\n            } : {\n              top: p,\n              left: $,\n              height: k,\n              width: S\n            };\n          }(u, h),\n          y = document.createElement(\"div\");\n        y.className = \"gantt_grid_editor_placeholder\", y.setAttribute(a.$config.item_attribute, u), y.setAttribute(a.$config.bind + \"_id\", u), y.setAttribute(\"data-column-name\", h);\n        var v = function (b, _) {\n          for (var m = b.getGridColumns(), p = 0; p < m.length; p++) if (m[p].name == _) return p;\n          return 0;\n        }(a, h);\n        return y.setAttribute(\"data-column-index\", v), t._waiAria.inlineEditorAttr(y), g.rtl ? y.style.cssText = [\"top:\" + f.top + \"px\", \"right:\" + f.right + \"px\", \"width:\" + f.width + \"px\", \"height:\" + f.height + \"px\"].join(\";\") : y.style.cssText = [\"top:\" + f.top + \"px\", \"left:\" + f.left + \"px\", \"width:\" + f.width + \"px\", \"height:\" + f.height + \"px\"].join(\";\"), y;\n      }\n      var s = Ia(t),\n        o = [],\n        l = [],\n        d = null,\n        c = {\n          _itemId: null,\n          _columnName: null,\n          _editor: null,\n          _editorType: null,\n          _placeholder: null,\n          locateCell: function (u) {\n            if (!Y(u, a.$grid)) return null;\n            var h = et(u, a.$config.item_attribute),\n              g = et(u, \"data-column-name\");\n            if (h && g) {\n              var f = g.getAttribute(\"data-column-name\");\n              return {\n                id: h.getAttribute(a.$config.item_attribute),\n                columnName: f\n              };\n            }\n            return null;\n          },\n          getEditorConfig: function (u) {\n            return a.getColumn(u).editor;\n          },\n          init: function () {\n            var u = e.getMapping();\n            u.init && u.init(this, a), d = a.$gantt.getDatastore(a.$config.bind);\n            var h = this;\n            o.push(d.attachEvent(\"onIdChange\", function (g, f) {\n              h._itemId == g && (h._itemId = f);\n            })), o.push(d.attachEvent(\"onStoreUpdated\", function () {\n              a.$gantt.getState(\"batchUpdate\").batch_update || h.isVisible() && !d.isVisible(h._itemId) && h.hide();\n            })), l.push(t.attachEvent(\"onDataRender\", function () {\n              h._editor && h._placeholder && !Y(h._placeholder, t.$root) && a.$grid_data.appendChild(h._placeholder);\n            })), this.init = function () {};\n          },\n          getState: function () {\n            return {\n              editor: this._editor,\n              editorType: this._editorType,\n              placeholder: this._placeholder,\n              id: this._itemId,\n              columnName: this._columnName\n            };\n          },\n          startEdit: function (u, h) {\n            if (this.isVisible() && this.save(), d.exists(u)) {\n              var g = {\n                id: u,\n                columnName: h\n              };\n              t.isReadonly(d.getItem(u)) ? this.callEvent(\"onEditPrevent\", [g]) : this.callEvent(\"onBeforeEditStart\", [g]) !== !1 ? (this.show(g.id, g.columnName), this.setValue(), this.callEvent(\"onEditStart\", [g])) : this.callEvent(\"onEditPrevent\", [g]);\n            }\n          },\n          isVisible: function () {\n            return !(!this._editor || !Y(this._placeholder, t.$root));\n          },\n          show: function (u, h) {\n            this.isVisible() && this.save();\n            var g = {\n                id: u,\n                columnName: h\n              },\n              f = a.getColumn(g.columnName),\n              y = this.getEditorConfig(f.name);\n            if (y) {\n              var v = a.$getConfig().editor_types[y.type],\n                b = r(g.id, g.columnName);\n              a.$grid_data.appendChild(b), v.show(g.id, f, y, b), this._editor = v, this._placeholder = b, this._itemId = g.id, this._columnName = g.columnName, this._editorType = y.type;\n              var _ = e.getMapping();\n              _.onShow && _.onShow(this, b, a);\n            }\n          },\n          setValue: function () {\n            var u = this.getState(),\n              h = u.id,\n              g = u.columnName,\n              f = a.getColumn(g),\n              y = d.getItem(h),\n              v = this.getEditorConfig(g);\n            if (v) {\n              var b = y[v.map_to];\n              v.map_to == \"auto\" && (b = d.getItem(h)), this._editor.set_value(b, h, f, this._placeholder), this.focus();\n            }\n          },\n          focus: function () {\n            this._editor.focus(this._placeholder);\n          },\n          getValue: function () {\n            var u = a.getColumn(this._columnName);\n            return this._editor.get_value(this._itemId, u, this._placeholder);\n          },\n          _getItemValue: function () {\n            var u = this.getEditorConfig(this._columnName);\n            if (u) {\n              var h = t.getTask(this._itemId)[u.map_to];\n              return u.map_to == \"auto\" && (h = d.getItem(this._itemId)), h;\n            }\n          },\n          isChanged: function () {\n            var u = a.getColumn(this._columnName),\n              h = this._getItemValue();\n            return this._editor.is_changed(h, this._itemId, u, this._placeholder);\n          },\n          hide: function () {\n            if (this._itemId) {\n              var u = this._itemId,\n                h = this._columnName,\n                g = e.getMapping();\n              g.onHide && g.onHide(this, this._placeholder, a), this._itemId = null, this._columnName = null, this._editorType = null, this._placeholder && (this._editor && this._editor.hide && this._editor.hide(this._placeholder), this._editor = null, this._placeholder.parentNode && this._placeholder.parentNode.removeChild(this._placeholder), this._placeholder = null, this.callEvent(\"onEditEnd\", [{\n                id: u,\n                columnName: h\n              }]));\n            }\n          },\n          save: function () {\n            if (this.isVisible() && d.exists(this._itemId) && this.isChanged()) {\n              var u = this._itemId,\n                h = this._columnName;\n              if (d.exists(u)) {\n                var g = d.getItem(u),\n                  f = this.getEditorConfig(h),\n                  y = {\n                    id: u,\n                    columnName: h,\n                    newValue: this.getValue(),\n                    oldValue: this._getItemValue()\n                  };\n                if (this.callEvent(\"onBeforeSave\", [y]) !== !1 && (!this._editor.is_valid || this._editor.is_valid(y.newValue, y.id, a.getColumn(h), this._placeholder))) {\n                  var v = f.map_to,\n                    b = y.newValue;\n                  v != \"auto\" ? (g[v] = b, s(g, v, t.config.inline_editors_date_processing), d.updateItem(u)) : this._editor.save(u, a.getColumn(h), this._placeholder), this.callEvent(\"onSave\", [y]);\n                }\n                this.hide();\n              }\n            } else this.hide();\n          },\n          _findEditableCell: function (u, h) {\n            var g = u,\n              f = a.getGridColumns()[g],\n              y = f ? f.name : null;\n            if (y) {\n              for (; y && !this.getEditorConfig(y);) y = this._findEditableCell(u + h, h);\n              return y;\n            }\n            return null;\n          },\n          getNextCell: function (u) {\n            return this._findEditableCell(a.getColumnIndex(this._columnName, !0) + u, u);\n          },\n          getFirstCell: function () {\n            return this._findEditableCell(0, 1);\n          },\n          getLastCell: function () {\n            return this._findEditableCell(a.getGridColumns().length - 1, -1);\n          },\n          editNextCell: function (u) {\n            var h = this.getNextCell(1);\n            if (h) {\n              var g = this.getNextCell(1);\n              g && this.getEditorConfig(g) && this.startEdit(this._itemId, g);\n            } else if (u && this.moveRow(1)) {\n              var f = this.moveRow(1);\n              (h = this.getFirstCell()) && this.getEditorConfig(h) && this.startEdit(f, h);\n            }\n          },\n          editPrevCell: function (u) {\n            var h = this.getNextCell(-1);\n            if (h) {\n              var g = this.getNextCell(-1);\n              g && this.getEditorConfig(g) && this.startEdit(this._itemId, g);\n            } else if (u && this.moveRow(-1)) {\n              var f = this.moveRow(-1);\n              (h = this.getLastCell()) && this.getEditorConfig(h) && this.startEdit(f, h);\n            }\n          },\n          moveRow: function (u) {\n            for (var h = u > 0 ? t.getNext : t.getPrev, g = (h = t.bind(h, t))(this._itemId); t.isTaskExists(g) && t.isReadonly(t.getTask(g));) g = h(g);\n            return g;\n          },\n          editNextRow: function (u) {\n            var h = this.getState().id;\n            if (t.isTaskExists(h)) {\n              var g = null;\n              g = u ? this.moveRow(1) : t.getNext(h), t.isTaskExists(g) && this.startEdit(g, this._columnName);\n            }\n          },\n          editPrevRow: function (u) {\n            var h = this.getState().id;\n            if (t.isTaskExists(h)) {\n              var g = null;\n              g = u ? this.moveRow(-1) : t.getPrev(h), t.isTaskExists(g) && this.startEdit(g, this._columnName);\n            }\n          },\n          detachStore: function () {\n            o.forEach(function (u) {\n              d.detachEvent(u);\n            }), l.forEach(function (u) {\n              t.detachEvent(u);\n            }), o = [], l = [], d = null, this.hide();\n          },\n          destructor: function () {\n            this.detachStore(), this.detachAllEvents();\n          }\n        };\n      return L(c, e), L(c, n), c;\n    }\n  };\n  return L(i, e), L(i, n), i;\n}\nfunction $e(t, e, n, i, a) {\n  if (!t.start_date || !t.end_date) return null;\n  var r = n.getItemTop(t.id),\n    s = n.getItemHeight(t.id);\n  if (r > e.y_end || r + s < e.y) return !1;\n  var o = n.posFromDate(t.start_date),\n    l = n.posFromDate(t.end_date),\n    d = Math.min(o, l) - 200,\n    c = Math.max(o, l) + 200;\n  return !(d > e.x_end || c < e.x);\n}\nfunction xn(t) {\n  function e(r, s, o) {\n    if (t._isAllowedUnscheduledTask(r) || !t._isTaskInTimelineLimits(r)) return;\n    var l = s.getItemPosition(r),\n      d = o,\n      c = s.$getTemplates(),\n      u = t.getTaskType(r.type),\n      h = s.getBarHeight(r.id, u == d.types.milestone),\n      g = 0;\n    u == d.types.milestone && (g = (h - l.height) / 2);\n    var f = Math.floor((s.getItemHeight(r.id) - h) / 2);\n    const y = t.config.baselines && r.baselines && r.baselines.length,\n      v = t.config.baselines && (t.config.baselines.render_mode == \"separateRow\" || t.config.baselines.render_mode == \"individualRow\");\n    if (y && v && r.bar_height !== \"full\" && r.bar_height < r.row_height) if (u === d.types.milestone) {\n      let T = s.getBarHeight(r.id, !0),\n        E = Math.sqrt(2 * T * T);\n      f = Math.floor((E - h) / 2) + 2;\n    } else f = 2;\n    u == d.types.milestone && (l.left -= Math.round(h / 2), l.width = h);\n    var b = document.createElement(\"div\"),\n      _ = Math.round(l.width);\n    s.$config.item_attribute && (b.setAttribute(s.$config.item_attribute, r.id), b.setAttribute(s.$config.bind + \"_id\", r.id)), d.show_progress && u != d.types.milestone && function (T, E, C, D, M) {\n      var A = 1 * T.progress || 0;\n      C = Math.max(C - 2, 0);\n      var I = document.createElement(\"div\"),\n        N = Math.round(C * A);\n      N = Math.min(C, N), I.style.width = N + \"px\", I.className = \"gantt_task_progress\", I.innerHTML = M.progress_text(T.start_date, T.end_date, T), D.rtl && (I.style.position = \"absolute\", I.style.right = \"0px\");\n      var P = document.createElement(\"div\");\n      P.className = \"gantt_task_progress_wrapper\", P.appendChild(I), E.appendChild(P);\n      const O = !t.isReadonly(T),\n        z = t.ext.dragTimeline && t.ext.dragTimeline._isDragInProgress();\n      if (t.config.drag_progress && (O || z)) {\n        var F = document.createElement(\"div\"),\n          H = N;\n        D.rtl && (H = C - N), F.style.left = H + \"px\", F.className = \"gantt_task_progress_drag\", F.innerHTML = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"9\" viewBox=\"0 0 12 9\" fill=\"none\">\n<path d=\"M5.58397 1.52543C5.78189 1.22856 6.21811 1.22856 6.41602 1.52543L10.5475 7.72265C10.769 8.05493 10.5308 8.5 10.1315 8.5L1.86852 8.5C1.46917 8.5 1.23097 8.05493 1.45249 7.72265L5.58397 1.52543Z\" fill=\"var(--dhx-gantt-progress-handle-background)\" stroke=\"var(--dhx-gantt-progress-handle-border)\"/>\n</svg>`, I.appendChild(F), E.appendChild(F);\n      }\n    }(r, b, _, d, c);\n    var m = function (T, E, C) {\n      var D = document.createElement(\"div\");\n      return t.getTaskType(T.type) != t.config.types.milestone ? D.innerHTML = C.task_text(T.start_date, T.end_date, T) : t.getTaskType(T.type) == t.config.types.milestone && E && (D.style.height = D.style.width = E + \"px\"), D.className = \"gantt_task_content\", D;\n    }(r, _, c);\n    b.appendChild(m);\n    var p = function (T, E, C, D) {\n      var M = D.$getConfig(),\n        A = [T];\n      E && A.push(E);\n      var I = t.getState(),\n        N = t.getTask(C);\n      if (t.getTaskType(N.type) == M.types.milestone ? A.push(\"gantt_milestone\") : t.getTaskType(N.type) == M.types.project && A.push(\"gantt_project\"), A.push(\"gantt_bar_\" + t.getTaskType(N.type)), t.isSummaryTask(N) && A.push(\"gantt_dependent_task\"), t.isSplitTask(N) && (M.open_split_tasks && !N.$open || !M.open_split_tasks) && A.push(\"gantt_split_parent\"), M.select_task && t.isSelectedTask(C) && A.push(\"gantt_selected\"), C == I.drag_id && (A.push(\"gantt_drag_\" + I.drag_mode), I.touch_drag && A.push(\"gantt_touch_\" + I.drag_mode)), I.link_source_id == C && (A.push(\"gantt_link_source\"), I.link_from_start ? A.push(\"gantt_link_from_start\") : A.push(\"gantt_link_from_end\")), I.link_target_id == C && A.push(\"gantt_link_target\"), M.highlight_critical_path && t.isCriticalTask && t.isCriticalTask(N) && A.push(\"gantt_critical_task\"), I.link_landing_area && I.link_target_id && I.link_source_id && I.link_target_id != I.link_source_id && (I.link_target_id == C || I.link_source_id == C)) {\n        var P = I.link_source_id,\n          O = I.link_from_start,\n          z = I.link_to_start,\n          F = \"\";\n        F = t.isLinkAllowed(P, C, O, z) ? z ? \"link_start_allow\" : \"link_finish_allow\" : z ? \"link_start_deny\" : \"link_finish_deny\", A.push(F);\n      }\n      return A.join(\" \");\n    }(\"gantt_task_line\", c.task_class(r.start_date, r.end_date, r), r.id, s);\n    (r.color || r.progressColor || r.textColor) && (p += \" gantt_task_inline_color\"), l.width < 20 && (p += \" gantt_thin_task\"), b.className = p;\n    var k = [\"left:\" + l.left + \"px\", \"top:\" + (f + l.top) + \"px\", \"height:\" + h + \"px\", \"line-height:\" + Math.max(h < 30 ? h - 2 : h, 0) + \"px\", \"width:\" + _ + \"px\"];\n    b.style.cssText = k.join(\";\"), r.color && b.style.setProperty(\"--dhx-gantt-task-background\", r.color), r.textColor && b.style.setProperty(\"--dhx-gantt-task-color\", r.textColor), r.progressColor && b.style.setProperty(\"--dhx-gantt-task-progress-color\", r.progressColor);\n    var x = function (T, E, C, D) {\n      var M = \"gantt_left \" + i(!E.rtl, T),\n        A = null;\n      return D && (A = {\n        type: \"marginRight\",\n        value: D\n      }), n(T, C.leftside_text, M, A);\n    }(r, d, c, g);\n    x && b.appendChild(x), x = function (T, E, C, D) {\n      var M = \"gantt_right \" + i(!!E.rtl, T),\n        A = null;\n      return D && (A = {\n        type: \"marginLeft\",\n        value: D\n      }), n(T, C.rightside_text, M, A);\n    }(r, d, c, g), x && b.appendChild(x), t._waiAria.setTaskBarAttr(r, b);\n    var $ = t.getState();\n    const w = !t.isReadonly(r),\n      S = t.ext.dragTimeline && t.ext.dragTimeline._isDragInProgress();\n    return (w || S) && (d.drag_resize && !t.isSummaryTask(r) && u != d.types.milestone && a(b, \"gantt_task_drag\", r, function (T) {\n      var E = document.createElement(\"div\");\n      return E.className = T, E;\n    }, d), d.drag_links && d.show_links && a(b, \"gantt_link_control\", r, function (T) {\n      var E = document.createElement(\"div\");\n      E.className = T, E.style.cssText = [\"height:\" + h + \"px\", \"line-height:\" + h + \"px\"].join(\";\");\n      var C = document.createElement(\"div\");\n      C.className = \"gantt_link_point\";\n      var D = !1;\n      return $.link_source_id && d.touch && (D = !0), C.style.display = D ? \"block\" : \"\", E.appendChild(C), E;\n    }, d, g)), b;\n  }\n  function n(r, s, o, l) {\n    if (!s) return null;\n    var d = s(r.start_date, r.end_date, r);\n    if (!d) return null;\n    var c = document.createElement(\"div\");\n    return c.className = \"gantt_side_content \" + o, c.innerHTML = d, l && (c.style[l.type] = Math.abs(l.value) + \"px\"), c;\n  }\n  function i(r, s) {\n    var o = r ? {\n      $source: [t.config.links.start_to_start],\n      $target: [t.config.links.start_to_start, t.config.links.finish_to_start]\n    } : {\n      $source: [t.config.links.finish_to_start, t.config.links.finish_to_finish],\n      $target: [t.config.links.finish_to_finish]\n    };\n    for (var l in o) for (var d = s[l], c = 0; c < d.length; c++) for (var u = t.getLink(d[c]), h = 0; h < o[l].length; h++) if (u.type == o[l][h]) return \"gantt_link_crossing\";\n    return \"\";\n  }\n  function a(r, s, o, l, d, c) {\n    var u,\n      h = t.getState();\n    +o.start_date >= +h.min_date && ((u = l([s, d.rtl ? \"task_right\" : \"task_left\", \"task_start_date\"].join(\" \"))).setAttribute(\"data-bind-property\", \"start_date\"), c && (u.style.marginLeft = c + \"px\"), r.appendChild(u)), +o.end_date <= +h.max_date && ((u = l([s, d.rtl ? \"task_left\" : \"task_right\", \"task_end_date\"].join(\" \"))).setAttribute(\"data-bind-property\", \"end_date\"), c && (u.style.marginRight = c + \"px\"), r.appendChild(u));\n  }\n  return function (r, s, o) {\n    var l = (o = s.$getConfig()).type_renderers[t.getTaskType(r.type)],\n      d = e;\n    return l ? l.call(t, r, function (c) {\n      return d.call(t, c, s, o);\n    }, s) : d.call(t, r, s, o);\n  };\n}\nfunction Ge(t) {\n  return {\n    render: xn(t),\n    update: null,\n    isInViewPort: $e,\n    getVisibleRange: ft\n  };\n}\nfunction Ct() {\n  return console.error(\"You are trying to use a Pro feature that is not available in the GPL version.\"), {\n    render: function () {},\n    isInViewPort: function () {},\n    getVisibleRange: function () {}\n  };\n}\nfunction Ye(t, e, n) {\n  return {\n    top: e.getItemTop(t.id),\n    height: e.getItemHeight(t.id),\n    left: 0,\n    right: 1 / 0\n  };\n}\nfunction jt(t, e) {\n  var n = 0,\n    i = t.left.length - 1;\n  if (e) for (var a = 0; a < t.left.length; a++) {\n    var r = t.left[a];\n    if (r < e.x && (n = a), r > e.x_end) {\n      i = a;\n      break;\n    }\n  }\n  return {\n    start: n,\n    end: i\n  };\n}\nfunction oe(t, e, n, i) {\n  var a = e.width[t];\n  if (a <= 0) return !1;\n  if (!i.config.smart_rendering || Nt(i)) return !0;\n  var r = e.left[t] - a,\n    s = e.left[t] + a;\n  return r <= n.x_end && s >= n.x;\n}\nfunction La(t, e) {\n  var n = e.config.timeline_placeholder;\n  if (t = t || [], n && t.filter(l => l.id === \"timeline_placeholder_task\").length === 0) {\n    var i = e.getState(),\n      a = null,\n      r = i.min_date,\n      s = i.max_date;\n    t.length && (a = t[t.length - 1].id);\n    var o = {\n      start_date: r,\n      end_date: s,\n      row_height: n.height || 0,\n      id: \"timeline_placeholder_task\",\n      unscheduled: !0,\n      lastTaskId: a,\n      calendar_id: n.calendar || \"global\",\n      $source: [],\n      $target: []\n    };\n    t.push(o);\n  }\n}\nfunction Pa(t) {\n  var e = {\n      current_pos: null,\n      dirs: {\n        left: \"left\",\n        right: \"right\",\n        up: \"up\",\n        down: \"down\"\n      },\n      path: [],\n      clear: function () {\n        this.current_pos = null, this.path = [];\n      },\n      point: function (a) {\n        this.current_pos = t.copy(a);\n      },\n      get_lines: function (a) {\n        this.clear(), this.point(a[0]);\n        for (var r = 1; r < a.length; r++) this.line_to(a[r]);\n        return this.get_path();\n      },\n      line_to: function (a) {\n        var r = t.copy(a),\n          s = this.current_pos,\n          o = this._get_line(s, r);\n        this.path.push(o), this.current_pos = r;\n      },\n      get_path: function () {\n        return this.path;\n      },\n      get_wrapper_sizes: function (a, r, s) {\n        var o,\n          l = r.$getConfig().link_wrapper_width,\n          d = a.y - l / 2;\n        switch (a.direction) {\n          case this.dirs.left:\n            o = {\n              top: d,\n              height: l,\n              lineHeight: l,\n              left: a.x - a.size - l / 2,\n              width: a.size + l\n            };\n            break;\n          case this.dirs.right:\n            o = {\n              top: d,\n              lineHeight: l,\n              height: l,\n              left: a.x - l / 2,\n              width: a.size + l\n            };\n            break;\n          case this.dirs.up:\n            o = {\n              top: d - a.size,\n              lineHeight: a.size + l,\n              height: a.size + l,\n              left: a.x - l / 2,\n              width: l\n            };\n            break;\n          case this.dirs.down:\n            o = {\n              top: d,\n              lineHeight: a.size + l,\n              height: a.size + l,\n              left: a.x - l / 2,\n              width: l\n            };\n        }\n        return o;\n      },\n      get_line_sizes: function (a, r) {\n        var s,\n          o = r.$getConfig(),\n          l = o.link_line_width,\n          d = o.link_wrapper_width,\n          c = a.size + l;\n        switch (a.direction) {\n          case this.dirs.left:\n          case this.dirs.right:\n            s = {\n              height: l,\n              width: c,\n              marginTop: (d - l) / 2,\n              marginLeft: (d - l) / 2\n            };\n            break;\n          case this.dirs.up:\n          case this.dirs.down:\n            s = {\n              height: c,\n              width: l,\n              marginTop: (d - l) / 2,\n              marginLeft: (d - l) / 2\n            };\n        }\n        return s;\n      },\n      render_line: function (a, r, s, o) {\n        var l = this.get_wrapper_sizes(a, s, o),\n          d = document.createElement(\"div\");\n        d.style.cssText = [\"top:\" + l.top + \"px\", \"left:\" + l.left + \"px\", \"height:\" + l.height + \"px\", \"width:\" + l.width + \"px\"].join(\";\"), d.className = \"gantt_line_wrapper\";\n        var c = this.get_line_sizes(a, s),\n          u = document.createElement(\"div\");\n        return u.style.cssText = [\"height:\" + c.height + \"px\", \"width:\" + c.width + \"px\", \"margin-top:\" + c.marginTop + \"px\", \"margin-left:\" + c.marginLeft + \"px\"].join(\";\"), u.className = \"gantt_link_line_\" + a.direction, d.appendChild(u), d;\n      },\n      render_corner: function (a, r) {\n        const s = a.radius,\n          o = r.$getConfig(),\n          l = o.link_line_width || 2,\n          d = document.createElement(\"div\");\n        let c, u;\n        return d.classList.add(\"gantt_link_corner\"), d.classList.add(`gantt_link_corner_${a.direction.from}_${a.direction.to}`), d.style.width = `${s}px`, d.style.height = `${s}px`, a.direction.from === \"right\" && a.direction.to === \"down\" ? (c = \"Right\", u = \"Top\", d.style.left = a.x - o.link_line_width / 2 + \"px\", d.style.top = `${a.y}px`) : a.direction.from === \"down\" && a.direction.to === \"right\" ? (c = \"Left\", u = \"Bottom\", d.style.left = a.x - o.link_line_width / 2 + \"px\", d.style.top = `${a.y}px`) : a.direction.from === \"right\" && a.direction.to === \"up\" ? (c = \"Right\", u = \"Bottom\", d.style.left = a.x - o.link_line_width / 2 + \"px\", d.style.top = a.y - s + \"px\") : a.direction.from === \"up\" && a.direction.to === \"right\" ? (c = \"Left\", u = \"Top\", d.style.left = a.x - o.link_line_width / 2 + \"px\", d.style.top = a.y - s + \"px\") : a.direction.from === \"left\" && a.direction.to === \"down\" ? (c = \"Left\", u = \"Top\", d.style.left = a.x - s - o.link_line_width / 2 + \"px\", d.style.top = `${a.y}px`) : a.direction.from === \"down\" && a.direction.to === \"left\" ? (c = \"Right\", u = \"Bottom\", d.style.left = a.x - s - o.link_line_width / 2 + \"px\", d.style.top = `${a.y}px`) : a.direction.from === \"left\" && a.direction.to === \"up\" ? (c = \"Left\", u = \"Bottom\", d.style.left = a.x - s - o.link_line_width / 2 + \"px\", d.style.top = a.y - s + \"px\") : a.direction.from === \"up\" && a.direction.to === \"left\" && (c = \"Right\", u = \"Top\", d.style.left = a.x - s - o.link_line_width / 2 + \"px\", d.style.top = a.y - s + \"px\"), d.style[`border${u}Width`] = `${l}px`, d.style[`border${c}Width`] = `${l}px`, d.style[`border${c}Style`] = \"solid\", d.style[`border${u}Style`] = \"solid\", d.style[`border${u}${c}Radius`] = `${s}px`, d;\n      },\n      render_arrow(a, r) {\n        var s = document.createElement(\"div\"),\n          o = a.y,\n          l = a.x,\n          d = r.link_arrow_size;\n        s.style.setProperty(\"--dhx-gantt-icon-size\", `${d}px`);\n        var c = \"gantt_link_arrow gantt_link_arrow_\" + a.direction;\n        return s.style.top = o + \"px\", s.style.left = l + \"px\", s.className = c, s;\n      },\n      _get_line: function (a, r) {\n        var s = this.get_direction(a, r),\n          o = {\n            x: a.x,\n            y: a.y,\n            direction: this.get_direction(a, r)\n          };\n        return s == this.dirs.left || s == this.dirs.right ? o.size = Math.abs(a.x - r.x) : o.size = Math.abs(a.y - r.y), o;\n      },\n      get_direction: function (a, r) {\n        return r.x < a.x ? this.dirs.left : r.x > a.x ? this.dirs.right : r.y > a.y ? this.dirs.down : this.dirs.up;\n      }\n    },\n    n = {\n      path: [],\n      clear: function () {\n        this.path = [];\n      },\n      current: function () {\n        return this.path[this.path.length - 1];\n      },\n      point: function (a) {\n        return a ? (this.path.push(t.copy(a)), a) : this.current();\n      },\n      point_to: function (a, r, s) {\n        s = s ? {\n          x: s.x,\n          y: s.y\n        } : t.copy(this.point());\n        var o = e.dirs;\n        switch (a) {\n          case o.left:\n            s.x -= r;\n            break;\n          case o.right:\n            s.x += r;\n            break;\n          case o.up:\n            s.y -= r;\n            break;\n          case o.down:\n            s.y += r;\n        }\n        return this.point(s);\n      },\n      get_points: function (a, r, s, o) {\n        var l = this.get_endpoint(a, r, s, o),\n          d = t.config,\n          c = l.e_y - l.y,\n          u = l.e_x - l.x,\n          h = e.dirs,\n          g = r.getItemHeight(a.source);\n        this.clear(), this.point({\n          x: l.x,\n          y: l.y\n        });\n        var f = 2 * d.link_arrow_size,\n          y = this.get_line_type(a, r.$getConfig()),\n          v = l.e_x > l.x;\n        if (y.from_start && y.to_start) this.point_to(h.left, f), v ? (this.point_to(h.down, c), this.point_to(h.right, u)) : (this.point_to(h.right, u), this.point_to(h.down, c)), this.point_to(h.right, f);else if (!y.from_start && y.to_start) {\n          if (c !== 0 && (v = l.e_x > l.x + 2 * f), this.point_to(h.right, f), v) u -= f, this.point_to(h.down, c), this.point_to(h.right, u);else {\n            u -= 2 * f;\n            var b = c > 0 ? 1 : -1;\n            this.point_to(h.down, b * (g / 2)), this.point_to(h.right, u), this.point_to(h.down, b * (Math.abs(c) - g / 2)), this.point_to(h.right, f);\n          }\n        } else y.from_start || y.to_start ? y.from_start && !y.to_start && (c !== 0 && (v = l.e_x > l.x - 2 * f), this.point_to(h.left, f), v ? (u += 2 * f, b = c > 0 ? 1 : -1, this.point_to(h.down, b * (g / 2)), this.point_to(h.right, u), this.point_to(h.down, b * (Math.abs(c) - g / 2)), this.point_to(h.left, f)) : (u += f, this.point_to(h.down, c), this.point_to(h.right, u))) : (this.point_to(h.right, f), v ? (this.point_to(h.right, u), this.point_to(h.down, c)) : (this.point_to(h.down, c), this.point_to(h.right, u)), this.point_to(h.left, f));\n        return this.path;\n      },\n      get_line_type: function (a, r) {\n        var s = r.links,\n          o = !1,\n          l = !1;\n        return a.type == s.start_to_start ? o = l = !0 : a.type == s.finish_to_finish ? o = l = !1 : a.type == s.finish_to_start ? (o = !1, l = !0) : a.type == s.start_to_finish ? (o = !0, l = !1) : t.assert(!1, \"Invalid link type\"), r.rtl && (o = !o, l = !l), {\n          from_start: o,\n          to_start: l\n        };\n      },\n      get_endpoint: function (a, r, s, o) {\n        var l = r.$getConfig(),\n          d = this.get_line_type(a, l),\n          c = d.from_start,\n          u = d.to_start,\n          h = i(s, r, l),\n          g = i(o, r, l);\n        return {\n          x: c ? h.left : h.left + h.width,\n          e_x: u ? g.left : g.left + g.width,\n          y: h.top + h.rowHeight / 2 - 1,\n          e_y: g.top + g.rowHeight / 2 - 1\n        };\n      }\n    };\n  function i(a, r, s) {\n    var o = r.getItemPosition(a);\n    let l = mi(t, r, a),\n      d = l.maxHeight,\n      c = l.splitChild;\n    const u = t.config.baselines && (t.config.baselines.render_mode == \"separateRow\" || t.config.baselines.render_mode == \"individualRow\") && a.baselines && a.baselines.length;\n    let h;\n    l.shrinkHeight && (o.rowHeight = d);\n    let g = t.getTaskType(a.type) == s.types.milestone;\n    if (g) {\n      let f = r.getBarHeight(a.id, !0);\n      h = Math.sqrt(2 * f * f), l.shrinkHeight && d < f && (f = d, h = d), o.left -= h / 2, o.width = h;\n    }\n    if (c) {\n      if (d >= o.height) {\n        const f = pi(t, a.parent);\n        u || f ? g ? (o.rowHeight = o.height + 4, o.left += (o.width - o.rowHeight + 4) / 2, o.width = o.rowHeight - 3) : o.rowHeight = o.height + 6 : g && (o.left += (h - o.height) / 2);\n      } else o.rowHeight = d + 2, g && (o.left += (o.width - o.rowHeight + 4) / 2, o.width = o.rowHeight - 3);\n    } else u && (o.rowHeight = o.height + 4);\n    return o;\n  }\n  return {\n    render: function (a, r, s) {\n      var o = t.getTask(a.source);\n      if (o.hide_bar) return;\n      var l = t.getTask(a.target);\n      if (l.hide_bar) return;\n      var d = n.get_endpoint(a, r, o, l),\n        c = d.e_y - d.y;\n      if (!(d.e_x - d.x) && !c) return null;\n      var u = n.get_points(a, r, o, l);\n      const h = function (v, b) {\n          const _ = b.link_radius || 4,\n            m = b.link_arrow_size || 6,\n            p = [];\n          for (let x = 0; x < v.length; x++) {\n            const $ = v[x],\n              w = v[x + 1];\n            if (!w || b.link_radius <= 1) p.push({\n              type: \"line\",\n              data: $\n            });else if ($.direction !== w.direction) {\n              if ($.size < _ || w.size < _) {\n                p.push({\n                  type: \"line\",\n                  data: $\n                });\n                continue;\n              }\n              $.size -= _, p.push({\n                type: \"line\",\n                data: $\n              });\n              let S = $.x,\n                T = $.y - b.link_line_width / 2;\n              switch ($.direction) {\n                case \"right\":\n                  S += $.size;\n                  break;\n                case \"left\":\n                  S -= $.size;\n                  break;\n                case \"down\":\n                  T += $.size;\n                  break;\n                case \"up\":\n                  T -= $.size;\n              }\n              const E = {\n                x: S,\n                y: T,\n                direction: {\n                  from: $.direction,\n                  to: w.direction\n                },\n                radius: _\n              };\n              switch (p.push({\n                type: \"corner\",\n                data: E\n              }), w.direction) {\n                case \"right\":\n                  w.x += _, w.size -= _;\n                  break;\n                case \"left\":\n                  w.x -= _, w.size -= _;\n                  break;\n                case \"down\":\n                  w.y += _, w.size -= _;\n                  break;\n                case \"up\":\n                  w.y -= _, w.size -= _;\n              }\n            } else p.push({\n              type: \"line\",\n              data: $\n            });\n          }\n          const k = v[v.length - 1];\n          if (k.direction === \"right\" || k.direction === \"left\") {\n            k.size -= 3 * m / 4;\n            let x = k.direction === \"right\" ? k.x + k.size : k.x - k.size - m / 2,\n              $ = k.y - b.link_line_width / 2 - m / 2 + 1;\n            k.direction === \"left\" ? ($ -= 1, x -= 2) : x -= 1;\n            const w = {\n              x,\n              y: $,\n              size: m,\n              direction: k.direction\n            };\n            p.push({\n              type: \"line\",\n              data: k\n            }), p.push({\n              type: \"arrow\",\n              data: w\n            });\n          } else p.push({\n            type: \"line\",\n            data: k\n          });\n          return p;\n        }(e.get_lines(u, r).filter(v => v.size > 0), s),\n        g = function (v, b, _, m) {\n          const p = document.createElement(\"div\");\n          return v.forEach(k => {\n            let x;\n            k.type === \"line\" ? x = e.render_line(k.data, null, b, _.source) : k.type === \"corner\" ? x = e.render_corner(k.data, b) : k.type === \"arrow\" && (x = e.render_arrow(k.data, m)), p.appendChild(x);\n          }), p;\n        }(h, r, a, s);\n      var f = \"gantt_task_link\";\n      a.color && (f += \" gantt_link_inline_color\");\n      var y = t.templates.link_class ? t.templates.link_class(a) : \"\";\n      return y && (f += \" \" + y), s.highlight_critical_path && t.isCriticalLink && t.isCriticalLink(a) && (f += \" gantt_critical_link\"), g.className = f, r.$config.link_attribute && (g.setAttribute(r.$config.link_attribute, a.id), g.setAttribute(\"link_id\", a.id)), a.color && g.style.setProperty(\"--dhx-gantt-link-background\", a.color), t._waiAria.linkAttr(a, g), g;\n    },\n    update: null,\n    isInViewPort: kn,\n    getVisibleRange: vn()\n  };\n}\nfunction Ra(t, e, n, i, a) {\n  if (a.$ui.getView(\"grid\") && (a.config.keyboard_navigation && a.getSelectedId() || a.ext.inlineEditors && a.ext.inlineEditors.getState().id)) return !!t.$expanded_branch;\n  var r = n.getItemTop(t.id),\n    s = n.getItemHeight(t.id);\n  return !(r > e.y_end || r + s < e.y);\n}\nfunction Ha(t) {\n  let e = {};\n  return t.$data.tasksStore.attachEvent(\"onStoreUpdated\", function () {\n    e = {};\n  }), function (n, i, a, r) {\n    const s = n.id + \"_\" + i + \"_\" + a.unit + \"_\" + a.step;\n    let o;\n    return o = e[s] ? e[s] : e[s] = function (l, d, c, u) {\n      let h,\n        g = !1,\n        f = {};\n      t.config.process_resource_assignments && d === t.config.resource_property ? (h = l.$role == \"task\" ? t.getResourceAssignments(l.$resource_id, l.$task_id) : t.getResourceAssignments(l.id), g = !0) : h = l.$role == \"task\" ? [] : t.getTaskBy(d, l.id), f = function (w, S, T) {\n        const E = S.unit,\n          C = S.step,\n          D = {},\n          M = {};\n        for (let A = 0; A < w.length; A++) {\n          const I = w[A];\n          let N = I;\n          if (T && (N = t.getTask(I.task_id)), N.unscheduled) continue;\n          let P = I.start_date || N.start_date,\n            O = I.end_date || N.end_date;\n          T && (I.start_date && (P = new Date(Math.max(I.start_date.valueOf(), N.start_date.valueOf()))), I.end_date && (O = new Date(Math.min(I.end_date.valueOf(), N.end_date.valueOf()))), I.mode && I.mode == \"fixedDates\" && (P = I.start_date, O = I.end_date));\n          let z = At(S.trace_x, P.valueOf()),\n            F = new Date(S.trace_x[z] || t.date[E + \"_start\"](new Date(P))),\n            H = new Date(Math.min(P.valueOf(), F.valueOf())),\n            Q = t.config.work_time ? t.getTaskCalendar(N) : t;\n          for (M[Q.id] = {}; H < O;) {\n            const J = M[Q.id],\n              B = H.valueOf();\n            H = t.date.add(H, C, E), J[B] !== !1 && (D[B] || (D[B] = {\n              tasks: [],\n              assignments: []\n            }), D[B].tasks.push(N), T && D[B].assignments.push(I));\n          }\n        }\n        return D;\n      }(h, c, g);\n      const y = c.unit,\n        v = c.step,\n        b = [];\n      let _, m, p, k, x;\n      const $ = u.$getConfig();\n      for (let w = 0; w < c.trace_x.length; w++) _ = new Date(c.trace_x[w]), m = t.date.add(_, v, y), x = f[_.valueOf()] || {}, p = x.tasks || [], k = x.assignments || [], p.length || $.resource_render_empty_cells ? b.push({\n        start_date: _,\n        end_date: m,\n        tasks: p,\n        assignments: k\n      }) : b.push(null);\n      return b;\n    }(n, i, a, r), o;\n  };\n}\nconst Oa = {\n    init: function (t, e) {\n      var n = t.$services.getService(\"dnd\");\n      if (e.$config.bind && t.getDatastore(e.$config.bind)) {\n        var i = new n(e.$grid_data, {\n          updates_per_second: 60\n        });\n        t.defined(e.$getConfig().dnd_sensitivity) && (i.config.sensitivity = e.$getConfig().dnd_sensitivity), i.attachEvent(\"onBeforeDragStart\", t.bind(function (o, l) {\n          var d = a(l);\n          if (!d || (t.hideQuickInfo && t.hideQuickInfo(), ct(l.target, \".gantt_grid_editor_placeholder\"))) return !1;\n          var c = d.getAttribute(e.$config.item_attribute);\n          if (s(c)) return !1;\n          var u = r().getItem(c);\n          return !t.isReadonly(u) && (i.config.initial_open_state = u.$open, !!t.callEvent(\"onRowDragStart\", [c, l.target || l.srcElement, l]) && void 0);\n        }, t)), i.attachEvent(\"onAfterDragStart\", t.bind(function (o, l) {\n          var d = a(l);\n          i.config.marker.innerHTML = d.outerHTML;\n          var c = i.config.marker.firstChild;\n          c && (c.style.position = \"static\"), i.config.id = d.getAttribute(e.$config.item_attribute);\n          var u = r(),\n            h = u.getItem(i.config.id);\n          i.config.index = u.getBranchIndex(i.config.id), i.config.parent = h.parent, h.$open = !1, h.$transparent = !0, this.refreshData();\n        }, t)), i.lastTaskOfLevel = function (o) {\n          for (var l = null, d = r().getItems(), c = 0, u = d.length; c < u; c++) d[c].$level == o && (l = d[c]);\n          return l ? l.id : null;\n        }, i._getGridPos = t.bind(function (o) {\n          var l = U(e.$grid_data),\n            d = l.x + e.$grid.scrollLeft,\n            c = o.pos.y - 10,\n            u = e.getItemHeight(i.config.id);\n          c < l.y && (c = l.y);\n          var h = e.getTotalHeight();\n          c > l.y + h - u && (c = l.y + h - u);\n          const g = l.y + l.height;\n          return c > g - u && (c = g - u), l.x = d, l.y = c, l;\n        }, t), i._getTargetY = t.bind(function (o) {\n          var l = U(e.$grid_data),\n            d = e.$state.scrollTop || 0,\n            c = t.$grid_data.getBoundingClientRect().height + d,\n            u = o.pageY - l.y + d;\n          return u > c ? u = c : u < d && (u = d), u;\n        }, t), i._getTaskByY = t.bind(function (o, l) {\n          var d = r();\n          o = o || 0;\n          var c = e.getItemIndexByTopPosition(o);\n          return (c = l < c ? c - 1 : c) > d.countVisible() - 1 ? null : d.getIdByIndex(c);\n        }, t), i.attachEvent(\"onDragMove\", t.bind(function (o, l) {\n          var d = t.$grid_data.getBoundingClientRect(),\n            c = d.height + d.y + (e.$state.scrollTop || 0) + window.scrollY,\n            u = i.config,\n            h = i._getGridPos(l);\n          t._waiAria.reorderMarkerAttr(u.marker);\n          var g = e.$getConfig(),\n            f = r();\n          h.y < c ? u.marker.style.top = h.y + \"px\" : u.marker.style.top = c + \"px\", u.marker.style.left = h.x + 10 + \"px\";\n          const y = U(t.$root);\n          h.width > y.width && (u.marker.style.width = y.width - 10 - 2 + \"px\", u.marker.style.overflow = \"hidden\");\n          var v = f.getItem(i.config.id),\n            b = i._getTargetY(l),\n            _ = i._getTaskByY(b, f.getIndexById(v.id));\n          function m(D, M) {\n            return !f.isChildOf(p.id, M.id) && (D.$level == M.$level || g.order_branch_free);\n          }\n          if (f.exists(_) || (_ = i.lastTaskOfLevel(g.order_branch_free ? v.$level : 0)) == i.config.id && (_ = null), f.exists(_)) {\n            var p = f.getItem(_),\n              k = e.getItemTop(p.id),\n              x = e.getItemHeight(p.id);\n            if (k + x / 2 < b) {\n              var $ = f.getIndexById(p.id),\n                w = f.getNext(p.id),\n                S = f.getItem(w);\n              if (s(w)) {\n                var T = f.getPrev(S.id);\n                S = f.getItem(T);\n              }\n              if (S) {\n                if (S.id == v.id) return g.order_branch_free && f.isChildOf(v.id, p.id) && f.getChildren(p.id).length == 1 ? void f.move(v.id, f.getBranchIndex(p.id) + 1, f.getParent(p.id)) : void 0;\n                p = S;\n              } else if (w = f.getIdByIndex($), S = f.getItem(w), s(w) && (T = f.getPrev(S.id), S = f.getItem(T)), m(S, v) && S.id != v.id) return void f.move(v.id, -1, f.getParent(S.id));\n            } else if (g.order_branch_free && p.id != v.id && m(p, v) && !s(p.id)) {\n              if (!f.hasChild(p.id)) return p.$open = !0, void f.move(v.id, -1, p.id);\n              if (f.getIndexById(p.id) || x / 3 < b) return;\n            }\n            $ = f.getIndexById(p.id), T = f.getIdByIndex($ - 1);\n            for (var E = f.getItem(T), C = 1; (!E || E.id == p.id) && $ - C >= 0;) T = f.getIdByIndex($ - C), E = f.getItem(T), C++;\n            if (v.id == p.id || s(p.id)) return;\n            m(p, v) && v.id != p.id ? f.move(v.id, 0, 0, p.id) : p.$level != v.$level - 1 || f.getChildren(p.id).length ? E && m(E, v) && v.id != E.id && f.move(v.id, -1, f.getParent(E.id)) : f.move(v.id, 0, p.id);\n          }\n          return !0;\n        }, t)), i.attachEvent(\"onDragEnd\", t.bind(function () {\n          var o = r(),\n            l = o.getItem(i.config.id);\n          l.$transparent = !1, l.$open = i.config.initial_open_state, this.callEvent(\"onBeforeRowDragEnd\", [i.config.id, i.config.parent, i.config.index]) === !1 ? (o.move(i.config.id, i.config.index, i.config.parent), l.$drop_target = null) : this.callEvent(\"onRowDragEnd\", [i.config.id, l.$drop_target]), t.render(), this.refreshData();\n        }, t));\n      }\n      function a(o) {\n        return et(o, e.$config.item_attribute);\n      }\n      function r() {\n        return t.getDatastore(e.$config.bind);\n      }\n      function s(o) {\n        return Rt(o, t, r());\n      }\n    }\n  },\n  K = {\n    createDropTargetObject: function (t) {\n      var e = {\n        targetParent: null,\n        targetIndex: 0,\n        targetId: null,\n        child: !1,\n        nextSibling: !1,\n        prevSibling: !1\n      };\n      return t && L(e, t, !0), e;\n    },\n    nextSiblingTarget: function (t, e, n) {\n      var i = this.createDropTargetObject();\n      return i.targetId = e, i.nextSibling = !0, i.targetParent = n.getParent(i.targetId), i.targetIndex = n.getBranchIndex(i.targetId), (n.getParent(t) != i.targetParent || i.targetIndex < n.getBranchIndex(t)) && (i.targetIndex += 1), i;\n    },\n    prevSiblingTarget: function (t, e, n) {\n      var i = this.createDropTargetObject();\n      return i.targetId = e, i.prevSibling = !0, i.targetParent = n.getParent(i.targetId), i.targetIndex = n.getBranchIndex(i.targetId), n.getParent(t) == i.targetParent && i.targetIndex > n.getBranchIndex(t) && (i.targetIndex -= 1), i;\n    },\n    firstChildTarget: function (t, e, n) {\n      var i = this.createDropTargetObject();\n      return i.targetId = e, i.targetParent = i.targetId, i.targetIndex = 0, i.child = !0, i;\n    },\n    lastChildTarget: function (t, e, n) {\n      var i = n.getChildren(e),\n        a = this.createDropTargetObject();\n      return a.targetId = i[i.length - 1], a.targetParent = e, a.targetIndex = i.length, a.nextSibling = !0, a;\n    }\n  };\nfunction $n(t, e, n, i, a) {\n  for (var r = e; i.exists(r);) {\n    var s = i.calculateItemLevel(i.getItem(r));\n    if ((s === n || s === n - 1) && i.getBranchIndex(r) > -1) break;\n    r = a ? i.getPrev(r) : i.getNext(r);\n  }\n  return i.exists(r) ? i.calculateItemLevel(i.getItem(r)) === n ? a ? K.nextSiblingTarget(t, r, i) : K.prevSiblingTarget(t, r, i) : K.firstChildTarget(t, r, i) : null;\n}\nfunction le(t, e, n, i) {\n  return $n(t, e, n, i, !0);\n}\nfunction Je(t, e, n, i) {\n  return $n(t, e, n, i, !1);\n}\nfunction Ke(t, e, n, i, a, r) {\n  var s;\n  if (e !== a.$getRootId()) {\n    var o = a.getItem(e),\n      l = a.calculateItemLevel(o);\n    if (l === r) {\n      var d = a.getPrevSibling(e);\n      n < 0.5 && !d ? s = K.prevSiblingTarget(t, e, a) : (n < 0.5 && (e = d), s = K.nextSiblingTarget(t, e, a));\n    } else if (l > r) a.eachParent(function (f) {\n      a.calculateItemLevel(f) === r && (e = f.id);\n    }, o), s = le(t, e, r, a);else {\n      var c = le(t, e, r, a),\n        u = Je(t, e, r, a);\n      s = n < 0.5 ? c : u;\n    }\n  } else {\n    var h = a.$getRootId(),\n      g = a.getChildren(h);\n    s = K.createDropTargetObject(), s = g.length && i >= 0 ? le(t, function (f) {\n      for (var y = f.getNext(); f.exists(y);) {\n        var v = f.getNext(y);\n        if (!f.exists(v)) return y;\n        y = v;\n      }\n      return null;\n    }(a), r, a) : Je(t, h, r, a);\n  }\n  return s;\n}\nfunction Xe(t, e) {\n  var n = U(e.$grid_data);\n  return t.x += n.x + e.$grid.scrollLeft, t.y += n.y - e.$grid_data.scrollTop, t;\n}\nfunction de(t, e, n = 0) {\n  const i = U(t.$root);\n  return e > i.width && (e = i.width - n - 2), e;\n}\nconst Ze = {\n    removeLineHighlight: function (t) {\n      t.markerLine && t.markerLine.parentNode && t.markerLine.parentNode.removeChild(t.markerLine), t.markerLine = null;\n    },\n    highlightPosition: function (t, e, n) {\n      var i = function (r, s) {\n        var o = U(s.$grid_data),\n          l = rt(r, s.$grid_data),\n          d = o.x + s.$grid.scrollLeft,\n          c = l.y - 10,\n          u = s.getItemHeight(r.targetId);\n        c < o.y && (c = o.y);\n        var h = s.getTotalHeight();\n        return c > o.y + h - u && (c = o.y + h - u), o.x = d, o.y = c, o.width = de(s.$gantt, o.width, 9), o;\n      }(t, n);\n      e.marker.style.left = i.x + 9 + \"px\", e.marker.style.width = i.width + \"px\", e.marker.style.overflow = \"hidden\";\n      var a = e.markerLine;\n      a || ((a = document.createElement(\"div\")).className = \"gantt_drag_marker gantt_grid_dnd_marker\", a.innerHTML = \"<div class='gantt_grid_dnd_marker_line'></div>\", a.style.pointerEvents = \"none\"), t.child ? function (r, s, o) {\n        var l = r.targetParent,\n          d = Xe({\n            x: 0,\n            y: o.getItemTop(l)\n          }, o),\n          c = o.$grid_data.getBoundingClientRect().bottom + window.scrollY;\n        let u = de(o.$gantt, o.$grid_data.offsetWidth);\n        s.innerHTML = \"<div class='gantt_grid_dnd_marker_folder'></div>\", s.style.width = u + \"px\", s.style.top = d.y + \"px\", s.style.left = d.x + \"px\", s.style.height = o.getItemHeight(l) + \"px\", d.y > c && (s.style.top = c + \"px\");\n      }(t, a, n) : function (r, s, o) {\n        var l = function (u, h) {\n            var g = h.$config.rowStore,\n              f = {\n                x: 0,\n                y: 0\n              },\n              y = h.$grid_data.querySelector(\".gantt_tree_indent\"),\n              v = 15,\n              b = 0;\n            y && (v = y.offsetWidth);\n            var _ = 40;\n            if (u.targetId !== g.$getRootId()) {\n              var m = h.getItemTop(u.targetId),\n                p = h.getItemHeight(u.targetId);\n              if (b = g.exists(u.targetId) ? g.calculateItemLevel(g.getItem(u.targetId)) : 0, u.prevSibling) f.y = m;else if (u.nextSibling) {\n                var k = 0;\n                g.eachItem(function (x) {\n                  g.getIndexById(x.id) !== -1 && k++;\n                }, u.targetId), f.y = m + p + k * p;\n              } else f.y = m + p, b += 1;\n            }\n            return f.x = _ + b * v, f.width = de(h.$gantt, Math.max(h.$grid_data.offsetWidth - f.x, 0), f.x), Xe(f, h);\n          }(r, o),\n          d = o.$grid_data.getBoundingClientRect().bottom + window.scrollY;\n        s.innerHTML = \"<div class='gantt_grid_dnd_marker_line'></div>\", s.style.left = l.x + \"px\", s.style.height = \"4px\";\n        var c = l.y - 2;\n        s.style.top = c + \"px\", s.style.width = l.width + \"px\", c > d && (s.style.top = d + \"px\");\n      }(t, a, n), e.markerLine || (document.body.appendChild(a), e.markerLine = a);\n    }\n  },\n  Ba = {\n    init: function (t, e) {\n      var n = t.$services.getService(\"dnd\");\n      if (e.$config.bind && t.getDatastore(e.$config.bind)) {\n        var i = new n(e.$grid_data, {\n          updates_per_second: 60\n        });\n        t.defined(e.$getConfig().dnd_sensitivity) && (i.config.sensitivity = e.$getConfig().dnd_sensitivity), i.attachEvent(\"onBeforeDragStart\", t.bind(function (o, l) {\n          var d = a(l);\n          if (!d || (t.hideQuickInfo && t.hideQuickInfo(), ct(l.target, \".gantt_grid_editor_placeholder\"))) return !1;\n          var c = d.getAttribute(e.$config.item_attribute),\n            u = e.$config.rowStore.getItem(c);\n          return !t.isReadonly(u) && !r(c) && (i.config.initial_open_state = u.$open, !!t.callEvent(\"onRowDragStart\", [c, l.target || l.srcElement, l]) && void 0);\n        }, t)), i.attachEvent(\"onAfterDragStart\", t.bind(function (o, l) {\n          var d = a(l);\n          i.config.marker.innerHTML = d.outerHTML;\n          var c = i.config.marker.firstChild;\n          c && (i.config.marker.style.opacity = 0.4, c.style.position = \"static\", c.style.pointerEvents = \"none\"), i.config.id = d.getAttribute(e.$config.item_attribute);\n          var u = e.$config.rowStore,\n            h = u.getItem(i.config.id);\n          i.config.level = u.calculateItemLevel(h), i.config.drop_target = K.createDropTargetObject({\n            targetParent: u.getParent(h.id),\n            targetIndex: u.getBranchIndex(h.id),\n            targetId: h.id,\n            nextSibling: !0\n          }), h.$open = !1, h.$transparent = !0, this.refreshData();\n        }, t)), i.attachEvent(\"onDragMove\", t.bind(function (o, l) {\n          var d = s(l);\n          return d && t.callEvent(\"onBeforeRowDragMove\", [i.config.id, d.targetParent, d.targetIndex]) !== !1 || (d = K.createDropTargetObject(i.config.drop_target)), Ze.highlightPosition(d, i.config, e), i.config.drop_target = d, t._waiAria.reorderMarkerAttr(i.config.marker), this.callEvent(\"onRowDragMove\", [i.config.id, d.targetParent, d.targetIndex]), !0;\n        }, t)), i.attachEvent(\"onDragEnd\", t.bind(function () {\n          var o = e.$config.rowStore,\n            l = o.getItem(i.config.id);\n          Ze.removeLineHighlight(i.config), l.$transparent = !1, l.$open = i.config.initial_open_state;\n          var d = i.config.drop_target;\n          this.callEvent(\"onBeforeRowDragEnd\", [i.config.id, d.targetParent, d.targetIndex]) === !1 ? l.$drop_target = null : (o.move(i.config.id, d.targetIndex, d.targetParent), t.render(), this.callEvent(\"onRowDragEnd\", [i.config.id, d.targetParent, d.targetIndex])), o.refresh(l.id);\n        }, t));\n      }\n      function a(o) {\n        return et(o, e.$config.item_attribute);\n      }\n      function r(o) {\n        return Rt(o, t, t.getDatastore(e.$config.bind));\n      }\n      function s(o) {\n        var l,\n          d = function (f) {\n            var y = rt(f, e.$grid_data).y,\n              v = e.$config.rowStore;\n            document.doctype || (y += window.scrollY), y = y || 0;\n            var b = e.$state.scrollTop || 0,\n              _ = t.$grid_data.getBoundingClientRect().height + b + window.scrollY,\n              m = b,\n              p = e.getItemIndexByTopPosition(e.$state.scrollTop);\n            if (v.exists(p) || (p = v.countVisible() - 1), p < 0) return v.$getRootId();\n            var k = v.getIdByIndex(p),\n              x = e.$state.scrollTop / e.getItemHeight(k),\n              $ = x - Math.floor(x);\n            $ > 0.1 && $ < 0.9 && (_ -= e.getItemHeight(k) * $, m += e.getItemHeight(k) * (1 - $));\n            const w = U(e.$grid_data),\n              S = w.y + w.height,\n              T = i.config.marker.offsetHeight;\n            y + T + window.scrollY >= _ && (i.config.marker.style.top = S - T + \"px\"), y >= _ ? y = _ : y <= m && (y = m, i.config.marker.style.top = w.y + \"px\");\n            var E = e.getItemIndexByTopPosition(y);\n            if (E > v.countVisible() - 1 || E < 0) return v.$getRootId();\n            var C = v.getIdByIndex(E);\n            return r(C) ? v.getPrevSibling(C) : v.getIdByIndex(E);\n          }(o),\n          c = null,\n          u = e.$config.rowStore,\n          h = !e.$getConfig().order_branch_free,\n          g = rt(o, e.$grid_data).y;\n        return document.doctype || (g += window.scrollY), d !== u.$getRootId() && (c = (g - e.getItemTop(d)) / e.getItemHeight(d)), h ? (l = Ke(i.config.id, d, c, g, u, i.config.level)) && l.targetParent && r(l.targetParent) && (d = u.getPrevSibling(l.targetParent), l = Ke(i.config.id, d, c, g, u, i.config.level)) : l = function (f, y, v, b, _) {\n          var m;\n          if (y !== _.$getRootId()) m = v < 0.25 ? K.prevSiblingTarget(f, y, _) : !(v > 0.6) || _.hasChild(y) && _.getItem(y).$open ? K.firstChildTarget(f, y, _) : K.nextSiblingTarget(f, y, _);else {\n            var p = _.$getRootId();\n            m = _.hasChild(p) && b >= 0 ? K.lastChildTarget(f, p, _) : K.firstChildTarget(f, p, _);\n          }\n          return m;\n        }(i.config.id, d, c, g, u), l;\n      }\n    }\n  };\nvar za = function (t) {\n  return {\n    onCreated: function (e) {\n      e.$config = L(e.$config, {\n        bind: \"task\"\n      }), e.$config.id == \"grid\" && (this.extendGantt(e), t.ext.inlineEditors = t.ext._inlineEditors.createEditors(e), t.ext.inlineEditors.init()), this._mouseDelegates = Te(t);\n    },\n    onInitialized: function (e) {\n      var n = e.$getConfig();\n      n.order_branch && (n.order_branch == \"marker\" ? Ba.init(e.$gantt, e) : Oa.init(e.$gantt, e)), this.initEvents(e, t), e.$config.id == \"grid\" && this.extendDom(e);\n    },\n    onDestroyed: function (e) {\n      e.$config.id == \"grid\" && t.ext.inlineEditors.detachStore(), this.clearEvents(e, t);\n    },\n    initEvents: function (e, n) {\n      this._mouseDelegates.delegate(\"click\", \"gantt_row\", n.bind(function (i, a, r) {\n        const s = e.$getConfig();\n        if (a !== null) {\n          const o = this.getTask(a);\n          if (s.scroll_on_click) {\n            const l = !n._is_icon_open_click(i),\n              d = n.$ui.getView(\"timeline\");\n            l && d && this.showDate(o.start_date);\n          }\n          n.callEvent(\"onTaskRowClick\", [a, r]);\n        }\n      }, n), e.$grid), this._mouseDelegates.delegate(\"click\", \"gantt_grid_head_cell\", n.bind(function (i, a, r) {\n        var s = r.getAttribute(\"data-column-id\");\n        if (n.callEvent(\"onGridHeaderClick\", [s, i])) {\n          var o = e.$getConfig();\n          if (s != \"add\") {\n            if (o.sort && s) {\n              for (var l, d = s, c = 0; c < o.columns.length; c++) if (o.columns[c].name == s) {\n                l = o.columns[c];\n                break;\n              }\n              if (l && l.sort !== void 0 && l.sort !== !0 && !(d = l.sort)) return;\n              var u = this._sort && this._sort.direction && this._sort.name == s ? this._sort.direction : \"desc\";\n              u = u == \"desc\" ? \"asc\" : \"desc\", this._sort = {\n                name: s,\n                direction: u\n              }, this.sort(d, u == \"desc\");\n            }\n          } else n.$services.getService(\"mouseEvents\").callHandler(\"click\", \"gantt_add\", e.$grid, [i, o.root_id]);\n        }\n      }, n), e.$grid), this._mouseDelegates.delegate(\"click\", \"gantt_add\", n.bind(function (i, a, r) {\n        if (!e.$getConfig().readonly) return this.createTask({}, a || n.config.root_id), !1;\n      }, n), e.$grid);\n    },\n    clearEvents: function (e, n) {\n      this._mouseDelegates.destructor(), this._mouseDelegates = null;\n    },\n    extendDom: function (e) {\n      t.$grid = e.$grid, t.$grid_scale = e.$grid_scale, t.$grid_data = e.$grid_data;\n    },\n    extendGantt: function (e) {\n      t.getGridColumns = t.bind(e.getGridColumns, e), e.attachEvent(\"onColumnResizeStart\", function () {\n        return t.callEvent(\"onColumnResizeStart\", arguments);\n      }), e.attachEvent(\"onColumnResize\", function () {\n        return t.callEvent(\"onColumnResize\", arguments);\n      }), e.attachEvent(\"onColumnResizeEnd\", function () {\n        return t.callEvent(\"onColumnResizeEnd\", arguments);\n      }), e.attachEvent(\"onColumnResizeComplete\", function (n, i) {\n        t.config.grid_width = i;\n      }), e.attachEvent(\"onBeforeRowResize\", function () {\n        return t.callEvent(\"onBeforeRowResize\", arguments);\n      }), e.attachEvent(\"onRowResize\", function () {\n        return t.callEvent(\"onRowResize\", arguments);\n      }), e.attachEvent(\"onBeforeRowResizeEnd\", function () {\n        return t.callEvent(\"onBeforeRowResizeEnd\", arguments);\n      }), e.attachEvent(\"onAfterRowResize\", function () {\n        return t.callEvent(\"onAfterRowResize\", arguments);\n      });\n    }\n  };\n};\nconst Wa = {\n  createTaskDND: function () {\n    var t;\n    return {\n      extend: function (e) {\n        e.roundTaskDates = function (n) {\n          t.round_task_dates(n);\n        };\n      },\n      init: function (e, n) {\n        return t = function (i, a) {\n          var r = a.$services;\n          return {\n            drag: null,\n            dragMultiple: {},\n            _events: {\n              before_start: {},\n              before_finish: {},\n              after_finish: {}\n            },\n            _handlers: {},\n            init: function () {\n              this._domEvents = a._createDomEventScope(), this.clear_drag_state();\n              var s = a.config.drag_mode;\n              this.set_actions(), r.getService(\"state\").registerProvider(\"tasksDnd\", R(function () {\n                return {\n                  drag_id: this.drag ? this.drag.id : void 0,\n                  drag_mode: this.drag ? this.drag.mode : void 0,\n                  drag_from_start: this.drag ? this.drag.left : void 0\n                };\n              }, this));\n              var o = {\n                before_start: \"onBeforeTaskDrag\",\n                before_finish: \"onBeforeTaskChanged\",\n                after_finish: \"onAfterTaskDrag\"\n              };\n              for (var l in this._events) for (var d in s) this._events[l][d] = o[l];\n              this._handlers[s.move] = this._move, this._handlers[s.resize] = this._resize, this._handlers[s.progress] = this._resize_progress;\n            },\n            set_actions: function () {\n              var s = i.$task_data;\n              this._domEvents.attach(s, \"mousemove\", a.bind(function (o) {\n                this.on_mouse_move(o);\n              }, this)), this._domEvents.attach(s, \"mousedown\", a.bind(function (o) {\n                this.on_mouse_down(o);\n              }, this)), this._domEvents.attach(document.body, \"mouseup\", a.bind(function (o) {\n                this.on_mouse_up(o);\n              }, this));\n            },\n            clear_drag_state: function () {\n              this.drag = {\n                id: null,\n                mode: null,\n                pos: null,\n                start_x: null,\n                start_y: null,\n                obj: null,\n                left: null\n              }, this.dragMultiple = {};\n            },\n            _resize: function (s, o, l) {\n              var d = i.$getConfig(),\n                c = this._drag_task_coords(s, l);\n              l.left ? (s.start_date = a.dateFromPos(c.start + o), s.start_date || (s.start_date = new Date(a.getState().min_date))) : (s.end_date = a.dateFromPos(c.end + o), s.end_date || (s.end_date = new Date(a.getState().max_date)));\n              var u = this._calculateMinDuration(d.min_duration, d.duration_unit);\n              s.end_date - s.start_date < d.min_duration && (l.left ? s.start_date = a.calculateEndDate(s.end_date, -u, d.duration_unit, s) : s.end_date = a.calculateEndDate(s.start_date, u, d.duration_unit, s)), a._init_task_timing(s);\n            },\n            _calculateMinDuration: function (s, o) {\n              return Math.ceil(s / {\n                minute: 6e4,\n                hour: 36e5,\n                day: 864e5,\n                week: 6048e5,\n                month: 24192e5,\n                year: 31356e6\n              }[o]);\n            },\n            _resize_progress: function (s, o, l) {\n              var d = this._drag_task_coords(s, l),\n                c = i.$getConfig().rtl ? d.start - l.pos.x : l.pos.x - d.start,\n                u = Math.max(0, c);\n              s.progress = Math.min(1, u / Math.abs(d.end - d.start));\n            },\n            _find_max_shift: function (s, o) {\n              var l;\n              for (var d in s) {\n                var c = s[d],\n                  u = a.getTask(c.id),\n                  h = this._drag_task_coords(u, c),\n                  g = a.posFromDate(new Date(a.getState().min_date)),\n                  f = a.posFromDate(new Date(a.getState().max_date));\n                if (h.end + o > f) {\n                  var y = f - h.end;\n                  (y < l || l === void 0) && (l = y);\n                } else if (h.start + o < g) {\n                  var v = g - h.start;\n                  (v > l || l === void 0) && (l = v);\n                }\n              }\n              return l;\n            },\n            _move: function (s, o, l, d) {\n              var c = this._drag_task_coords(s, l),\n                u = null,\n                h = null;\n              d ? (u = new Date(+l.obj.start_date + d), h = new Date(+l.obj.end_date + d)) : (u = a.dateFromPos(c.start + o), h = a.dateFromPos(c.end + o)), u ? h ? (s.start_date = u, s.end_date = h) : (s.end_date = new Date(a.getState().max_date), s.start_date = a.dateFromPos(a.posFromDate(s.end_date) - (c.end - c.start))) : (s.start_date = new Date(a.getState().min_date), s.end_date = a.dateFromPos(a.posFromDate(s.start_date) + (c.end - c.start)));\n            },\n            _drag_task_coords: function (s, o) {\n              return {\n                start: o.obj_s_x = o.obj_s_x || a.posFromDate(s.start_date),\n                end: o.obj_e_x = o.obj_e_x || a.posFromDate(s.end_date)\n              };\n            },\n            _mouse_position_change: function (s, o) {\n              var l = s.x - o.x,\n                d = s.y - o.y;\n              return Math.sqrt(l * l + d * d);\n            },\n            _is_number: function (s) {\n              return !isNaN(parseFloat(s)) && isFinite(s);\n            },\n            on_mouse_move: function (s) {\n              if (this.drag.start_drag) {\n                var o = rt(s, a.$task_data),\n                  l = this.drag.start_drag.start_x,\n                  d = this.drag.start_drag.start_y;\n                (Date.now() - this.drag.timestamp > 50 || this._is_number(l) && this._is_number(d) && this._mouse_position_change({\n                  x: l,\n                  y: d\n                }, o) > 20) && this._start_dnd(s);\n              }\n              if (this.drag.mode) {\n                if (!un(this, 40)) return;\n                this._update_on_move(s);\n              }\n            },\n            _update_item_on_move: function (s, o, l, d, c, u) {\n              var h = a.getTask(o),\n                g = a.mixin({}, h),\n                f = a.mixin({}, h);\n              this._handlers[l].apply(this, [f, s, d, u]), a.mixin(h, f, !0), a.callEvent(\"onTaskDrag\", [h.id, l, f, g, c]), a.mixin(h, f, !0), a.refreshTask(o);\n            },\n            _update_on_move: function (s) {\n              var o = this.drag,\n                l = i.$getConfig();\n              if (o.mode) {\n                var d = rt(s, i.$task_data);\n                if (o.pos && o.pos.x == d.x) return;\n                o.pos = d;\n                var c = a.dateFromPos(d.x);\n                if (!c || isNaN(c.getTime())) return;\n                var u = d.x - o.start_x,\n                  h = a.getTask(o.id);\n                if (this._handlers[o.mode]) {\n                  if (o.mode === l.drag_mode.move) {\n                    var g = {};\n                    this._isMultiselect() && a.getSelectedTasks().indexOf(o.id) >= 0 && (g = this.dragMultiple);\n                    var f = !1;\n                    if (a.isSummaryTask(h) && a.config.drag_project) {\n                      var y = {};\n                      y[o.id] = G(o), f = !0, g = L(y, this.dragMultiple);\n                    }\n                    var v = this._find_max_shift(g, u);\n                    let m;\n                    if (v !== void 0 && (u = v), this._update_item_on_move(u, o.id, o.mode, o, s), v === void 0) {\n                      const p = a.posFromDate(o.obj.start_date),\n                        k = a.posFromDate(o.obj.end_date);\n                      if (o.handle_offset === void 0) {\n                        const $ = k - p,\n                          w = o.start_x - p;\n                        o.handle_offset = w / $;\n                      }\n                      let x = p + Math.abs(k - p) * o.handle_offset;\n                      m = c - a.dateFromPos(x);\n                    }\n                    for (var b in g) {\n                      var _ = g[b];\n                      f && _.id != o.id && (a._bulk_dnd = !0), this._update_item_on_move(u, _.id, _.mode, _, s, m);\n                    }\n                    a._bulk_dnd = !1;\n                  } else this._update_item_on_move(u, o.id, o.mode, o, s);\n                  a._update_parents(o.id);\n                }\n              }\n            },\n            on_mouse_down: function (s, o) {\n              if (s.button != 2 || s.button === void 0) {\n                var l = i.$getConfig(),\n                  d = a.locate(s),\n                  c = null;\n                if (a.isTaskExists(d) && (c = a.getTask(d)), !a.isReadonly(c) && !this.drag.mode) {\n                  this.clear_drag_state();\n                  var u = X(o = o || s.target || s.srcElement),\n                    h = this._get_drag_mode(u, o);\n                  if (!u || !h) return o.parentNode ? this.on_mouse_down(s, o.parentNode) : void 0;\n                  if (h) {\n                    if (h.mode && h.mode != l.drag_mode.ignore && l[\"drag_\" + h.mode]) {\n                      if (d = a.locate(o), c = a.copy(a.getTask(d) || {}), a.isReadonly(c)) return this.clear_drag_state(), !1;\n                      if (a.isSummaryTask(c) && c.auto_scheduling !== !1 && !l.drag_project && h.mode != l.drag_mode.progress) return void this.clear_drag_state();\n                      h.id = d;\n                      var g = rt(s, a.$task_data);\n                      h.start_x = g.x, h.start_y = g.y, h.obj = c, this.drag.start_drag = h, this.drag.timestamp = Date.now();\n                    } else this.clear_drag_state();\n                  } else if (a.checkEvent(\"onMouseDown\") && a.callEvent(\"onMouseDown\", [u.split(\" \")[0]]) && o.parentNode) return this.on_mouse_down(s, o.parentNode);\n                }\n              }\n            },\n            _fix_dnd_scale_time: function (s, o) {\n              var l = i.$getConfig(),\n                d = a.getScale().unit,\n                c = a.getScale().step;\n              function u(h) {\n                if (a.config.correct_work_time) {\n                  var g = i.$getConfig();\n                  a.isWorkTime(h.start_date, void 0, h) || (h.start_date = a.calculateEndDate({\n                    start_date: h.start_date,\n                    duration: -1,\n                    unit: g.duration_unit,\n                    task: h\n                  }));\n                }\n              }\n              l.round_dnd_dates || (d = \"minute\", c = l.time_step), o.mode == l.drag_mode.resize ? o.left ? (s.start_date = a.roundDate({\n                date: s.start_date,\n                unit: d,\n                step: c\n              }), u(s)) : (s.end_date = a.roundDate({\n                date: s.end_date,\n                unit: d,\n                step: c\n              }), function (h) {\n                if (a.config.correct_work_time) {\n                  var g = i.$getConfig();\n                  a.isWorkTime(new Date(h.end_date - 1), void 0, h) || (h.end_date = a.calculateEndDate({\n                    start_date: h.end_date,\n                    duration: 1,\n                    unit: g.duration_unit,\n                    task: h\n                  }));\n                }\n              }(s)) : o.mode == l.drag_mode.move && (s.start_date = a.roundDate({\n                date: s.start_date,\n                unit: d,\n                step: c\n              }), u(s), s.end_date = a.calculateEndDate(s));\n            },\n            _fix_working_times: function (s, o) {\n              var l = i.$getConfig();\n              (o = o || {\n                mode: l.drag_mode.move\n              }).mode == l.drag_mode.resize ? o.left ? s.start_date = a.getClosestWorkTime({\n                date: s.start_date,\n                dir: \"future\",\n                task: s\n              }) : s.end_date = a.getClosestWorkTime({\n                date: s.end_date,\n                dir: \"past\",\n                task: s\n              }) : o.mode == l.drag_mode.move && a.correctTaskWorkTime(s);\n            },\n            _finalize_mouse_up: function (s, o, l, d) {\n              var c = a.getTask(s);\n              if (o.work_time && o.correct_work_time && this._fix_working_times(c, l), this._fix_dnd_scale_time(c, l), this._fireEvent(\"before_finish\", l.mode, [s, l.mode, a.copy(l.obj), d])) {\n                var u = s;\n                a._init_task_timing(c), this.clear_drag_state(), a.updateTask(c.id), this._fireEvent(\"after_finish\", l.mode, [u, l.mode, d]);\n              } else this.clear_drag_state(), s == l.id && (l.obj._dhx_changed = !1, a.mixin(c, l.obj, !0)), a.refreshTask(c.id);\n            },\n            on_mouse_up: function (s) {\n              var o = this.drag;\n              if (o.mode && o.id) {\n                var l = i.$getConfig(),\n                  d = a.getTask(o.id),\n                  c = this.dragMultiple,\n                  u = !1,\n                  h = 0;\n                o.mode === l.drag_mode.move && (a.isSummaryTask(d) && l.drag_project || this._isMultiselect()) && (u = !0, h = Object.keys(c).length);\n                var g = function () {\n                  if (u) for (var f in c) c[f].id != o.id && this._finalize_mouse_up(c[f].id, l, c[f], s);\n                  this._finalize_mouse_up(o.id, l, o, s);\n                };\n                u && h > 10 ? a.batchUpdate(function () {\n                  g.call(this);\n                }.bind(this)) : g.call(this);\n              }\n              this.clear_drag_state();\n            },\n            _get_drag_mode: function (s, o) {\n              var l = i.$getConfig().drag_mode,\n                d = {\n                  mode: null,\n                  left: null\n                };\n              switch ((s || \"\").split(\" \")[0]) {\n                case \"gantt_task_line\":\n                case \"gantt_task_content\":\n                  d.mode = l.move;\n                  break;\n                case \"gantt_task_drag\":\n                  d.mode = l.resize;\n                  var c = o.getAttribute(\"data-bind-property\");\n                  d.left = c == \"start_date\";\n                  break;\n                case \"gantt_task_progress_drag\":\n                  d.mode = l.progress;\n                  break;\n                case \"gantt_link_control\":\n                case \"gantt_link_point\":\n                  d.mode = l.ignore;\n                  break;\n                default:\n                  d = null;\n              }\n              return d;\n            },\n            _start_dnd: function (s) {\n              var o = this.drag = this.drag.start_drag;\n              delete o.start_drag;\n              var l = i.$getConfig(),\n                d = o.id;\n              if (l[\"drag_\" + o.mode] && a.callEvent(\"onBeforeDrag\", [d, o.mode, s]) && this._fireEvent(\"before_start\", o.mode, [d, o.mode, s])) {\n                delete o.start_drag;\n                var c = a.getTask(d);\n                if (a.isReadonly(c)) return void this.clear_drag_state();\n                if (this._isMultiselect()) {\n                  var u = a.getSelectedTasks();\n                  u.indexOf(o.id) >= 0 && kt(u, a.bind(function (h) {\n                    var g = a.getTask(h);\n                    a.isSummaryTask(g) && a.config.drag_project && o.mode == l.drag_mode.move && this._addSubtasksToDragMultiple(g.id), this.dragMultiple[h] = a.mixin({\n                      id: g.id,\n                      obj: a.copy(g)\n                    }, this.drag);\n                  }, this));\n                }\n                a.isSummaryTask(c) && a.config.drag_project && o.mode == l.drag_mode.move && this._addSubtasksToDragMultiple(c.id), a.callEvent(\"onTaskDragStart\", []);\n              } else this.clear_drag_state();\n            },\n            _fireEvent: function (s, o, l) {\n              a.assert(this._events[s], \"Invalid stage:{\" + s + \"}\");\n              var d = this._events[s][o];\n              return a.assert(d, \"Unknown after drop mode:{\" + o + \"}\"), a.assert(l, \"Invalid event arguments\"), !a.checkEvent(d) || a.callEvent(d, l);\n            },\n            round_task_dates: function (s) {\n              var o = this.drag,\n                l = i.$getConfig();\n              o || (o = {\n                mode: l.drag_mode.move\n              }), this._fix_dnd_scale_time(s, o);\n            },\n            destructor: function () {\n              this._domEvents.detachAll();\n            },\n            _isMultiselect: function () {\n              return a.config.drag_multiple && !!(a.getSelectedTasks && a.getSelectedTasks().length > 0);\n            },\n            _addSubtasksToDragMultiple: function (s) {\n              a.eachTask(function (o) {\n                this.dragMultiple[o.id] = a.mixin({\n                  id: o.id,\n                  obj: a.copy(o)\n                }, this.drag);\n              }, s, this);\n            }\n          };\n        }(e, n), e._tasks_dnd = t, t.init(n);\n      },\n      destructor: function () {\n        t && (t.destructor(), t = null);\n      }\n    };\n  }\n};\nvar ja = function (t, e) {\n  var n, i, a, r, s;\n  function o() {\n    return {\n      link_source_id: r,\n      link_target_id: i,\n      link_from_start: s,\n      link_to_start: a,\n      link_landing_area: n\n    };\n  }\n  var l = e.$services,\n    d = l.getService(\"state\"),\n    c = l.getService(\"dnd\");\n  d.registerProvider(\"linksDnD\", o);\n  var u = \"gantt_link_point\",\n    h = \"gantt_link_control\",\n    g = new c(t.$task_bars, {\n      sensitivity: 0,\n      updates_per_second: 60,\n      mousemoveContainer: e.$root,\n      selector: \".\" + u,\n      preventDefault: !0\n    });\n  function f(m, p) {\n    var k,\n      x = g.getPosition(m),\n      $ = function (M) {\n        var A = 0,\n          I = 0;\n        return M && (A = M.offsetWidth || 0, I = M.offsetHeight || 0), {\n          width: A,\n          height: I\n        };\n      }(p),\n      w = {\n        right: (k = e.$root).offsetWidth,\n        bottom: k.offsetHeight\n      },\n      S = e.config.tooltip_offset_x || 10,\n      T = e.config.tooltip_offset_y || 10,\n      E = e.config.scroll_size || 18,\n      C = e.$container.getBoundingClientRect().y + window.scrollY,\n      D = {\n        y: x.y + T,\n        x: x.x + S,\n        bottom: x.y + $.height + T + E,\n        right: x.x + $.width + S + E\n      };\n    return D.bottom > w.bottom + C && (D.y = w.bottom + C - $.height - T), D.right > w.right && (D.x = w.right - $.width - S), D;\n  }\n  function y(m) {\n    var p = o();\n    p.link_source_id && p.link_target_id && e.isLinkAllowed(p.link_source_id, p.link_target_id, p.link_from_start, p.link_to_start);\n    var k = \"<div class='\" + e.templates.drag_link_class(p.link_source_id, p.link_from_start, p.link_target_id, p.link_to_start) + \"'>\" + e.templates.drag_link(p.link_source_id, p.link_from_start, p.link_target_id, p.link_to_start) + \"</div>\";\n    m.innerHTML = k;\n  }\n  function v() {\n    r = s = i = null, a = !0;\n  }\n  function b(m, p, k, x) {\n    var $ = function () {\n        return g._direction && g._direction.parentNode || (g._direction = document.createElement(\"div\"), t.$task_links.appendChild(g._direction)), g._direction;\n      }(),\n      w = o(),\n      S = [\"gantt_link_direction\"];\n    e.templates.link_direction_class && S.push(e.templates.link_direction_class(w.link_source_id, w.link_from_start, w.link_target_id, w.link_to_start));\n    var T = Math.sqrt(Math.pow(k - m, 2) + Math.pow(x - p, 2));\n    if (T = Math.max(0, T - 3)) {\n      $.className = S.join(\" \");\n      var E = (x - p) / (k - m),\n        C = Math.atan(E);\n      _(m, k, p, x) == 2 ? C += Math.PI : _(m, k, p, x) == 3 && (C -= Math.PI);\n      var D = Math.sin(C),\n        M = Math.cos(C),\n        A = Math.round(p),\n        I = Math.round(m),\n        N = [\"-webkit-transform: rotate(\" + C + \"rad)\", \"-moz-transform: rotate(\" + C + \"rad)\", \"-ms-transform: rotate(\" + C + \"rad)\", \"-o-transform: rotate(\" + C + \"rad)\", \"transform: rotate(\" + C + \"rad)\", \"width:\" + Math.round(T) + \"px\"];\n      if (window.navigator.userAgent.indexOf(\"MSIE 8.0\") != -1) {\n        N.push('-ms-filter: \"' + function (z, F) {\n          return \"progid:DXImageTransform.Microsoft.Matrix(M11 = \" + F + \",M12 = -\" + z + \",M21 = \" + z + \",M22 = \" + F + \",SizingMethod = 'auto expand')\";\n        }(D, M) + '\"');\n        var P = Math.abs(Math.round(m - k)),\n          O = Math.abs(Math.round(x - p));\n        switch (_(m, k, p, x)) {\n          case 1:\n            A -= O;\n            break;\n          case 2:\n            I -= P, A -= O;\n            break;\n          case 3:\n            I -= P;\n        }\n      }\n      N.push(\"top:\" + A + \"px\"), N.push(\"left:\" + I + \"px\"), $.style.cssText = N.join(\";\");\n    }\n  }\n  function _(m, p, k, x) {\n    return p >= m ? x <= k ? 1 : 4 : x <= k ? 2 : 3;\n  }\n  g.attachEvent(\"onBeforeDragStart\", e.bind(function (m, p) {\n    var k = p.target || p.srcElement;\n    if (v(), e.getState(\"tasksDnd\").drag_id) return !1;\n    if (pt(k, u)) {\n      pt(k, \"task_start_date\") && (s = !0);\n      var x = e.locate(p);\n      r = x;\n      var $ = e.getTask(x);\n      return e.isReadonly($) ? (v(), !1) : (this._dir_start = {\n        x: g.config.original_element_sizes.x + g.config.original_element_sizes.width / 2,\n        y: g.config.original_element_sizes.y + g.config.original_element_sizes.height / 2\n      }, !0);\n    }\n    return !1;\n  }, this)), g.attachEvent(\"onAfterDragStart\", e.bind(function (m, p) {\n    e.config.touch && e.refreshData(), y(g.config.marker);\n  }, this)), g.attachEvent(\"onDragMove\", e.bind(function (m, p) {\n    var k = g.config,\n      x = f(p, k.marker);\n    (function (M, A) {\n      M.style.left = A.x + \"px\", M.style.top = A.y + \"px\";\n    })(k.marker, x);\n    var $ = !!pt(p, h),\n      w = i,\n      S = n,\n      T = a,\n      E = e.locate(p),\n      C = !0;\n    if (Y(yt(p), e.$root) || ($ = !1, E = null), $ && (C = !pt(p, \"task_end_date\"), $ = !!E), i = E, n = $, a = C, $) {\n      const M = pt(p, h).querySelector(`.${u}`);\n      if (M) {\n        const A = an(M, t.$task_bg);\n        this._dir_end = {\n          x: A.x + M.offsetWidth / 2,\n          y: A.y + M.offsetHeight / 2\n        };\n      }\n    } else this._dir_end = rt(p, t.$task_data), e.env.isEdge && (this._dir_end.y += window.scrollY);\n    var D = !(S == $ && w == E && T == C);\n    return D && (w && e.refreshTask(w, !1), E && e.refreshTask(E, !1)), D && y(k.marker), b(this._dir_start.x, this._dir_start.y, this._dir_end.x, this._dir_end.y), !0;\n  }, this)), g.attachEvent(\"onDragEnd\", e.bind(function () {\n    var m = o();\n    if (m.link_source_id && m.link_target_id && m.link_source_id != m.link_target_id) {\n      var p = e._get_link_type(m.link_from_start, m.link_to_start),\n        k = {\n          source: m.link_source_id,\n          target: m.link_target_id,\n          type: p\n        };\n      k.type && e.isLinkAllowed(k) && e.callEvent(\"onLinkCreated\", [k]) && e.addLink(k);\n    }\n    v(), e.config.touch ? e.refreshData() : (m.link_source_id && e.refreshTask(m.link_source_id, !1), m.link_target_id && e.refreshTask(m.link_target_id, !1)), g._direction && (g._direction.parentNode && g._direction.parentNode.removeChild(g._direction), g._direction = null);\n  }, this)), e.attachEvent(\"onGanttRender\", e.bind(function () {\n    g._direction && b(this._dir_start.x, this._dir_start.y, this._dir_end.x, this._dir_end.y);\n  }, this));\n};\nconst Fa = function () {\n  return {\n    init: ja\n  };\n};\nvar Va = function (t) {\n    var e = t.$services;\n    return {\n      onCreated: function (n) {\n        var i = n.$config;\n        i.bind = j(i.bind) ? i.bind : \"task\", i.bindLinks = j(i.bindLinks) ? i.bindLinks : \"link\", n._linksDnD = Fa(), n._tasksDnD = Wa.createTaskDND(), n._tasksDnD.extend(n), this._mouseDelegates = Te(t);\n      },\n      onInitialized: function (n) {\n        this._attachDomEvents(t), this._attachStateProvider(t, n), n._tasksDnD.init(n, t), n._linksDnD.init(n, t), n.$config.id == \"timeline\" && this.extendDom(n);\n      },\n      onDestroyed: function (n) {\n        this._clearDomEvents(t), this._clearStateProvider(t), n._tasksDnD && n._tasksDnD.destructor();\n      },\n      extendDom: function (n) {\n        t.$task = n.$task, t.$task_scale = n.$task_scale, t.$task_data = n.$task_data, t.$task_bg = n.$task_bg, t.$task_links = n.$task_links, t.$task_bars = n.$task_bars;\n      },\n      _clearDomEvents: function () {\n        this._mouseDelegates.destructor(), this._mouseDelegates = null;\n      },\n      _attachDomEvents: function (n) {\n        function i(a, r) {\n          if (a && this.callEvent(\"onLinkDblClick\", [a, r])) {\n            var s = this.getLink(a);\n            if (this.isReadonly(s)) return;\n            var o = this.locale.labels.link + \" \" + this.templates.link_description(this.getLink(a)) + \" \" + this.locale.labels.confirm_link_deleting;\n            window.setTimeout(function () {\n              n._simple_confirm(o, \"\", function () {\n                n.deleteLink(a);\n              });\n            }, this.config.touch ? 300 : 1);\n          }\n        }\n        this._mouseDelegates.delegate(\"click\", \"gantt_task_link\", n.bind(function (a, r) {\n          var s = this.locate(a, this.config.link_attribute);\n          s && this.callEvent(\"onLinkClick\", [s, a]);\n        }, n), this.$task), this._mouseDelegates.delegate(\"click\", \"gantt_scale_cell\", n.bind(function (a, r) {\n          var s = rt(a, n.$task_data),\n            o = n.dateFromPos(s.x),\n            l = Math.floor(n.columnIndexByDate(o)),\n            d = n.getScale().trace_x[l];\n          n.callEvent(\"onScaleClick\", [a, d]);\n        }, n), this.$task), this._mouseDelegates.delegate(\"doubleclick\", \"gantt_task_link\", n.bind(function (a, r, s) {\n          r = this.locate(a, n.config.link_attribute), i.call(this, r, a);\n        }, n), this.$task), this._mouseDelegates.delegate(\"doubleclick\", \"gantt_link_point\", n.bind(function (a, r, s) {\n          r = this.locate(a);\n          var o = this.getTask(r),\n            l = null;\n          return s.parentNode && X(s.parentNode) && (l = X(s.parentNode).indexOf(\"_left\") > -1 ? o.$target[0] : o.$source[0]), l && i.call(this, l, a), !1;\n        }, n), this.$task);\n      },\n      _attachStateProvider: function (n, i) {\n        var a = i;\n        e.getService(\"state\").registerProvider(\"tasksTimeline\", function () {\n          return {\n            scale_unit: a._tasks ? a._tasks.unit : void 0,\n            scale_step: a._tasks ? a._tasks.step : void 0\n          };\n        });\n      },\n      _clearStateProvider: function () {\n        e.getService(\"state\").unregisterProvider(\"tasksTimeline\");\n      }\n    };\n  },\n  Ua = function (t) {\n    return {\n      getVerticalScrollbar: function () {\n        return t.$ui.getView(\"scrollVer\");\n      },\n      getHorizontalScrollbar: function () {\n        return t.$ui.getView(\"scrollHor\");\n      },\n      _legacyGridResizerClass: function (e) {\n        for (var n = e.getCellsByType(\"resizer\"), i = 0; i < n.length; i++) {\n          var a = n[i],\n            r = !1,\n            s = a.$parent.getPrevSibling(a.$id);\n          if (s && s.$config && s.$config.id === \"grid\") r = !0;else {\n            var o = a.$parent.getNextSibling(a.$id);\n            o && o.$config && o.$config.id === \"grid\" && (r = !0);\n          }\n          r && (a.$config.css = (a.$config.css ? a.$config.css + \" \" : \"\") + \"gantt_grid_resize_wrap\");\n        }\n      },\n      onCreated: function (e) {\n        var n = !0;\n        this._legacyGridResizerClass(e), e.attachEvent(\"onBeforeResize\", function () {\n          var i = t.$ui.getView(\"timeline\");\n          i && (i.$config.hidden = i.$parent.$config.hidden = !t.config.show_chart);\n          var a = t.$ui.getView(\"grid\");\n          if (a) {\n            var r = a._getColsTotalWidth(),\n              s = !t.config.show_grid || !t.config.grid_width || r === 0;\n            if (n && !s && r !== !1 && (t.config.grid_width = r), a.$config.hidden = a.$parent.$config.hidden = s, !a.$config.hidden) {\n              var o = a._getGridWidthLimits();\n              if (o[0] && t.config.grid_width < o[0] && (t.config.grid_width = o[0]), o[1] && t.config.grid_width > o[1] && (t.config.grid_width = o[1]), i && t.config.show_chart) {\n                if (a.$config.width = t.config.grid_width - 1, !a.$config.scrollable && a.$config.scrollY && t.$root.offsetWidth) {\n                  var l = a.$gantt.$layout.$container.offsetWidth,\n                    d = t.$ui.getView(a.$config.scrollY).$config.width,\n                    c = l - (a.$config.width + d) - 4;\n                  c < 0 && (a.$config.width += c, t.config.grid_width += c);\n                }\n                if (n) a.$parent.$config.width = t.config.grid_width, a.$parent.$config.group && t.$layout._syncCellSizes(a.$parent.$config.group, {\n                  value: a.$parent.$config.width,\n                  isGravity: !1\n                });else if (i && !Y(i.$task, e.$view)) {\n                  if (!a.$config.original_grid_width) {\n                    var u = t.skins[t.skin];\n                    u && u.config && u.config.grid_width ? a.$config.original_grid_width = u.config.grid_width : a.$config.original_grid_width = 0;\n                  }\n                  t.config.grid_width = a.$config.original_grid_width, a.$parent.$config.width = t.config.grid_width;\n                } else a.$parent._setContentSize(a.$config.width, null), t.$layout._syncCellSizes(a.$parent.$config.group, {\n                  value: t.config.grid_width,\n                  isGravity: !1\n                });\n              } else i && Y(i.$task, e.$view) && (a.$config.original_grid_width = t.config.grid_width), n || (a.$parent.$config.width = 0);\n            }\n            n = !1;\n          }\n        }), this._initScrollStateEvents(e);\n      },\n      _initScrollStateEvents: function (e) {\n        t._getVerticalScrollbar = this.getVerticalScrollbar, t._getHorizontalScrollbar = this.getHorizontalScrollbar;\n        var n = this.getVerticalScrollbar(),\n          i = this.getHorizontalScrollbar();\n        n && n.attachEvent(\"onScroll\", function (a, r, s) {\n          var o = t.getScrollState();\n          t.callEvent(\"onGanttScroll\", [o.x, a, o.x, r]);\n        }), i && i.attachEvent(\"onScroll\", function (a, r, s) {\n          var o = t.getScrollState();\n          t.callEvent(\"onGanttScroll\", [a, o.y, r, o.y]);\n          var l = t.$ui.getView(\"grid\");\n          l && l.$grid_data && !l.$config.scrollable && (l.$grid_data.style.left = l.$grid.scrollLeft + \"px\", l.$grid_data.scrollLeft = l.$grid.scrollLeft);\n        }), e.attachEvent(\"onResize\", function () {\n          n && !t.$scroll_ver && (t.$scroll_ver = n.$scroll_ver), i && !t.$scroll_hor && (t.$scroll_hor = i.$scroll_hor);\n        });\n      },\n      _findGridResizer: function (e, n) {\n        for (var i, a = e.getCellsByType(\"resizer\"), r = !0, s = 0; s < a.length; s++) {\n          var o = a[s];\n          o._getSiblings();\n          var l = o._behind,\n            d = o._front;\n          if (l && l.$content === n || l.isChild && l.isChild(n)) {\n            i = o, r = !0;\n            break;\n          }\n          if (d && d.$content === n || d.isChild && d.isChild(n)) {\n            i = o, r = !1;\n            break;\n          }\n        }\n        return {\n          resizer: i,\n          gridFirst: r\n        };\n      },\n      onInitialized: function (e) {\n        var n = t.$ui.getView(\"grid\"),\n          i = this._findGridResizer(e, n);\n        if (i.resizer) {\n          var a,\n            r = i.gridFirst,\n            s = i.resizer;\n          if (s.$config.mode !== \"x\") return;\n          s.attachEvent(\"onResizeStart\", function (o, l) {\n            var d = t.$ui.getView(\"grid\"),\n              c = d ? d.$parent : null;\n            if (c) {\n              var u = d._getGridWidthLimits();\n              d.$config.scrollable || (c.$config.minWidth = u[0]), c.$config.maxWidth = u[1];\n            }\n            return a = r ? o : l, t.callEvent(\"onGridResizeStart\", [a]);\n          }), s.attachEvent(\"onResize\", function (o, l) {\n            var d = r ? o : l;\n            return t.callEvent(\"onGridResize\", [a, d]);\n          }), s.attachEvent(\"onResizeEnd\", function (o, l, d, c) {\n            var u = r ? o : l,\n              h = r ? d : c,\n              g = t.$ui.getView(\"grid\"),\n              f = g ? g.$parent : null;\n            f && (f.$config.minWidth = void 0);\n            var y = t.callEvent(\"onGridResizeEnd\", [u, h]);\n            return y && h !== 0 && (t.config.grid_width = h), y;\n          });\n        }\n      },\n      onDestroyed: function (e) {}\n    };\n  };\nconst qa = {\n  init: function (t) {\n    function e(r, s) {\n      var o = s(t);\n      o.onCreated && o.onCreated(r), r.attachEvent(\"onReady\", function () {\n        o.onInitialized && o.onInitialized(r);\n      }), r.attachEvent(\"onDestroy\", function () {\n        o.onDestroyed && o.onDestroyed(r);\n      });\n    }\n    var n = ha(t);\n    n.registerView(\"cell\", Ht), n.registerView(\"resizer\", null), n.registerView(\"scrollbar\", ka), n.registerView(\"layout\", yn, function (r) {\n      (r.$config ? r.$config.id : null) === \"main\" && e(r, Ua);\n    }), n.registerView(\"viewcell\", va), n.registerView(\"multiview\", ma), n.registerView(\"timeline\", Ut, function (r) {\n      (r.$config ? r.$config.id : null) !== \"timeline\" && r.$config.bind != \"task\" || e(r, Va);\n    }), n.registerView(\"grid\", xe, function (r) {\n      (r.$config ? r.$config.id : null) !== \"grid\" && r.$config.bind != \"task\" || e(r, za);\n    }), n.registerView(\"resourceGrid\", xe), n.registerView(\"resourceTimeline\", Ut), n.registerView(\"resourceHistogram\", Ut);\n    var i = function (r) {\n        var s = fa(r);\n        return {\n          getDataRender: function (o) {\n            return r.$services.getService(\"layer:\" + o) || null;\n          },\n          createDataRender: function (o) {\n            var l = o.name,\n              d = o.defaultContainer,\n              c = o.defaultContainerSibling,\n              u = s.createGroup(d, c, function (h, g) {\n                if (!u.filters) return !0;\n                for (var f = 0; f < u.filters.length; f++) if (u.filters[f](h, g) === !1) return !1;\n              }, pa);\n            return r.$services.setService(\"layer:\" + l, function () {\n              return u;\n            }), r.attachEvent(\"onGanttReady\", function () {\n              u.addLayer();\n            }), u;\n          },\n          init: function () {\n            var o = this.createDataRender({\n                name: \"task\",\n                defaultContainer: function () {\n                  return r.$task_data ? r.$task_data : r.$ui.getView(\"timeline\") ? r.$ui.getView(\"timeline\").$task_data : void 0;\n                },\n                defaultContainerSibling: function () {\n                  return r.$task_links ? r.$task_links : r.$ui.getView(\"timeline\") ? r.$ui.getView(\"timeline\").$task_links : void 0;\n                },\n                filter: function (d) {}\n              }, r),\n              l = this.createDataRender({\n                name: \"link\",\n                defaultContainer: function () {\n                  return r.$task_data ? r.$task_data : r.$ui.getView(\"timeline\") ? r.$ui.getView(\"timeline\").$task_data : void 0;\n                }\n              }, r);\n            return {\n              addTaskLayer: function (d) {\n                const c = ft;\n                return typeof d == \"function\" ? d = {\n                  renderer: {\n                    render: d,\n                    getVisibleRange: c\n                  }\n                } : d.renderer && !d.renderer.getVisibleRange && (d.renderer.getVisibleRange = c), d.view = \"timeline\", o.addLayer(d);\n              },\n              _getTaskLayers: function () {\n                return o.getLayers();\n              },\n              removeTaskLayer: function (d) {\n                o.removeLayer(d);\n              },\n              _clearTaskLayers: function () {\n                o.clear();\n              },\n              addLinkLayer: function (d) {\n                const c = vn();\n                return typeof d == \"function\" ? d = {\n                  renderer: {\n                    render: d,\n                    getVisibleRange: c\n                  }\n                } : d.renderer && !d.renderer.getVisibleRange && (d.renderer.getVisibleRange = c), d.view = \"timeline\", d && d.renderer && (d.renderer.getRectangle || d.renderer.isInViewPort || (d.renderer.isInViewPort = kn)), l.addLayer(d);\n              },\n              _getLinkLayers: function () {\n                return l.getLayers();\n              },\n              removeLinkLayer: function (d) {\n                l.removeLayer(d);\n              },\n              _clearLinkLayers: function () {\n                l.clear();\n              }\n            };\n          }\n        };\n      }(t),\n      a = Na(t);\n    return t.ext.inlineEditors = a, t.ext._inlineEditors = a, a.init(t), {\n      factory: n,\n      mouseEvents: ga.init(t),\n      layersApi: i.init(),\n      render: {\n        gridLine: function () {\n          return /* @__PURE__ */function (r) {\n            return {\n              render: function (s, o, l, d) {\n                for (var c = o.getGridColumns(), u = o.$getTemplates(), h = o.$config.rowStore, g = [], f = 0; f < c.length; f++) {\n                  var y,\n                    v,\n                    b,\n                    _ = f == c.length - 1,\n                    m = c[f];\n                  m.name == \"add\" ? (v = \"<div \" + (S = r._waiAria.gridAddButtonAttrString(m)) + \" class='gantt_add'></div>\", b = \"\") : (Z(v = m.template ? m.template(s) : s[m.name]) && (v = u.date_grid(v, s, m.name)), v == null && (v = \"\"), b = v, v = \"<div class='gantt_tree_content'>\" + v + \"</div>\");\n                  var p = \"gantt_cell\" + (_ ? \" gantt_last_cell\" : \"\"),\n                    k = [];\n                  if (m.tree) {\n                    p += \" gantt_cell_tree\";\n                    for (var x = 0; x < s.$level; x++) k.push(u.grid_indent(s));\n                    !h.hasChild(s.id) || r.isSplitTask(s) && !r.config.open_split_tasks ? (k.push(u.grid_blank(s)), k.push(u.grid_file(s))) : (k.push(u.grid_open(s)), k.push(u.grid_folder(s)));\n                  }\n                  var $ = \"width:\" + (m.width - (_ ? 1 : 0)) + \"px;\";\n                  if (this.defined(m.align)) {\n                    var w = {\n                      right: \"flex-end\",\n                      left: \"flex-start\",\n                      center: \"center\"\n                    }[m.align];\n                    $ += \"text-align:\" + m.align + \";justify-content:\" + w + \";\";\n                  }\n                  var S = r._waiAria.gridCellAttrString(m, b, s);\n                  k.push(v), y = \"<div class='\" + p + \"' data-column-index='\" + f + \"' data-column-name='\" + m.name + \"' style='\" + $ + \"' \" + S + \">\" + k.join(\"\") + \"</div>\", g.push(y);\n                }\n                switch (p = \"\", h.$config.name) {\n                  case \"task\":\n                    p = r.getGlobalTaskIndex(s.id) % 2 == 0 ? \"\" : \" odd\";\n                    break;\n                  case \"resource\":\n                    p = h.visibleOrder.indexOf(s.id) % 2 == 0 ? \"\" : \" odd\";\n                }\n                if (p += s.$transparent ? \" gantt_transparent\" : \"\", p += s.$dataprocessor_class ? \" \" + s.$dataprocessor_class : \"\", u.grid_row_class) {\n                  var T = u.grid_row_class.call(r, s.start_date, s.end_date, s);\n                  T && (p += \" \" + T);\n                }\n                h.isSelected(s.id) && (p += \" gantt_selected\");\n                var E = document.createElement(\"div\");\n                E.className = \"gantt_row\" + p + \" gantt_row_\" + r.getTaskType(s.type);\n                var C = o.getItemHeight(s.id);\n                return E.style.height = C + \"px\", E.style.lineHeight = C + \"px\", l.smart_rendering && (E.style.position = \"absolute\", E.style.left = \"0px\", E.style.top = o.getItemTop(s.id) + \"px\"), o.$config.item_attribute && (E.setAttribute(o.$config.item_attribute, s.id), E.setAttribute(o.$config.bind + \"_id\", s.id)), r._waiAria.taskRowAttr(s, E), E.innerHTML = g.join(\"\"), E;\n              },\n              update: null,\n              getRectangle: Kt,\n              isInViewPort: Ra,\n              getVisibleRange: ft,\n              onrender: function (s, o, l) {\n                for (var d = l.getGridColumns(), c = 0; c < d.length; c++) {\n                  var u = d[c];\n                  if (u.onrender) {\n                    var h = o.querySelector(\"[data-column-name=\" + u.name + \"]\");\n                    if (h) {\n                      var g = u.onrender(s, h);\n                      if (g && typeof g == \"string\") h.innerHTML = g;else if (g && typeof g == \"object\" && r.config.external_render) {\n                        var f = r.config.external_render;\n                        f.isElement(g) && f.renderElement(g, h);\n                      }\n                    }\n                  }\n                }\n              }\n            };\n          }(t);\n        },\n        taskBg: function () {\n          return /* @__PURE__ */function (r) {\n            var s = {},\n              o = {};\n            function l(g, f) {\n              return !(!s[g.id][f] || !s[g.id][f].parentNode);\n            }\n            function d(g, f) {\n              s[g] && s[g][f] && s[g][f].parentNode && s[g][f].parentNode.removeChild(s[g][f]);\n            }\n            function c(g) {\n              var f,\n                y = g.$getTemplates();\n              return y.task_cell_class !== void 0 ? (f = y.task_cell_class, (console.warn || console.log)(\"gantt.templates.task_cell_class template is deprecated and will be removed soon. Please use gantt.templates.timeline_cell_class instead.\")) : f = y.timeline_cell_class, f;\n            }\n            function u(g) {\n              return g.$getTemplates().timeline_cell_content;\n            }\n            function h(g, f, y, v, b, _, m, p) {\n              var k = g.width[f],\n                x = \"\";\n              if (oe(f, g, v, r)) {\n                var $ = _(y, g.trace_x[f]),\n                  w = \"\";\n                if (m && (w = m(y, g.trace_x[f])), p.static_background) {\n                  var S = !(!$ && !w);\n                  if (!p.static_background_cells || !S) return null;\n                }\n                if (s[y.id][f]) return o[y.id][f] = f, s[y.id][f];\n                var T = document.createElement(\"div\");\n                return T.style.width = k + \"px\", x = \"gantt_task_cell\" + (f == b - 1 ? \" gantt_last_cell\" : \"\"), $ && (x += \" \" + $), T.className = x, w && (T.innerHTML = w), T.style.position = \"absolute\", T.style.left = g.left[f] + \"px\", s[y.id][f] = T, o[y.id][f] = f, T;\n              }\n              return null;\n            }\n            return {\n              render: function (g, f, y, v) {\n                var b = f.$getTemplates(),\n                  _ = f.getScale(),\n                  m = _.count;\n                if (y.static_background && !y.static_background_cells) return null;\n                var p,\n                  k = document.createElement(\"div\"),\n                  x = c(f),\n                  $ = u(f);\n                if (p = v && y.smart_rendering && !Nt(r) ? jt(_, v.x) : {\n                  start: 0,\n                  end: m - 1\n                }, y.show_task_cells) {\n                  s[g.id] = {}, o[g.id] = {};\n                  for (var w = p.start; w <= p.end; w++) {\n                    var S = h(_, w, g, v, m, x, $, y);\n                    S && k.appendChild(S);\n                  }\n                }\n                const T = f.$config.rowStore,\n                  E = T.getIndexById(g.id) % 2 != 0;\n                var C = b.task_row_class(g.start_date, g.end_date, g),\n                  D = \"gantt_task_row\" + (E ? \" odd\" : \"\") + (C ? \" \" + C : \"\");\n                if (T.isSelected(g.id) && (D += \" gantt_selected\"), k.className = D, y.smart_rendering ? (k.style.position = \"absolute\", k.style.top = f.getItemTop(g.id) + \"px\", k.style.width = \"100%\") : k.style.position = \"relative\", k.style.height = f.getItemHeight(g.id) + \"px\", g.id == \"timeline_placeholder_task\") {\n                  var M = 0;\n                  g.lastTaskId && (M = f.getItemTop(g.lastTaskId) + f.getItemHeight(g.lastTaskId));\n                  var A = (g.row_height || f.$task_data.offsetHeight) - M;\n                  A < 0 && (A = 0), y.smart_rendering && (k.style.top = M + \"px\"), k.style.height = A + \"px\";\n                }\n                return f.$config.item_attribute && (k.setAttribute(f.$config.item_attribute, g.id), k.setAttribute(f.$config.bind + \"_id\", g.id)), k;\n              },\n              update: function (g, f, y, v, b) {\n                var _ = y.getScale(),\n                  m = _.count,\n                  p = c(y),\n                  k = u(y);\n                if (v.show_task_cells) {\n                  s[g.id] || (s[g.id] = {}), o[g.id] || (o[g.id] = {});\n                  var x = jt(_, b);\n                  for (var $ in o[g.id]) {\n                    var w = o[g.id][$];\n                    (Number(w) < x.start || Number(w) > x.end) && d(g.id, w);\n                  }\n                  o[g.id] = {};\n                  for (var S = x.start; S <= x.end; S++) {\n                    var T = h(_, S, g, b, m, p, k, v);\n                    !T && l(g, S) ? d(g.id, S) : T && !T.parentNode && f.appendChild(T);\n                  }\n                }\n              },\n              getRectangle: Ye,\n              getVisibleRange: ft,\n              prepareData: La\n            };\n          }(t);\n        },\n        taskBar: function () {\n          return Ge(t);\n        },\n        timedProjectBar: function () {\n          return Ge(t);\n        },\n        taskRollupBar: function () {\n          return function (r) {\n            const s = xn(r),\n              o = {};\n            function l(u, h, g, f, y) {\n              let v = !0;\n              return f.smart_rendering && (v = $e(u, h, g)), v;\n            }\n            function d(u, h, g, f) {\n              const y = r.copy(r.getTask(h.id));\n              if (y.$rendered_at = u.id, r.callEvent(\"onBeforeRollupTaskDisplay\", [y.id, y, u.id]) === !1) return;\n              const v = s(y, g);\n              if (!v) return;\n              const b = g.getBarHeight(u.id, h.type == r.config.types.milestone),\n                _ = Math.floor((g.getItemHeight(u.id) - b) / 2);\n              return v.style.top = f.top + _ + \"px\", v.classList.add(\"gantt_rollup_child\"), v.setAttribute(\"data-rollup-parent-id\", u.id), v;\n            }\n            function c(u, h) {\n              return u + \"_\" + h;\n            }\n            return {\n              render: function (u, h, g, f) {\n                if (u.rollup !== !1 && u.$rollup && u.$rollup.length) {\n                  const y = document.createElement(\"div\"),\n                    v = r.getTaskPosition(u);\n                  return f && (f.y = 0, f.y_end = r.$task_bg.scrollHeight), u.$rollup.forEach(function (b) {\n                    if (!r.isTaskExists(b)) return;\n                    const _ = r.getTask(b);\n                    if (!l(_, f, h, g)) return;\n                    const m = d(u, _, h, v);\n                    m ? (o[c(_.id, u.id)] = m, y.appendChild(m)) : o[c(_.id, u.id)] = !1;\n                  }), y;\n                }\n                return !1;\n              },\n              update: function (u, h, g, f, y) {\n                const v = document.createElement(\"div\"),\n                  b = r.getTaskPosition(u);\n                y.y = 0, y.y_end = r.$task_bg.scrollHeight, u.$rollup.forEach(function (_) {\n                  const m = r.getTask(_),\n                    p = c(m.id, u.id);\n                  let k = l(m, y, g, f);\n                  if (k !== !!o[p]) if (k) {\n                    const x = d(u, m, g, b);\n                    o[p] = x || !1;\n                  } else o[p] = !1;\n                  o[p] && v.appendChild(o[p]), h.innerHTML = \"\", h.appendChild(v);\n                });\n              },\n              isInViewPort: $e,\n              getVisibleRange: ft\n            };\n          }(t);\n        },\n        taskSplitBar: function () {\n          return Ct();\n        },\n        taskConstraints: function () {\n          return Ct();\n        },\n        taskDeadline: function () {\n          return Ct();\n        },\n        taskBaselines: function () {\n          return Ct();\n        },\n        link: function () {\n          return Pa(t);\n        },\n        resourceRow: function () {\n          return function (r) {\n            var s = Ha(r),\n              o = {};\n            function l(c, u, h, g, f) {\n              var y = h.resource_cell_class(u.start_date, u.end_date, c, u.tasks, u.assignments),\n                v = h.resource_cell_value(u.start_date, u.end_date, c, u.tasks, u.assignments),\n                b = f.getItemHeight(c.id) - 1;\n              if (y || v) {\n                var _ = f.getItemPosition(c, u.start_date, u.end_date),\n                  m = document.createElement(\"div\");\n                return m.setAttribute(f.$config.item_attribute, c.id), m.className = [\"gantt_resource_marker\", y].join(\" \"), m.style.cssText = [\"left:\" + _.left + \"px\", \"width:\" + _.width + \"px\", \"height:\" + b + \"px\", \"line-height:\" + b + \"px\", \"top:\" + _.top + \"px\"].join(\";\"), v && (m.innerHTML = v), m;\n              }\n              return null;\n            }\n            function d(c, u) {\n              o[c] && o[c][u] && o[c][u].parentNode && o[c][u].parentNode.removeChild(o[c][u]);\n            }\n            return {\n              render: function (c, u, h, g) {\n                var f = u.$getTemplates(),\n                  y = u.getScale(),\n                  v = s(c, h.resource_property, u.getScale(), u),\n                  b = !!g,\n                  _ = [];\n                o[c.id] = {};\n                for (var m = jt(y, g), p = m.start; p <= m.end; p++) {\n                  var k = v[p];\n                  if (k && (!b || oe(p, y, g, r))) {\n                    var x = l(c, k, f, 0, u);\n                    x && (_.push(x), o[c.id][p] = x);\n                  }\n                }\n                var $ = null;\n                if (_.length) {\n                  $ = document.createElement(\"div\");\n                  for (var w = 0; w < _.length; w++) $.appendChild(_[w]);\n                }\n                return $;\n              },\n              update: function (c, u, h, g, f) {\n                var y = h.$getTemplates(),\n                  v = h.getScale(),\n                  b = s(c, g.resource_property, h.getScale(), h),\n                  _ = jt(v, f),\n                  m = {};\n                if (o && o[c.id]) for (var p in o[c.id]) m[p] = p;\n                for (var k = _.start; k <= _.end; k++) {\n                  var x = b[k];\n                  if (m[k] = !1, x) if (oe(k, v, f, r)) {\n                    if (o[c.id] && o[c.id][k]) o[c.id] && o[c.id][k] && !o[c.id][k].parentNode && u.appendChild(o[c.id][k]);else {\n                      var $ = l(c, x, y, 0, h);\n                      $ && (u.appendChild($), o[c.id][k] = $);\n                    }\n                  } else d(c.id, k);\n                }\n                for (var p in m) m[p] !== !1 && d(c.id, p);\n              },\n              getRectangle: Ye,\n              getVisibleRange: ft\n            };\n          }(t);\n        },\n        resourceHistogram: function () {\n          return Ct();\n        },\n        gridTaskRowResizer: function () {\n          return /* @__PURE__ */function (r) {\n            return {\n              render: function (s, o, l) {\n                var d = o.$getConfig(),\n                  c = document.createElement(\"div\");\n                return c.className = \"gantt_task_grid_row_resize_wrap\", c.style.top = o.getItemTop(s.id) + o.getItemHeight(s.id) + \"px\", c.innerHTML = \"<div class='gantt_task_grid_row_resize' role='cell'></div>\", c.setAttribute(d.task_grid_row_resizer_attribute, s.id), r._waiAria.rowResizerAttr(c), c;\n              },\n              update: null,\n              getRectangle: Kt,\n              getVisibleRange: ft\n            };\n          }(t);\n        }\n      },\n      layersService: {\n        getDataRender: function (r) {\n          return i.getDataRender(r, t);\n        },\n        createDataRender: function (r) {\n          return i.createDataRender(r, t);\n        }\n      }\n    };\n  }\n};\nfunction ce(t, e) {\n  const n = getComputedStyle(e.$root).getPropertyValue(\"--dhx-gantt-theme\");\n  let i,\n    a = !!n;\n  if (a) i = n;else {\n    var r = e.skin;\n    if (i = r, !r || t) for (var s = document.getElementsByTagName(\"link\"), o = 0; o < s.length; o++) {\n      var l = s[o].href.match(\"dhtmlxgantt_([a-z_]+).css\");\n      if (l && (e.skins[l[1]] || !r)) {\n        i = l[1];\n        break;\n      }\n    }\n  }\n  e._theme_info = {\n    theme: i,\n    cssVarTheme: a\n  }, e.skin = i || \"terrace\";\n  var d = e.skins[e.skin] || e.skins.terrace;\n  (function (h, g, f) {\n    for (var y in g) (h[y] === void 0 || f) && (h[y] = g[y]);\n  })(e.config, d.config, t), a || (e.config.link_radius = 1);\n  var c = e.getGridColumns();\n  for (c[1] && !e.defined(c[1].width) && (c[1].width = d._second_column_width), c[2] && !e.defined(c[2].width) && (c[2].width = d._third_column_width), o = 0; o < c.length; o++) {\n    var u = c[o];\n    u.name == \"add\" && (u.width || (u.width = 44), e.defined(u.min_width) && e.defined(u.max_width) || (u.min_width = u.min_width || u.width, u.max_width = u.max_width || u.width), u.min_width && (u.min_width = +u.min_width), u.max_width && (u.max_width = +u.max_width), u.width && (u.width = +u.width, u.width = u.min_width && u.min_width > u.width ? u.min_width : u.width, u.width = u.max_width && u.max_width < u.width ? u.max_width : u.width));\n  }\n  d.config.task_height && (e.config.task_height = d.config.task_height || \"full\"), d.config.bar_height && (e.config.bar_height = d.config.bar_height || \"full\"), d._lightbox_template && (e._lightbox_template = d._lightbox_template), d._redefine_lightbox_buttons && (e.config.buttons_right = d._redefine_lightbox_buttons.buttons_right, e.config.buttons_left = d._redefine_lightbox_buttons.buttons_left), e.resetLightbox();\n}\nfunction Ga(t) {\n  var e = 50,\n    n = 30,\n    i = 10,\n    a = 50,\n    r = null,\n    s = !1,\n    o = null,\n    l = {\n      started: !1\n    },\n    d = {};\n  function c(b) {\n    return b && Y(b, t.$root) && b.offsetHeight;\n  }\n  function u() {\n    var b = !!document.querySelector(\".gantt_drag_marker\"),\n      _ = !!document.querySelector(\".gantt_drag_marker.gantt_grid_resize_area\") || !!document.querySelector(\".gantt_drag_marker.gantt_row_grid_resize_area\"),\n      m = !!document.querySelector(\".gantt_link_direction\"),\n      p = t.getState(),\n      k = p.autoscroll;\n    return s = b && !_ && !m, !(!p.drag_mode && !b || _) || k;\n  }\n  function h(b) {\n    if (o && (clearTimeout(o), o = null), b) {\n      var _ = t.config.autoscroll_speed;\n      _ && _ < 10 && (_ = 10), o = setTimeout(function () {\n        r = setInterval(y, _ || a);\n      }, t.config.autoscroll_delay || i);\n    }\n  }\n  function g(b) {\n    b ? (h(!0), l.started || (l.x = d.x, l.y = d.y, l.started = !0)) : (r && (clearInterval(r), r = null), h(!1), l.started = !1);\n  }\n  function f(b) {\n    var _ = u();\n    if (!r && !o || _ || g(!1), !t.config.autoscroll || !_) return !1;\n    d = {\n      x: b.clientX,\n      y: b.clientY\n    }, b.type == \"touchmove\" && (d.x = b.targetTouches[0].clientX, d.y = b.targetTouches[0].clientY), !r && _ && g(!0);\n  }\n  function y() {\n    if (!u()) return g(!1), !1;\n    var b = c(t.$task) ? t.$task : c(t.$grid) ? t.$grid : t.$root;\n    if (b) {\n      var _ = !1;\n      [\".gantt_drag_marker.gantt_grid_resize_area\", \".gantt_drag_marker .gantt_row.gantt_row_task\", \".gantt_drag_marker.gantt_grid_dnd_marker\"].forEach(function (I) {\n        _ = _ || !!document.querySelector(I);\n      }), _ && (b = t.$grid);\n      var m = U(b),\n        p = d.x - m.x,\n        k = d.y - m.y + window.scrollY,\n        x = s ? 0 : v(p, m.width, l.x - m.x),\n        $ = v(k, m.height, l.y - m.y + window.scrollY),\n        w = t.getScrollState(),\n        S = w.y,\n        T = w.inner_height,\n        E = w.height,\n        C = w.x,\n        D = w.inner_width,\n        M = w.width;\n      ($ && !T || $ < 0 && !S || $ > 0 && S + T >= E + 2) && ($ = 0), (x && !D || x < 0 && !C || x > 0 && C + D >= M) && (x = 0);\n      var A = t.config.autoscroll_step;\n      A && A < 2 && (A = 2), $ *= A || n, ((x *= A || n) || $) && function (I, N) {\n        var P = t.getScrollState(),\n          O = null,\n          z = null;\n        I && (O = P.x + I, O = Math.min(P.width, O), O = Math.max(0, O)), N && (z = P.y + N, z = Math.min(P.height, z), z = Math.max(0, z)), t.scrollTo(O, z);\n      }(x, $);\n    }\n  }\n  function v(b, _, m) {\n    return b - e < 0 && b < m ? -1 : b > _ - e && b > m ? 1 : 0;\n  }\n  t.attachEvent(\"onGanttReady\", function () {\n    if (!V(t)) {\n      var b = vt(t.$root) || document.body;\n      t.eventRemove(b, \"mousemove\", f), t.event(b, \"mousemove\", f), t.eventRemove(b, \"touchmove\", f), t.event(b, \"touchmove\", f), t.eventRemove(b, \"pointermove\", f), t.event(b, \"pointermove\", f);\n    }\n  }), t.attachEvent(\"onDestroy\", function () {\n    g(!1);\n  });\n}\nvar ue, he;\nwindow.jQuery && (ue = window.jQuery, he = [], ue.fn.dhx_gantt = function (t) {\n  if (typeof (t = t || {}) != \"string\") {\n    var e = [];\n    return this.each(function () {\n      if (this && this.getAttribute) if (this.gantt || window.gantt.$root == this) e.push(typeof this.gantt == \"object\" ? this.gantt : window.gantt);else {\n        var n = window.gantt.$container && window.Gantt ? window.Gantt.getGanttInstance() : window.gantt;\n        for (var i in t) i != \"data\" && (n.config[i] = t[i]);\n        n.init(this), t.data && n.parse(t.data), e.push(n);\n      }\n    }), e.length === 1 ? e[0] : e;\n  }\n  if (he[t]) return he[t].apply(this, []);\n  ue.error(\"Method \" + t + \" does not exist on jQuery.dhx_gantt\");\n});\nconst Ya = null;\nwindow.dhtmlx && (window.dhtmlx.attaches || (window.dhtmlx.attaches = {}), window.dhtmlx.attaches.attachGantt = function (t, e, n) {\n  var i = document.createElement(\"DIV\");\n  n = n || window.gantt, i.id = \"gantt_\" + n.uid(), i.style.width = \"100%\", i.style.height = \"100%\", i.cmp = \"grid\", document.body.appendChild(i), this.attachObject(i.id), this.dataType = \"gantt\", this.dataObj = n;\n  var a = this.vs[this.av];\n  return a.grid = n, n.init(i.id, t, e), i.firstChild.style.border = \"none\", a.gridId = i.id, a.gridObj = i, this.vs[this._viewRestore()].grid;\n}), window.dhtmlXCellObject !== void 0 && (window.dhtmlXCellObject.prototype.attachGantt = function (t, e, n) {\n  n = n || window.gantt;\n  var i = document.createElement(\"DIV\");\n  return i.id = \"gantt_\" + n.uid(), i.style.width = \"100%\", i.style.height = \"100%\", i.cmp = \"grid\", document.body.appendChild(i), this.attachObject(i.id), this.dataType = \"gantt\", this.dataObj = n, n.init(i.id, t, e), i.firstChild.style.border = \"none\", i = null, this.callEvent(\"_onContentAttach\", []), this.dataObj;\n});\nconst Ja = null,\n  Ka = [\"ctrlKey\", \"altKey\", \"shiftKey\", \"metaKey\"],\n  Xa = [[{\n    unit: \"month\",\n    date: \"%M\",\n    step: 1\n  }, {\n    unit: \"day\",\n    date: \"%d\",\n    step: 1\n  }], [{\n    unit: \"day\",\n    date: \"%d %M\",\n    step: 1\n  }], [{\n    unit: \"day\",\n    date: \"%d %M\",\n    step: 1\n  }, {\n    unit: \"hour\",\n    date: \"%H:00\",\n    step: 8\n  }], [{\n    unit: \"day\",\n    date: \"%d %M\",\n    step: 1\n  }, {\n    unit: \"hour\",\n    date: \"%H:00\",\n    step: 1\n  }]];\nclass Za {\n  constructor(e) {\n    this.zoomIn = () => {\n      const n = this.getCurrentLevel() - 1;\n      n < 0 || this.setLevel(n);\n    }, this.zoomOut = () => {\n      const n = this.getCurrentLevel() + 1;\n      n > this._levels.length - 1 || this.setLevel(n);\n    }, this.getCurrentLevel = () => this._activeLevelIndex, this.getLevels = () => this._levels, this.setLevel = n => {\n      const i = this._getZoomIndexByName(n);\n      i === -1 && this.$gantt.assert(i !== -1, \"Invalid zoom level for gantt.ext.zoom.setLevel. \" + n + \" is not an expected value.\"), this._setLevel(i, 0);\n    }, this._getZoomIndexByName = n => {\n      let i = -1;\n      if (typeof n == \"string\") {\n        if (!isNaN(Number(n)) && this._levels[Number(n)]) i = Number(n);else for (let a = 0; a < this._levels.length; a++) if (this._levels[a].name === n) {\n          i = a;\n          break;\n        }\n      } else i = n;\n      return i;\n    }, this._getVisibleDate = () => {\n      if (!this.$gantt.$task) return null;\n      const n = this.$gantt.getScrollState().x,\n        i = this.$gantt.$task.offsetWidth;\n      this._visibleDate = this.$gantt.dateFromPos(n + i / 2);\n    }, this._setLevel = (n, i) => {\n      this._activeLevelIndex = n;\n      const a = this.$gantt,\n        r = a.copy(this._levels[this._activeLevelIndex]),\n        s = a.copy(r);\n      if (delete s.name, a.mixin(a.config, s, !0), [\"resourceTimeline\", \"resourceHistogram\"].forEach(function (o) {\n        const l = a.$ui.getView(o);\n        if (l) {\n          const d = l.$getConfig();\n          d.fixed_scales || a.mixin(d, s, !0);\n        }\n      }), a.$root && a.$task) {\n        if (i) {\n          const o = this.$gantt.dateFromPos(i + this.$gantt.getScrollState().x);\n          this.$gantt.render();\n          const l = this.$gantt.posFromDate(o);\n          this.$gantt.scrollTo(l - i);\n        } else {\n          const o = this.$gantt.$task.offsetWidth;\n          this._visibleDate || this._getVisibleDate();\n          const l = this._visibleDate;\n          this.$gantt.render();\n          const d = this.$gantt.posFromDate(l);\n          this.$gantt.scrollTo(d - o / 2);\n        }\n        this.callEvent(\"onAfterZoom\", [this._activeLevelIndex, r]);\n      }\n    }, this._attachWheelEvent = n => {\n      const i = mt.isFF ? \"wheel\" : \"mousewheel\";\n      let a;\n      a = typeof n.element == \"function\" ? n.element() : n.element, a && this._domEvents.attach(a, i, this.$gantt.bind(function (r) {\n        if (this._useKey && (Ka.indexOf(this._useKey) < 0 || !r[this._useKey])) return !1;\n        if (typeof this._handler == \"function\") return this._handler.apply(this, [r]), !0;\n      }, this), {\n        passive: !1\n      });\n    }, this._defaultHandler = n => {\n      const i = this.$gantt.$task.getBoundingClientRect().x,\n        a = n.clientX - i;\n      let r = !1;\n      (this.$gantt.env.isFF ? -40 * n.deltaY : n.wheelDelta) > 0 && (r = !0), n.preventDefault(), n.stopPropagation(), this._setScaleSettings(r, a);\n    }, this._setScaleDates = () => {\n      this._initialStartDate && this._initialEndDate && (this.$gantt.config.start_date = this._initialStartDate, this.$gantt.config.end_date = this._initialEndDate);\n    }, this.$gantt = e, this._domEvents = this.$gantt._createDomEventScope();\n  }\n  init(e) {\n    this.$gantt.env.isNode || (this._initialStartDate = e.startDate, this._initialEndDate = e.endDate, this._activeLevelIndex = e.activeLevelIndex ? e.activeLevelIndex : 0, this._levels = this._mapScales(e.levels || Xa), this._handler = e.handler || this._defaultHandler, this._minColumnWidth = e.minColumnWidth || 60, this._maxColumnWidth = e.maxColumnWidth || 240, this._widthStep = e.widthStep || 3 / 8 * e.minColumnWidth, this._useKey = e.useKey, this._initialized || (ot(this), this.$gantt.attachEvent(\"onGanttScroll\", () => {\n      this._getVisibleDate();\n    })), this._domEvents.detachAll(), e.trigger === \"wheel\" && (this.$gantt.$root ? this._attachWheelEvent(e) : this.$gantt.attachEvent(\"onGanttReady\", () => {\n      this._attachWheelEvent(e);\n    })), this._initialized = !0, this.setLevel(this._activeLevelIndex));\n  }\n  _mapScales(e) {\n    return e.map(n => Array.isArray(n) ? {\n      scales: n\n    } : n);\n  }\n  _setScaleSettings(e, n) {\n    e ? this._stepUp(n) : this._stepDown(n);\n  }\n  _stepUp(e) {\n    if (this._activeLevelIndex >= this._levels.length - 1) return;\n    let n = this._activeLevelIndex;\n    if (this._setScaleDates(), this._widthStep) {\n      let i = this.$gantt.config.min_column_width + this._widthStep;\n      i > this._maxColumnWidth && (i = this._minColumnWidth, n++), this.$gantt.config.min_column_width = i;\n    } else n++;\n    this._setLevel(n, e);\n  }\n  _stepDown(e) {\n    if (this._activeLevelIndex < 1) return;\n    let n = this._activeLevelIndex;\n    if (this._setScaleDates(), this._widthStep) {\n      let i = this.$gantt.config.min_column_width - this._widthStep;\n      i < this._minColumnWidth && (i = this._maxColumnWidth, n--), this.$gantt.config.min_column_width = i;\n    } else n--;\n    this._setLevel(n, e);\n  }\n}\nfunction Qa(t) {\n  function e() {\n    if (t.config.touch != \"force\" && (t.config.touch = t.config.touch && (navigator.userAgent.indexOf(\"Mobile\") != -1 || navigator.userAgent.indexOf(\"iPad\") != -1 || navigator.userAgent.indexOf(\"Android\") != -1 || navigator.userAgent.indexOf(\"Touch\") != -1) || navigator.platform === \"MacIntel\" && navigator.maxTouchPoints > 1), t.config.touch) {\n      var r = !0;\n      try {\n        document.createEvent(\"TouchEvent\");\n      } catch {\n        r = !1;\n      }\n      r ? t._touch_events([\"touchmove\", \"touchstart\", \"touchend\"], function (s) {\n        return s.touches && s.touches.length > 1 ? null : s.touches[0] ? {\n          target: s.target,\n          pageX: s.touches[0].pageX,\n          pageY: s.touches[0].pageY,\n          clientX: s.touches[0].clientX,\n          clientY: s.touches[0].clientY\n        } : s;\n      }, function () {\n        return !1;\n      }) : window.navigator.pointerEnabled ? t._touch_events([\"pointermove\", \"pointerdown\", \"pointerup\"], function (s) {\n        return s.pointerType == \"mouse\" ? null : s;\n      }, function (s) {\n        return !s || s.pointerType == \"mouse\";\n      }) : window.navigator.msPointerEnabled && t._touch_events([\"MSPointerMove\", \"MSPointerDown\", \"MSPointerUp\"], function (s) {\n        return s.pointerType == s.MSPOINTER_TYPE_MOUSE ? null : s;\n      }, function (s) {\n        return !s || s.pointerType == s.MSPOINTER_TYPE_MOUSE;\n      });\n    }\n  }\n  function n(r) {\n    var s = r.$config.scrollX ? t.$ui.getView(r.$config.scrollX) : null,\n      o = r.$config.scrollY ? t.$ui.getView(r.$config.scrollY) : null,\n      l = {\n        x: null,\n        y: null\n      };\n    return s && s.getScrollState().visible && (l.x = s.$view.scrollLeft), o && o.getScrollState().visible && (l.y = o.$view.scrollTop), l;\n  }\n  function i() {\n    var r;\n    return t.$ui.getView(\"timeline\") && (r = t.$ui.getView(\"timeline\")._tasks_dnd), r;\n  }\n  t.config.touch_drag = 75, t.config.touch = !0, t.config.touch_feedback = !0, t.config.touch_feedback_duration = 1, t._prevent_touch_scroll = !1, t._touch_feedback = function () {\n    t.config.touch_feedback && navigator.vibrate && navigator.vibrate(t.config.touch_feedback_duration);\n  }, t.attachEvent(\"onGanttReady\", function () {\n    t.$container && e();\n  }), t.attachEvent(\"onGanttLayoutReady\", function () {\n    t.$container && t.attachEvent(\"onGanttRender\", e, {\n      once: !0\n    });\n  });\n  var a = [];\n  t._touch_events = function (r, s, o) {\n    var l,\n      d = 0,\n      c = !1,\n      u = !1,\n      h = null,\n      g = null,\n      f = null,\n      y = [],\n      v = null;\n    let b = {};\n    for (var _ = 0; _ < a.length; _++) t.eventRemove(a[_][0], a[_][1], a[_][2]);\n    (a = []).push([t.$container, r[0], function (p) {\n      var k = i();\n      if (!o(p) && c) {\n        g && clearTimeout(g);\n        var x = s(p);\n        if (k && (k.drag.id || k.drag.start_drag)) return k.on_mouse_move(x), p.preventDefault && p.preventDefault(), p.cancelBubble = !0, !1;\n        if (!t._prevent_touch_scroll) {\n          if (x && h) {\n            var $ = h.pageX - x.pageX,\n              w = h.pageY - x.pageY;\n            if (!u && (Math.abs($) > 5 || Math.abs(w) > 5) && (u = !0, d = 0, l = v ? n(v) : t.getScrollState()), u) {\n              var S,\n                T = l.x + $,\n                E = l.y + w;\n              if (v ? (function (C, D, M) {\n                var A = C.$config.scrollX ? t.$ui.getView(C.$config.scrollX) : null,\n                  I = C.$config.scrollY ? t.$ui.getView(C.$config.scrollY) : null;\n                A && A.scrollTo(D, null), I && I.scrollTo(null, M);\n              }(v, T, E), S = n(v)) : (t.scrollTo(T, E), S = t.getScrollState()), l.x != S.x && w > 2 * $ || l.y != S.y && $ > 2 * w) return m(p);\n            }\n          }\n          return m(p);\n        }\n        return !0;\n      }\n    }]);\n    try {\n      document.addEventListener(\"touchmove\", function (p) {\n        t._touch_drag && m(p);\n      }, {\n        passive: !1\n      });\n    } catch {\n      console.warn(\"Cannot prevent touch event for the page drag\");\n    }\n    for (a.push([this.$container, \"contextmenu\", function (p) {\n      if (c) return m(p);\n    }]), a.push([this.$container, r[1], function (p) {\n      if (b = p.touches.length, document && document.body && document.body.classList.add(\"gantt_touch_active\"), !o(p)) if (p.touches && p.touches.length > 1) c = !1;else {\n        h = s(p), v = function (x) {\n          for (var $ = t.$layout.getCellsByType(\"viewCell\"), w = 0; w < $.length; w++) {\n            var S = $[w].$view.getBoundingClientRect();\n            if (x.clientX >= S.left && x.clientX <= S.right && x.clientY <= S.bottom && x.clientY >= S.top) return $[w];\n          }\n        }(h), t._locate_css(h, \"gantt_hor_scroll\") || t._locate_css(h, \"gantt_ver_scroll\") || (c = !0);\n        var k = i();\n        g = setTimeout(function () {\n          var x = t.locate(h);\n          k && x && !t._locate_css(h, \"gantt_link_control\") && !t._locate_css(h, \"gantt_grid_data\") && (k.on_mouse_down(h), k.drag && k.drag.start_drag && (function ($) {\n            const w = t._getTaskLayers();\n            let S = t.getTask($);\n            if (S) {\n              let T = t.isTaskVisible($);\n              if (T) {\n                f = $;\n                for (let E = 0; E < w.length; E++) if (S = w[E].rendered[$], S && S.getAttribute(t.config.task_attribute) && S.getAttribute(t.config.task_attribute) == $) {\n                  const C = S.cloneNode(!0);\n                  y.push(S), w[E].rendered[$] = C, S.style.display = \"none\", C.className += \" gantt_drag_move \", S.parentNode.appendChild(C);\n                }\n              } else if (S.$split_subtask) {\n                let E = S.$rendered_parent;\n                if (T = t.isTaskVisible(E), !T) return;\n                f = $;\n                for (let C = 0; C < w.length; C++) {\n                  const D = w[C].rendered[E];\n                  let M;\n                  if (D && D.childNodes && (M = D.querySelector(`[${t.config.task_attribute}=\"${S.id}\"]`)), M) {\n                    const A = M.cloneNode(!0);\n                    M.parentNode.appendChild(A), t.$task_bars.appendChild(M), M.style.display = \"none\", y.push(M), M = null;\n                  }\n                }\n              }\n            }\n          }(x), k._start_dnd(h), t._touch_drag = !0, t.refreshTask(x), t._touch_feedback())), g = null;\n        }, t.config.touch_drag);\n      }\n    }]), a.push([this.$container, r[2], function (p) {\n      if (document && document.body && document.body.classList.remove(\"gantt_touch_active\"), !o(p)) {\n        g && clearTimeout(g), t._touch_drag = !1, c = !1;\n        var k = s(p),\n          x = i();\n        if (x && x.on_mouse_up(k), f && t.isTaskExists(f) && (t.refreshTask(f), y.length && (y.forEach(function (w) {\n          w.parentNode && w.parentNode.removeChild(w);\n        }), t._touch_feedback())), c = u = !1, y = [], f = null, h && d) {\n          var $ = /* @__PURE__ */new Date();\n          $ - d < 500 && b <= 1 ? (t.$services.getService(\"mouseEvents\").onDoubleClick(h), m(p)) : d = $;\n        } else d = /* @__PURE__ */new Date();\n      }\n    }]), _ = 0; _ < a.length; _++) t.event(a[_][0], a[_][1], a[_][2]);\n    function m(p) {\n      return p && p.preventDefault && p.cancelable && p.preventDefault(), p.cancelBubble = !0, !1;\n    }\n  };\n}\nfunction Ft() {\n  console.log(\"Method is not implemented.\");\n}\nfunction Mt() {}\nfunction ht(t) {\n  return Mt;\n}\nMt.prototype.render = Ft, Mt.prototype.set_value = Ft, Mt.prototype.get_value = Ft, Mt.prototype.focus = Ft;\nvar wn = {\n  getHtmlSelect: function (t, e, n) {\n    var i = \"\",\n      a = this;\n    return kt(t = t || [], function (r) {\n      var s = [{\n        key: \"value\",\n        value: r.key\n      }];\n      n == r.key && (s[s.length] = {\n        key: \"selected\",\n        value: \"selected\"\n      }), r.attributes && (s = s.concat(r.attributes)), i += a.getHtmlOption({\n        innerHTML: r.label\n      }, s);\n    }), Dt(\"select\", {\n      innerHTML: i\n    }, e);\n  },\n  getHtmlOption: function (t, e) {\n    return Dt(\"option\", t, e);\n  },\n  getHtmlButton: function (t, e) {\n    return Dt(\"button\", t, e);\n  },\n  getHtmlDiv: function (t, e) {\n    return Dt(\"div\", t, e);\n  },\n  getHtmlLabel: function (t, e) {\n    return Dt(\"label\", t, e);\n  },\n  getHtmlInput: function (t) {\n    return \"<input\" + Sn(t || []) + \">\";\n  }\n};\nfunction Dt(t, e, n) {\n  return e = e || [], \"<\" + t + Sn(n || []) + \">\" + (e.innerHTML || \"\") + \"</\" + t + \">\";\n}\nfunction Sn(t) {\n  var e = \"\";\n  return kt(t, function (n) {\n    e += \" \" + n.key + \"='\" + n.value + \"'\";\n  }), e;\n}\nfunction qt(t) {\n  const e = ht();\n  function n() {\n    return e.apply(this, arguments) || this;\n  }\n  return W(n, e), n.prototype.render = function (i) {\n    const a = i.height ? `height:${i.height}px;` : \"\";\n    let r = `<div class='gantt_cal_ltext gantt_section_${i.name}' ${a ? `style='${a}'` : \"\"}>`;\n    return r += wn.getHtmlSelect(i.options, [{\n      key: \"style\",\n      value: \"width:100%;\"\n    }, {\n      key: \"title\",\n      value: i.name\n    }]), r += \"</div>\", r;\n  }, n.prototype.set_value = function (i, a, r, s) {\n    var o = i.firstChild;\n    !o._dhx_onchange && s.onchange && (o.onchange = s.onchange, o._dhx_onchange = !0), a === void 0 && (a = (o.options[0] || {}).value), o.value = a || \"\";\n  }, n.prototype.get_value = function (i) {\n    return i.firstChild.value;\n  }, n.prototype.focus = function (i) {\n    var a = i.firstChild;\n    t._focus(a, !0);\n  }, n;\n}\nfunction tr(t) {\n  var e = qt(t);\n  function n() {\n    return e.apply(this, arguments) || this;\n  }\n  function i(a, r) {\n    var s = [],\n      o = [];\n    r && (s = t.getTaskByTime(), a.allow_root && s.unshift({\n      id: t.config.root_id,\n      text: a.root_label || \"\"\n    }), s = function (u, h, g) {\n      var f = h.filter || function () {\n        return !0;\n      };\n      u = u.slice(0);\n      for (var y = 0; y < u.length; y++) {\n        var v = u[y];\n        (v.id == g || t.isChildOf(v.id, g) || f(v.id, v) === !1) && (u.splice(y, 1), y--);\n      }\n      return u;\n    }(s, a, r), a.sort && s.sort(a.sort));\n    for (var l = a.template || t.templates.task_text, d = 0; d < s.length; d++) {\n      var c = l.apply(t, [s[d].start_date, s[d].end_date, s[d]]);\n      c === void 0 && (c = \"\"), o.push({\n        key: s[d].id,\n        label: c\n      });\n    }\n    return a.options = o, a.map_to = a.map_to || \"parent\", t.form_blocks.select.render.apply(this, arguments);\n  }\n  return W(n, e), n.prototype.render = function (a) {\n    return i(a, !1);\n  }, n.prototype.set_value = function (a, r, s, o) {\n    r === 0 && (r = \"0\");\n    var l = document.createElement(\"div\");\n    l.innerHTML = i(o, s.id);\n    var d = l.removeChild(l.firstChild);\n    return a.onselect = null, a.parentNode.replaceChild(d, a), t.form_blocks.select.set_value.apply(t, [d, r, s, o]);\n  }, n;\n}\nfunction er(t) {\n  var e = function () {\n      const _ = ht();\n      function m() {\n        return _.apply(this, arguments) || this;\n      }\n      return W(m, _), m.prototype.render = function (p) {\n        let k = p.height ? `${p.height}px` : \"\";\n        return `<div class='gantt_cal_ltext gantt_cal_template gantt_section_${p.name}' ${k ? `style='height:${k};'` : \"\"}></div>`;\n      }, m.prototype.set_value = function (p, k) {\n        p.innerHTML = k || \"\";\n      }, m.prototype.get_value = function (p) {\n        return p.innerHTML || \"\";\n      }, m.prototype.focus = function () {}, m;\n    }(),\n    n = function (_) {\n      const m = ht();\n      function p() {\n        return m.apply(this, arguments) || this;\n      }\n      return W(p, m), p.prototype.render = function (k) {\n        const x = (k.height || \"130\") + \"px\",\n          $ = k.placeholder ? `placeholder='${k.placeholder}'` : \"\";\n        return `<div class='gantt_cal_ltext gantt_section_${k.name}' style='height:${x};' ${$}><textarea></textarea></div>`;\n      }, p.prototype.set_value = function (k, x) {\n        _.form_blocks.textarea._get_input(k).value = x || \"\";\n      }, p.prototype.get_value = function (k) {\n        return _.form_blocks.textarea._get_input(k).value;\n      }, p.prototype.focus = function (k) {\n        var x = _.form_blocks.textarea._get_input(k);\n        _._focus(x, !0);\n      }, p.prototype._get_input = function (k) {\n        return k.querySelector(\"textarea\");\n      }, p;\n    }(t),\n    i = function (_) {\n      const m = ht();\n      function p() {\n        return m.apply(this, arguments) || this;\n      }\n      return W(p, m), p.prototype.render = function (k) {\n        var x = _.form_blocks.getTimePicker.call(this, k);\n        let $ = \"gantt_section_time\";\n        k.name !== \"time\" && ($ += \" gantt_section_\" + k.name);\n        var w = \"<div style='padding-top:0px;font-size:inherit;text-align:center;' class='\" + $ + \"'>\";\n        return w += x, k.single_date ? (x = _.form_blocks.getTimePicker.call(this, k, !0), w += \"<span></span>\") : w += \"<span class='gantt_section_time_spacer'> &nbsp;&ndash;&nbsp; </span>\", (w += x) + \"</div>\";\n      }, p.prototype.set_value = function (k, x, $, w) {\n        var S = w,\n          T = k.getElementsByTagName(\"select\"),\n          E = w._time_format_order;\n        if (S.auto_end_date) for (var C = function () {\n            A = new Date(T[E[2]].value, T[E[1]].value, T[E[0]].value, 0, 0), I = _.calculateEndDate({\n              start_date: A,\n              duration: 1,\n              task: $\n            }), _.form_blocks._fill_lightbox_select(T, E.size, I, E, S);\n          }, D = 0; D < 4; D++) T[D].onchange = C;\n        var M = _._resolve_default_mapping(w);\n        typeof M == \"string\" && (M = {\n          start_date: M\n        });\n        var A = $[M.start_date] || /* @__PURE__ */new Date(),\n          I = $[M.end_date] || _.calculateEndDate({\n            start_date: A,\n            duration: 1,\n            task: $\n          });\n        _.form_blocks._fill_lightbox_select(T, 0, A, E, S), _.form_blocks._fill_lightbox_select(T, E.size, I, E, S);\n      }, p.prototype.get_value = function (k, x, $) {\n        var w,\n          S = k.getElementsByTagName(\"select\"),\n          T = $._time_format_order;\n        return w = _.form_blocks.getTimePickerValue(S, $), typeof _._resolve_default_mapping($) == \"string\" ? w : {\n          start_date: w,\n          end_date: function (E, C, D) {\n            var M = _.form_blocks.getTimePickerValue(E, $, C.size);\n            return M <= D && ($.autofix_end !== !1 || $.single_date) ? _.date.add(D, _._get_timepicker_step(), \"minute\") : M;\n          }(S, T, w)\n        };\n      }, p.prototype.focus = function (k) {\n        _._focus(k.getElementsByTagName(\"select\")[0]);\n      }, p;\n    }(t),\n    a = qt(t),\n    r = function (_) {\n      var m = ht();\n      function p() {\n        return m.apply(this, arguments) || this;\n      }\n      return W(p, m), p.prototype.render = function (k) {\n        const x = k.height ? `height:${k.height}px;` : \"\";\n        let $ = `<div class='gantt_cal_ltext gantt_cal_lcheckbox gantt_section_${k.name}' ${x ? `style='${x}'` : \"\"}>`;\n        if (k.options && k.options.length) for (var w = 0; w < k.options.length; w++) $ += \"<label><input type='checkbox' value='\" + k.options[w].key + \"' name='\" + k.name + \"'>\" + k.options[w].label + \"</label>\";else k.single_value = !0, $ += \"<label><input type='checkbox' name='\" + k.name + \"'></label>\";\n        return $ += \"</div>\", $;\n      }, p.prototype.set_value = function (k, x, $, w) {\n        var S = Array.prototype.slice.call(k.querySelectorAll(\"input[type=checkbox]\"));\n        !k._dhx_onchange && w.onchange && (k.onchange = w.onchange, k._dhx_onchange = !0), w.single_value ? S[0].checked = !!x : kt(S, function (T) {\n          T.checked = !!x && x.indexOf(T.value) >= 0;\n        });\n      }, p.prototype.get_value = function (k, x, $) {\n        return $.single_value ? k.querySelector(\"input[type=checkbox]\").checked : function (w, S) {\n          if (w.map) return w.map(S);\n          for (var T = w.slice(), E = [], C = 0; C < T.length; C++) E.push(S(T[C], C));\n          return E;\n        }(Array.prototype.slice.call(k.querySelectorAll(\"input[type=checkbox]:checked\")), function (w) {\n          return w.value;\n        });\n      }, p.prototype.focus = function (k) {\n        _._focus(k.querySelector(\"input[type=checkbox]\"));\n      }, p;\n    }(t),\n    s = function (_) {\n      const m = ht();\n      function p() {\n        return m.apply(this, arguments) || this;\n      }\n      return W(p, m), p.prototype.render = function (k) {\n        const x = k.height ? `${k.height}px` : \"\";\n        let $ = `<div class='gantt_cal_ltext gantt_cal_lradio gantt_section_${k.name}' ${x ? `style='height:${x};'` : \"\"}>`;\n        if (k.options && k.options.length) for (var w = 0; w < k.options.length; w++) $ += \"<label><input type='radio' value='\" + k.options[w].key + \"' name='\" + k.name + \"'>\" + k.options[w].label + \"</label>\";\n        return $ += \"</div>\", $;\n      }, p.prototype.set_value = function (k, x, $, w) {\n        var S;\n        w.options && w.options.length && (S = k.querySelector(\"input[type=radio][value='\" + x + \"']\") || k.querySelector(\"input[type=radio][value='\" + w.default_value + \"']\")) && (!k._dhx_onchange && w.onchange && (k.onchange = w.onchange, k._dhx_onchange = !0), S.checked = !0);\n      }, p.prototype.get_value = function (k, x) {\n        var $ = k.querySelector(\"input[type=radio]:checked\");\n        return $ ? $.value : \"\";\n      }, p.prototype.focus = function (k) {\n        _._focus(k.querySelector(\"input[type=radio]\"));\n      }, p;\n    }(t),\n    o = function (_) {\n      var m = ht();\n      function p() {\n        return m.apply(this, arguments) || this;\n      }\n      function k(w) {\n        return w.formatter || new Pt();\n      }\n      function x(w, S) {\n        var T = w.getElementsByTagName(\"select\"),\n          E = S._time_format_order,\n          C = 0,\n          D = 0;\n        if (_.defined(E[3])) {\n          var M = T[E[3]],\n            A = parseInt(M.value, 10);\n          isNaN(A) && M.hasAttribute(\"data-value\") && (A = parseInt(M.getAttribute(\"data-value\"), 10)), C = Math.floor(A / 60), D = A % 60;\n        }\n        return new Date(T[E[2]].value, T[E[1]].value, T[E[0]].value, C, D);\n      }\n      function $(w, S) {\n        var T = w.getElementsByTagName(\"input\")[1];\n        return (T = k(S).parse(T.value)) && !window.isNaN(T) || (T = 1), T < 0 && (T *= -1), T;\n      }\n      return W(p, m), p.prototype.render = function (w) {\n        var S = \"<div class='gantt_time_selects'>\" + _.form_blocks.getTimePicker.call(this, w) + \"</div>\",\n          T = \" \" + _.locale.labels[_.config.duration_unit + \"s\"] + \" \",\n          E = w.single_date ? \" style='display:none'\" : \"\",\n          C = w.readonly ? \" disabled='disabled'\" : \"\",\n          D = _._waiAria.lightboxDurationInputAttrString(w),\n          M = \"gantt_duration_value\";\n        w.formatter && (T = \"\", M += \" gantt_duration_value_formatted\");\n        var A = \"<div class='gantt_duration' \" + E + \"><div class='gantt_duration_inputs'><input type='button' class='gantt_duration_dec' value='−'\" + C + \"><input type='text' value='5days' class='\" + M + \"'\" + C + \" \" + D + \"><input type='button' class='gantt_duration_inc' value='+'\" + C + \"></div><div class='gantt_duration_end_date'>\" + T + \"<span></span></div></div></div>\";\n        let I = \"gantt_section_time gantt_section_duration\";\n        return w.name !== \"time\" && (I += \" gantt_section_\" + w.name), \"<div style='padding-top:0px;font-size:inherit;' class='\" + I + \"'>\" + S + \" \" + A + \"</div>\";\n      }, p.prototype.set_value = function (w, S, T, E) {\n        var C,\n          D,\n          M,\n          A,\n          I = w.getElementsByTagName(\"select\"),\n          N = w.getElementsByTagName(\"input\"),\n          P = N[1],\n          O = [N[0], N[2]],\n          z = w.getElementsByTagName(\"span\")[0],\n          F = E._time_format_order;\n        function H() {\n          var J = x.call(_, w, E),\n            B = $.call(_, w, E),\n            _t = _.calculateEndDate({\n              start_date: J,\n              duration: B,\n              task: T\n            }),\n            Tt = _.templates.task_end_date || _.templates.task_date;\n          z.innerHTML = Tt(_t);\n        }\n        function Q(J) {\n          var B = P.value;\n          B = k(E).parse(B), window.isNaN(B) && (B = 0), (B += J) < 1 && (B = 1), P.value = k(E).format(B), H();\n        }\n        O[0].onclick = _.bind(function () {\n          Q(-1 * _.config.duration_step);\n        }, this), O[1].onclick = _.bind(function () {\n          Q(1 * _.config.duration_step);\n        }, this), I[0].onchange = H, I[1].onchange = H, I[2].onchange = H, I[3] && (I[3].onchange = H), P.onkeydown = _.bind(function (J) {\n          var B;\n          return (B = (J = J || window.event).charCode || J.keyCode || J.which) == _.constants.KEY_CODES.DOWN ? (Q(-1 * _.config.duration_step), !1) : B == _.constants.KEY_CODES.UP ? (Q(1 * _.config.duration_step), !1) : void window.setTimeout(H, 1);\n        }, this), P.onchange = _.bind(H, this), typeof (C = _._resolve_default_mapping(E)) == \"string\" && (C = {\n          start_date: C\n        }), D = T[C.start_date] || /* @__PURE__ */new Date(), M = T[C.end_date] || _.calculateEndDate({\n          start_date: D,\n          duration: 1,\n          task: T\n        }), A = Math.round(T[C.duration]) || _.calculateDuration({\n          start_date: D,\n          end_date: M,\n          task: T\n        }), A = k(E).format(A), _.form_blocks._fill_lightbox_select(I, 0, D, F, E), P.value = A, H();\n      }, p.prototype.get_value = function (w, S, T) {\n        var E = x(w, T),\n          C = $(w, T),\n          D = _.calculateEndDate({\n            start_date: E,\n            duration: C,\n            task: S\n          });\n        return typeof _._resolve_default_mapping(T) == \"string\" ? E : {\n          start_date: E,\n          end_date: D,\n          duration: C\n        };\n      }, p.prototype.focus = function (w) {\n        _._focus(w.getElementsByTagName(\"select\")[0]);\n      }, p;\n    }(t),\n    l = tr(t),\n    d = qt(t),\n    c = function (_) {\n      var m = ht();\n      function p() {\n        return m.apply(this, arguments) || this;\n      }\n      function k($) {\n        return !$ || $ === _.config.constraint_types.ASAP || $ === _.config.constraint_types.ALAP;\n      }\n      function x($, w) {\n        for (var S = k(w), T = 0; T < $.length; T++) $[T].disabled = S;\n      }\n      return W(p, m), p.prototype.render = function ($) {\n        const w = $.height ? `height:${$.height}px;` : \"\";\n        let S = `<div class='gantt_cal_ltext gantt_section_${$.name}' ${w ? `style='${w}'` : \"\"}>`;\n        var T = [];\n        for (var E in _.config.constraint_types) T.push({\n          key: _.config.constraint_types[E],\n          label: _.locale.labels[_.config.constraint_types[E]]\n        });\n        return $.options = $.options || T, S += \"<span data-constraint-type-select>\" + wn.getHtmlSelect($.options, [{\n          key: \"data-type\",\n          value: \"constraint-type\"\n        }]) + \"</span>\", S += \"<label data-constraint-time-select>\" + (_.locale.labels.constraint_date || \"Constraint date\") + \": \" + _.form_blocks.getTimePicker.call(this, $) + \"</label>\", S += \"</div>\", S;\n      }, p.prototype.set_value = function ($, w, S, T) {\n        var E = $.querySelector(\"[data-constraint-type-select] select\"),\n          C = $.querySelectorAll(\"[data-constraint-time-select] select\"),\n          D = T._time_format_order,\n          M = _._resolve_default_mapping(T);\n        E._eventsInitialized || (E.addEventListener(\"change\", function (N) {\n          x(C, N.target.value);\n        }), E._eventsInitialized = !0);\n        var A = S[M.constraint_date] || /* @__PURE__ */new Date();\n        _.form_blocks._fill_lightbox_select(C, 0, A, D, T);\n        var I = S[M.constraint_type] || _.getConstraintType(S);\n        E.value = I, x(C, I);\n      }, p.prototype.get_value = function ($, w, S) {\n        var T = $.querySelector(\"[data-constraint-type-select] select\"),\n          E = $.querySelectorAll(\"[data-constraint-time-select] select\"),\n          C = T.value,\n          D = null;\n        return k(C) || (D = _.form_blocks.getTimePickerValue(E, S)), {\n          constraint_type: C,\n          constraint_date: D\n        };\n      }, p.prototype.focus = function ($) {\n        _._focus($.querySelector(\"select\"));\n      }, p;\n    }(t),\n    u = function (_) {\n      const m = qt(_);\n      function p() {\n        return m.apply(this, arguments) || this;\n      }\n      return W(p, m), p.prototype.render = function (k) {\n        var x = _.config.types,\n          $ = _.locale.labels,\n          w = [],\n          S = k.filter || function (C, D) {\n            return !x.placeholder || D !== x.placeholder;\n          };\n        for (var T in x) !S(T, x[T]) == 0 && w.push({\n          key: x[T],\n          label: $[\"type_\" + T]\n        });\n        k.options = w;\n        var E = k.onchange;\n        return k.onchange = function () {\n          _._lightbox_current_type = this.value, _.changeLightboxType(this.value), typeof E == \"function\" && E.apply(this, arguments);\n        }, m.prototype.render.apply(this, arguments);\n      }, p;\n    }(t),\n    h = function (_) {\n      var m = ht();\n      function p() {\n        return m.apply(this, arguments) || this;\n      }\n      function k(S) {\n        return S.formatter || new Pt();\n      }\n      function x(S, T, E, C) {\n        const D = \"<div class='gantt_time_selects'>\" + _.form_blocks.getTimePicker.call(_, C) + \"</div>\";\n        let M = \" \" + _.locale.labels[_.config.duration_unit + \"s\"] + \" \";\n        const A = C.single_date ? \" style='display:none'\" : \"\",\n          I = C.readonly ? \" disabled='disabled'\" : \"\",\n          N = _._waiAria.lightboxDurationInputAttrString(C),\n          P = _.locale.labels.baselines_remove_button;\n        let O = \"gantt_duration_value\";\n        C.formatter && (M = \"\", O += \" gantt_duration_value_formatted\");\n        const z = \"<div class='gantt_duration' \" + A + \"><div class='gantt_duration_inputs'><input type='button' class='gantt_duration_dec' value='−'\" + I + \"><input type='text' value='5days' class='\" + O + \"'\" + I + \" \" + N + \"><input type='button' class='gantt_duration_inc' value='+'\" + I + \"></div><div class='gantt_duration_end_date'>\" + M + \"<span></span></div></div></div>\",\n          F = `<div><div class='baseline_delete_button gantt_custom_button'>${P}</div></div>`,\n          H = document.createElement(\"div\");\n        H.className = \"gantt_section_time gantt_section_duration\", H.setAttribute(\"data-baseline-id\", T.id), H.innerHTML = D + z + F + \"<br>\", S.appendChild(H);\n        var Q,\n          J,\n          B,\n          _t = H.getElementsByTagName(\"select\"),\n          Tt = H.getElementsByTagName(\"input\"),\n          Et = Tt[1],\n          Ee = [Tt[0], Tt[2]],\n          Tn = H.getElementsByTagName(\"span\")[0],\n          En = C._time_format_order;\n        function gt() {\n          var ut = $.call(_, H, C),\n            q = w.call(_, H, C),\n            Cn = _.calculateEndDate({\n              start_date: ut,\n              duration: q,\n              task: E\n            }),\n            Dn = _.templates.task_end_date || _.templates.task_date;\n          Tn.innerHTML = Dn(Cn);\n        }\n        function Ot(ut) {\n          var q = Et.value;\n          q = k(C).parse(q), window.isNaN(q) && (q = 0), (q += ut) < 1 && (q = 1), Et.value = k(C).format(q), gt();\n        }\n        H.querySelector(\".baseline_delete_button\").onclick = function (ut) {\n          const q = H.parentNode;\n          H.innerHTML = \"\", H.remove(), q.innerHTML === \"\" && (q.innerHTML = _.locale.labels.baselines_section_placeholder);\n        }, Ee[0].onclick = _.bind(function () {\n          Ot(-1 * _.config.duration_step);\n        }, _), Ee[1].onclick = _.bind(function () {\n          Ot(1 * _.config.duration_step);\n        }, _), _t[0].onchange = gt, _t[1].onchange = gt, _t[2].onchange = gt, _t[3] && (_t[3].onchange = gt), Et.onkeydown = _.bind(function (ut) {\n          var q;\n          return (q = (ut = ut || window.event).charCode || ut.keyCode || ut.which) == _.constants.KEY_CODES.DOWN ? (Ot(-1 * _.config.duration_step), !1) : q == _.constants.KEY_CODES.UP ? (Ot(1 * _.config.duration_step), !1) : void window.setTimeout(gt, 1);\n        }, _), Et.onchange = _.bind(gt, _), _._resolve_default_mapping(C), Q = T.start_date || /* @__PURE__ */new Date(), J = T.end_date || _.calculateEndDate({\n          start_date: Q,\n          duration: 1,\n          task: E\n        }), B = _.calculateDuration({\n          start_date: Q,\n          end_date: J,\n          task: E\n        }), B = k(C).format(B), _.form_blocks._fill_lightbox_select(_t, 0, Q, En, C), Et.value = B, gt();\n      }\n      function $(S, T) {\n        var E = S.getElementsByTagName(\"select\"),\n          C = T._time_format_order,\n          D = 0,\n          M = 0;\n        if (_.defined(C[3])) {\n          var A = E[C[3]],\n            I = parseInt(A.value, 10);\n          isNaN(I) && A.hasAttribute(\"data-value\") && (I = parseInt(A.getAttribute(\"data-value\"), 10)), D = Math.floor(I / 60), M = I % 60;\n        }\n        return new Date(E[C[2]].value, E[C[1]].value, E[C[0]].value, D, M);\n      }\n      function w(S, T) {\n        var E = S.getElementsByTagName(\"input\")[1];\n        return (E = k(T).parse(E.value)) && !window.isNaN(E) || (E = 1), E < 0 && (E *= -1), E;\n      }\n      return W(p, m), p.prototype.render = function (S) {\n        return `<div style='height: ${S.height || 100}px; padding-top:0px; font-size:inherit;' class='gantt_section_baselines'></div>`;\n      }, p.prototype.set_value = function (S, T, E, C) {\n        E.baselines ? (S.innerHTML = \"\", E.baselines.forEach(D => {\n          x(S, D, E, C);\n        })) : S.innerHTML = _.locale.labels.baselines_section_placeholder;\n      }, p.prototype.get_value = function (S, T, E) {\n        const C = [];\n        return S.querySelectorAll(\"[data-baseline-id]\").forEach(D => {\n          const M = D.dataset.baselineId;\n          let A,\n            I = _.getDatastore(\"baselines\").getItem(M);\n          A = I ? _.copy(I) : {\n            id: _.uid(),\n            task_id: T.id,\n            text: \"Baseline 1\"\n          }, A.start_date = $(D, E), A.duration = w(D, E), A.end_date = _.calculateEndDate({\n            start_date: A.start_date,\n            duration: A.duration,\n            task: T\n          }), C.push(A);\n        }), C;\n      }, p.prototype.button_click = function (S, T, E, C) {\n        if (_.callEvent(\"onSectionButton\", [_._lightbox_id, E]) !== !1 && (T.closest(\".gantt_custom_button.gantt_remove_baselines\") && (C.innerHTML = _.locale.labels.baselines_section_placeholder), T.closest(\".gantt_custom_button.gantt_add_baselines\"))) {\n          C.innerHTML == _.locale.labels.baselines_section_placeholder && (C.innerHTML = \"\");\n          const D = _.getTask(_._lightbox_id);\n          x(C, {\n            id: _.uid(),\n            task_id: D.id,\n            text: \"Baseline 1\",\n            start_date: D.start_date,\n            end_date: D.end_date\n          }, D, _._get_typed_lightbox_config()[S]);\n        }\n      }, p.prototype.focus = function (S) {\n        _._focus(S.getElementsByTagName(\"select\")[0]);\n      }, p;\n    }(t);\n  t._lightbox_methods = {}, t._lightbox_template = \"<div class='gantt_cal_ltitle'><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='gantt_title'></span></div><div class='gantt_cal_larea'></div>\", t._lightbox_template = `<div class='gantt_cal_ltitle'><div class=\"dhx_cal_ltitle_descr\"><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='dhx_title'></span>\n</div>\n<div class=\"gantt_cal_ltitle_controls\">\n\t<a class=\"gantt_cal_ltitle_close_btn dhx_gantt_icon dhx_gantt_icon_close\"></a>\n\n</div></div><div class='gantt_cal_larea'></div>`, t._lightbox_root = t.$root, t.$services.getService(\"state\").registerProvider(\"lightbox\", function () {\n    return {\n      lightbox: t._lightbox_id\n    };\n  }), t.showLightbox = function (_) {\n    var m = this.getTask(_);\n    if (this.callEvent(\"onBeforeLightbox\", [_])) {\n      var p = this.getLightbox(this.getTaskType(m.type));\n      this.showCover(p), this._fill_lightbox(_, p), this._setLbPosition(p), this._waiAria.lightboxVisibleAttr(p), this.callEvent(\"onLightbox\", [_]);\n    } else t.isTaskExists(_) && t.getTask(_).$new && this.$data.tasksStore._updateOrder();\n  }, t._get_timepicker_step = function () {\n    if (this.config.round_dnd_dates) {\n      var _;\n      if (function (p) {\n        var k = p.$ui.getView(\"timeline\");\n        return !(!k || !k.isVisible());\n      }(this)) {\n        var m = t.getScale();\n        _ = Vt(m.unit) * m.step / 60;\n      }\n      return (!_ || _ >= 1440) && (_ = this.config.time_step), _;\n    }\n    return this.config.time_step;\n  }, t.getLabel = function (_, m) {\n    for (var p = this._get_typed_lightbox_config(), k = 0; k < p.length; k++) if (p[k].map_to == _) {\n      for (var x = p[k].options, $ = 0; $ < x.length; $++) if (x[$].key == m) return x[$].label;\n    }\n    return \"\";\n  }, t.updateCollection = function (_, m) {\n    m = m.slice(0);\n    var p = t.serverList(_);\n    if (!p) return !1;\n    p.splice(0, p.length), p.push.apply(p, m || []), t.resetLightbox();\n  }, t.getLightboxType = function () {\n    return this.getTaskType(this._lightbox_type);\n  }, t.getLightbox = function (_) {\n    var m,\n      p,\n      k,\n      x,\n      $,\n      w = \"\";\n    if (function () {\n      const T = t.config.csp === !0,\n        E = !!window.Sfdc || !!window.$A || window.Aura || \"$shadowResolver$\" in document.body;\n      t._lightbox_root = T || E ? t.$root : document.body;\n    }(), _ === void 0 && (_ = this.getLightboxType()), !this._lightbox || this.getLightboxType() != this.getTaskType(_)) {\n      this._lightbox_type = this.getTaskType(_), m = document.createElement(\"div\"), w = \"gantt_cal_light\", p = this._is_lightbox_timepicker(), t.config.wide_form && (w += \" gantt_cal_light_wide\"), p && (w += \" gantt_cal_light_full\"), m.className = w, m.style.visibility = \"hidden\", k = this._lightbox_template, k += \"<div class='gantt_cal_lcontrols'>\", k += y(this.config.buttons_left), k += \"<div class='gantt_cal_lcontrols_push_right'></div>\", k += y(this.config.buttons_right), k += \"</div>\", m.innerHTML = k, t._waiAria.lightboxAttr(m), t.config.drag_lightbox && (m.firstChild.onmousedown = t._ready_to_dnd, m.firstChild.ontouchstart = function (T) {\n        t._ready_to_dnd(T.touches[0]);\n      }, m.firstChild.onselectstart = function () {\n        return !1;\n      }, m.firstChild.style.cursor = \"pointer\", t._init_dnd_events()), this._lightbox && this.resetLightbox(), g(), this._cover.insertBefore(m, this._cover.firstChild), this._lightbox = m, x = this._get_typed_lightbox_config(_), k = this._render_sections(x);\n      var S = ($ = m.querySelector(\"div.gantt_cal_larea\")).style.overflow;\n      $.style.overflow = \"hidden\", $.innerHTML = k, function (T) {\n        var E, C, D, M, A, I;\n        for (I = 0; I < T.length; I++) E = T[I], D = t._lightbox_root.querySelector(\"#\" + E.id), E.id && D && (C = D.querySelector(\"label\"), (M = D.nextSibling) && (A = M.querySelector(\"input, select, textarea\")) && (A.id = A.id || \"input_\" + t.uid(), E.inputId = A.id, C.setAttribute(\"for\", E.inputId)));\n      }(x), $.style.overflow = S, this._init_lightbox_events(this), m.style.display = \"none\", m.style.visibility = \"visible\";\n    }\n    return this._lightbox;\n  }, t._render_sections = function (_) {\n    for (var m = \"\", p = 0; p < _.length; p++) {\n      var k = this.form_blocks[_[p].type];\n      if (k) {\n        _[p].id = \"area_\" + this.uid();\n        var x = _[p].hidden ? \" style='display:none'\" : \"\",\n          $ = \"\";\n        _[p].button && ($ = \"<div class='gantt_custom_button' data-index='\" + p + \"'><div class='gantt_custom_button_\" + _[p].button + \"'></div><div class='gantt_custom_button_label'>\" + this.locale.labels[\"button_\" + _[p].button] + \"</div></div>\"), _[p].type == \"baselines\" && ($ = \"<div class='gantt_custom_button gantt_remove_baselines' data-index='\" + p + \"'><div class='gantt_custom_button_delete_baselines'></div><div class='gantt_custom_button_label'>\" + this.locale.labels.baselines_remove_all_button + \"</div></div><div class='gantt_custom_button gantt_add_baselines' data-index='\" + p + \"'><div class='gantt_custom_button_add_baseline'></div><div class='gantt_custom_button_label'>\" + this.locale.labels.baselines_add_button + \"</div></div>\"), this.config.wide_form && (m += \"<div class='gantt_wrap_section' \" + x + \">\"), m += \"<div id='\" + _[p].id + \"' class='gantt_cal_lsection'><label>\" + $ + this.locale.labels[\"section_\" + _[p].name] + \"</label></div>\" + k.render.call(this, _[p]), m += \"</div>\";\n      }\n    }\n    return m;\n  }, t._center_lightbox = function (_) {\n    t._setLbPosition(_);\n  }, t._setLbPosition = function (_) {\n    if (!_) return;\n    const m = t._lightbox_root || t.$root;\n    _.style.top = Math.max(m.offsetHeight / 2 - _.offsetHeight / 2, 0) + \"px\", _.style.left = Math.max(m.offsetWidth / 2 - _.offsetWidth / 2, 0) + \"px\";\n  }, t.showCover = function (_) {\n    _ && (_.style.display = \"block\", this._setLbPosition(_)), g(), this._cover.style.display = \"\";\n  };\n  const g = function () {\n    t._cover || (t._cover = document.createElement(\"div\"), t._cover.className = \"gantt_cal_cover\", t._cover.style.display = \"none\", t.event(t._cover, \"mousemove\", t._move_while_dnd), t.event(t._cover, \"mouseup\", t._finish_dnd), (t._lightbox_root || t.$root).appendChild(t._cover));\n  };\n  function f(_) {\n    for (var m in this.config.types) if (this.config.types[m] == _) return m;\n    return \"task\";\n  }\n  function y(_, m) {\n    var p,\n      k,\n      x = \"\";\n    for (k = 0; k < _.length; k++) p = t.config._migrate_buttons[_[k]] ? t.config._migrate_buttons[_[k]] : _[k], x += \"<div \" + t._waiAria.lightboxButtonAttrString(p) + \" class='gantt_btn_set gantt_left_btn_set \" + p + \"_set'><div dhx_button='1' data-dhx-button='1' class='\" + p + \"'></div><div>\" + t.locale.labels[p] + \"</div></div>\";\n    return x;\n  }\n  function v(_) {\n    var m, p;\n    return _.time_format ? _.time_format : (p = [\"%d\", \"%m\", \"%Y\"], Vt((m = t.getScale()) ? m.unit : t.config.duration_unit) < Vt(\"day\") && p.push(\"%H:%i\"), p);\n  }\n  function b(_, m, p) {\n    var k,\n      x,\n      $,\n      w,\n      S,\n      T,\n      E = \"\";\n    switch (p.timeFormat[m]) {\n      case \"%Y\":\n        for (_._time_format_order[2] = m, _._time_format_order.size++, _.year_range && (isNaN(_.year_range) ? _.year_range.push && ($ = _.year_range[0], w = _.year_range[1]) : k = _.year_range), k = k || 10, x = x || Math.floor(k / 2), $ = $ || p.date.getFullYear() - x, w = w || t.getState().max_date.getFullYear() + x, S = $; S <= w; S++) E += \"<option value='\" + S + \"'>\" + S + \"</option>\";\n        break;\n      case \"%m\":\n        for (_._time_format_order[1] = m, _._time_format_order.size++, S = 0; S < 12; S++) E += \"<option value='\" + S + \"'>\" + t.locale.date.month_full[S] + \"</option>\";\n        break;\n      case \"%d\":\n        for (_._time_format_order[0] = m, _._time_format_order.size++, S = 1; S < 32; S++) E += \"<option value='\" + S + \"'>\" + S + \"</option>\";\n        break;\n      case \"%H:%i\":\n        for (_._time_format_order[3] = m, _._time_format_order.size++, S = p.first, T = p.date.getDate(), _._time_values = []; S < p.last;) E += \"<option value='\" + S + \"'>\" + t.templates.time_picker(p.date) + \"</option>\", _._time_values.push(S), p.date.setTime(p.date.valueOf() + 60 * t._get_timepicker_step() * 1e3), S = 24 * (p.date.getDate() != T ? 1 : 0) * 60 + 60 * p.date.getHours() + p.date.getMinutes();\n    }\n    return E;\n  }\n  t._init_lightbox_events = function () {\n    t.lightbox_events = {}, t.lightbox_events.gantt_save_btn = function () {\n      t._save_lightbox();\n    }, t.lightbox_events.gantt_delete_btn = function () {\n      t._lightbox_current_type = null, t.callEvent(\"onLightboxDelete\", [t._lightbox_id]) && (t.isTaskExists(t._lightbox_id) ? t.$click.buttons.delete(t._lightbox_id) : t.hideLightbox());\n    }, t.lightbox_events.gantt_cancel_btn = function () {\n      t._cancel_lightbox();\n    }, t.lightbox_events.default = function (_, m) {\n      if (m.getAttribute(\"data-dhx-button\")) t.callEvent(\"onLightboxButton\", [m.className, m, _]);else {\n        var p,\n          k,\n          x = X(m);\n        if (x.indexOf(\"gantt_custom_button\") != -1) if (x.indexOf(\"gantt_custom_button_\") != -1) for (p = m.parentNode.getAttribute(\"data-index\"), k = m; k && X(k).indexOf(\"gantt_cal_lsection\") == -1;) k = k.parentNode;else p = m.getAttribute(\"data-index\"), k = m.closest(\".gantt_cal_lsection\"), m = m.firstChild;\n        var $ = t._get_typed_lightbox_config();\n        p && (p *= 1, t.form_blocks[$[1 * p].type].button_click(p, m, k, k.nextSibling));\n      }\n    }, this.event(t.getLightbox(), \"click\", function (_) {\n      _.target.closest(\".gantt_cal_ltitle_close_btn\") && t._cancel_lightbox();\n      var m = yt(_),\n        p = X(m);\n      return p || (p = X(m = m.previousSibling)), m && p && p.indexOf(\"gantt_btn_set\") === 0 && (p = X(m = m.firstChild)), !(!m || !p) && (t.defined(t.lightbox_events[m.className]) ? t.lightbox_events[m.className] : t.lightbox_events.default)(_, m);\n    }), t.getLightbox().onkeydown = function (_) {\n      var m = _ || window.event,\n        p = _.target || _.srcElement,\n        k = X(p).indexOf(\"gantt_btn_set\") > -1;\n      switch ((_ || m).keyCode) {\n        case t.constants.KEY_CODES.SPACE:\n          if ((_ || m).shiftKey) return;\n          k && p.click && p.click();\n          break;\n        case t.keys.edit_save:\n          if ((_ || m).shiftKey) return;\n          k && p.click ? p.click() : t._save_lightbox();\n          break;\n        case t.keys.edit_cancel:\n          t._cancel_lightbox();\n      }\n    };\n  }, t._cancel_lightbox = function () {\n    var _ = this.getLightboxValues();\n    t._lightbox_current_type = null, this.callEvent(\"onLightboxCancel\", [this._lightbox_id, _.$new]), t.isTaskExists(_.id) && _.$new && (this.silent(function () {\n      t.$data.tasksStore.removeItem(_.id), t._update_flags(_.id, null);\n    }), this.refreshData()), this.hideLightbox();\n  }, t._save_lightbox = function () {\n    var _ = this.getLightboxValues();\n    t._lightbox_current_type = null, this.callEvent(\"onLightboxSave\", [this._lightbox_id, _, !!_.$new]) && (t.$data.tasksStore._skipTaskRecalculation = \"lightbox\", _.$new ? (delete _.$new, this.addTask(_, _.parent, this.getTaskIndex(_.id))) : this.isTaskExists(_.id) && (this.mixin(this.getTask(_.id), _, !0), this.refreshTask(_.id), this.updateTask(_.id)), t.$data.tasksStore._skipTaskRecalculation = !1, this.refreshData(), this.hideLightbox());\n  }, t._resolve_default_mapping = function (_) {\n    var m = _.map_to;\n    return {\n      time: !0,\n      time_optional: !0,\n      duration: !0,\n      duration_optional: !0\n    }[_.type] ? _.map_to == \"auto\" ? m = {\n      start_date: \"start_date\",\n      end_date: \"end_date\",\n      duration: \"duration\"\n    } : typeof _.map_to == \"string\" && (m = {\n      start_date: _.map_to\n    }) : _.type === \"constraint\" && (_.map_to && typeof _.map_to != \"string\" || (m = {\n      constraint_type: \"constraint_type\",\n      constraint_date: \"constraint_date\"\n    })), m;\n  }, t.getLightboxValues = function () {\n    var _ = {};\n    t.isTaskExists(this._lightbox_id) && (_ = this.mixin({}, this.getTask(this._lightbox_id)));\n    for (var m = this._get_typed_lightbox_config(), p = 0; p < m.length; p++) {\n      var k = t._lightbox_root.querySelector(\"#\" + m[p].id);\n      k = k && k.nextSibling;\n      var x = this.form_blocks[m[p].type];\n      if (x) {\n        var $ = x.get_value.call(this, k, _, m[p]),\n          w = t._resolve_default_mapping(m[p]);\n        if (typeof w == \"string\" && w != \"auto\") _[w] = $;else if (typeof w == \"object\") for (var S in w) w[S] && (_[w[S]] = $[S]);\n      }\n    }\n    return t._lightbox_current_type && (_.type = t._lightbox_current_type), _;\n  }, t.hideLightbox = function () {\n    var _ = this.getLightbox();\n    _ && (_.style.display = \"none\"), this._waiAria.lightboxHiddenAttr(_), this._lightbox_id = null, this.hideCover(_), this.resetLightbox(), this.callEvent(\"onAfterLightbox\", []);\n  }, t.hideCover = function (_) {\n    _ && (_.style.display = \"none\"), this._cover && this._cover.parentNode.removeChild(this._cover), this._cover = null;\n  }, t.resetLightbox = function () {\n    t._lightbox && !t._custom_lightbox && t._lightbox.remove(), t._lightbox = null;\n  }, t._set_lightbox_values = function (_, m) {\n    var p = _,\n      k = m.getElementsByTagName(\"span\"),\n      x = [];\n    t.templates.lightbox_header ? (x.push(\"\"), x.push(t.templates.lightbox_header(p.start_date, p.end_date, p)), k[1].innerHTML = \"\", k[2].innerHTML = t.templates.lightbox_header(p.start_date, p.end_date, p)) : (x.push(this.templates.task_time(p.start_date, p.end_date, p)), x.push(String(this.templates.task_text(p.start_date, p.end_date, p) || \"\").substr(0, 70)), k[1].innerHTML = this.templates.task_time(p.start_date, p.end_date, p), k[2].innerHTML = String(this.templates.task_text(p.start_date, p.end_date, p) || \"\").substr(0, 70)), k[1].innerHTML = x[0], k[2].innerHTML = x[1], t._waiAria.lightboxHeader(m, x.join(\" \"));\n    for (var $ = this._get_typed_lightbox_config(this.getLightboxType()), w = 0; w < $.length; w++) {\n      var S = $[w];\n      if (this.form_blocks[S.type]) {\n        var T = t._lightbox_root.querySelector(\"#\" + S.id).nextSibling,\n          E = this.form_blocks[S.type],\n          C = t._resolve_default_mapping($[w]),\n          D = this.defined(p[C]) ? p[C] : S.default_value;\n        E.set_value.call(t, T, D, p, S), S.focus && E.focus.call(t, T);\n      }\n    }\n    t.isTaskExists(_.id) && (t._lightbox_id = _.id);\n  }, t._fill_lightbox = function (_, m) {\n    var p = this.getTask(_);\n    this._set_lightbox_values(p, m);\n  }, t.getLightboxSection = function (_) {\n    for (var m = this._get_typed_lightbox_config(), p = 0; p < m.length && m[p].name != _; p++);\n    var k = m[p];\n    if (!k) return null;\n    this._lightbox || this.getLightbox();\n    var x = t._lightbox_root.querySelector(\"#\" + k.id),\n      $ = x.nextSibling,\n      w = {\n        section: k,\n        header: x,\n        node: $,\n        getValue: function (T) {\n          return t.form_blocks[k.type].get_value.call(t, $, T || {}, k);\n        },\n        setValue: function (T, E) {\n          return t.form_blocks[k.type].set_value.call(t, $, T, E || {}, k);\n        }\n      },\n      S = this._lightbox_methods[\"get_\" + k.type + \"_control\"];\n    return S ? S(w) : w;\n  }, t._lightbox_methods.get_template_control = function (_) {\n    return _.control = _.node, _;\n  }, t._lightbox_methods.get_select_control = function (_) {\n    return _.control = _.node.getElementsByTagName(\"select\")[0], _;\n  }, t._lightbox_methods.get_textarea_control = function (_) {\n    return _.control = _.node.getElementsByTagName(\"textarea\")[0], _;\n  }, t._lightbox_methods.get_time_control = function (_) {\n    return _.control = _.node.getElementsByTagName(\"select\"), _;\n  }, t._init_dnd_events = function () {\n    var _ = t._lightbox_root;\n    this.event(_, \"mousemove\", t._move_while_dnd), this.event(_, \"mouseup\", t._finish_dnd), this.event(_, \"touchmove\", function (m) {\n      t._move_while_dnd(m.touches[0]);\n    }), this.event(_, \"touchend\", function (m) {\n      t._finish_dnd(m.touches[0]);\n    });\n  }, t._move_while_dnd = function (_) {\n    if (t._dnd_start_lb) {\n      document.gantt_unselectable || (t._lightbox_root.className += \" gantt_unselectable\", document.gantt_unselectable = !0);\n      var m = t.getLightbox(),\n        p = [_.pageX, _.pageY];\n      m.style.top = t._lb_start[1] + p[1] - t._dnd_start_lb[1] + \"px\", m.style.left = t._lb_start[0] + p[0] - t._dnd_start_lb[0] + \"px\";\n    }\n  }, t._ready_to_dnd = function (_) {\n    var m = t.getLightbox();\n    t._lb_start = [m.offsetLeft, m.offsetTop], t._dnd_start_lb = [_.pageX, _.pageY];\n  }, t._finish_dnd = function () {\n    t._lb_start && (t._lb_start = t._dnd_start_lb = !1, t._lightbox_root.className = t._lightbox_root.className.replace(\" gantt_unselectable\", \"\"), document.gantt_unselectable = !1);\n  }, t._focus = function (_, m) {\n    if (_ && _.focus && !t.config.touch) try {\n      m && _.select && _.select(), _.focus();\n    } catch {}\n  }, t.form_blocks = {\n    getTimePicker: function (_, m) {\n      var p,\n        k,\n        x,\n        $ = \"\",\n        w = this.config,\n        S = {\n          first: 0,\n          last: 1440,\n          date: this.date.date_part(new Date(t._min_date.valueOf())),\n          timeFormat: v(_)\n        };\n      for (_._time_format_order = {\n        size: 0\n      }, t.config.limit_time_select && (S.first = 60 * w.first_hour, S.last = 60 * w.last_hour + 1, S.date.setHours(w.first_hour)), p = 0; p < S.timeFormat.length; p++) p > 0 && ($ += \" \"), (k = b(_, p, S)) && (x = t._waiAria.lightboxSelectAttrString(S.timeFormat[p]), $ += \"<select \" + (_.readonly ? \"disabled='disabled'\" : \"\") + (m ? \" style='display:none' \" : \"\") + x + \">\" + k + \"</select>\");\n      return $;\n    },\n    getTimePickerValue: function (_, m, p) {\n      var k,\n        x = m._time_format_order,\n        $ = 0,\n        w = 0,\n        S = p || 0;\n      return t.defined(x[3]) && (k = parseInt(_[x[3] + S].value, 10), $ = Math.floor(k / 60), w = k % 60), new Date(_[x[2] + S].value, _[x[1] + S].value, _[x[0] + S].value, $, w);\n    },\n    _fill_lightbox_select: function (_, m, p, k) {\n      if (_[m + k[0]].value = p.getDate(), _[m + k[1]].value = p.getMonth(), _[m + k[2]].value = p.getFullYear(), t.defined(k[3])) {\n        var x = 60 * p.getHours() + p.getMinutes();\n        x = Math.round(x / t._get_timepicker_step()) * t._get_timepicker_step();\n        var $ = _[m + k[3]];\n        $.value = x, $.setAttribute(\"data-value\", x);\n      }\n    },\n    template: new e(),\n    textarea: new n(),\n    select: new a(),\n    time: new i(),\n    duration: new o(),\n    parent: new l(),\n    radio: new s(),\n    checkbox: new r(),\n    resources: new d(),\n    constraint: new c(),\n    baselines: new h(),\n    typeselect: new u()\n  }, t._is_lightbox_timepicker = function () {\n    for (var _ = this._get_typed_lightbox_config(), m = 0; m < _.length; m++) if (_[m].name == \"time\" && _[m].type == \"time\") return !0;\n    return !1;\n  }, t._simple_confirm = function (_, m, p, k) {\n    if (!_) return p();\n    var x = {\n      text: _\n    };\n    m && (x.title = m), k && (x.ok = k), p && (x.callback = function ($) {\n      $ && p();\n    }), t.confirm(x);\n  }, t._get_typed_lightbox_config = function (_) {\n    _ === void 0 && (_ = this.getLightboxType());\n    var m = f.call(this, _);\n    return t.config.lightbox[m + \"_sections\"] ? t.config.lightbox[m + \"_sections\"] : t.config.lightbox.sections;\n  }, t._silent_redraw_lightbox = function (_) {\n    var m = this.getLightboxType();\n    if (this.getState().lightbox) {\n      var p = this.getState().lightbox,\n        k = this.getLightboxValues(),\n        x = this.copy(this.getTask(p));\n      this.resetLightbox();\n      var $ = this.mixin(x, k, !0),\n        w = this.getLightbox(_ || void 0);\n      this._set_lightbox_values($, w), this.showCover(w);\n    } else this.resetLightbox(), this.getLightbox(_ || void 0);\n    this.callEvent(\"onLightboxChange\", [m, this.getLightboxType()]);\n  };\n}\nfunction nr(t) {\n  if (!mt.isNode) {\n    t.utils = {\n      arrayFind: Rn,\n      dom: on\n    };\n    var e = Se();\n    t.event = e.attach, t.eventRemove = e.detach, t._eventRemoveAll = e.detachAll, t._createDomEventScope = e.extend, L(t, ca(t));\n    var n = qa.init(t);\n    t.$ui = n.factory, t.$ui.layers = n.render, t.$mouseEvents = n.mouseEvents, t.$services.setService(\"mouseEvents\", function () {\n      return t.$mouseEvents;\n    }), t.mixin(t, n.layersApi), function (i) {\n      delete i.addTaskLayer, delete i.addLinkLayer;\n    }(t), t.$services.setService(\"layers\", function () {\n      return n.layersService;\n    }), t.mixin(t, /* @__PURE__ */function () {\n      function i(u) {\n        return u.$ui.getView(\"timeline\");\n      }\n      function a(u) {\n        return u.$ui.getView(\"grid\");\n      }\n      function r(u) {\n        var h = i(u);\n        if (h && !h.$config.hidden) return h;\n        var g = a(u);\n        return g && !g.$config.hidden ? g : null;\n      }\n      function s(u) {\n        var h = null,\n          g = !1;\n        return [\".gantt_drag_marker.gantt_grid_resize_area\", \".gantt_drag_marker .gantt_row.gantt_row_task\", \".gantt_drag_marker.gantt_grid_dnd_marker\"].forEach(function (f) {\n          g = g || !!document.querySelector(f);\n        }), (h = g ? a(u) : r(u)) ? l(u, h, \"scrollY\") : null;\n      }\n      function o(u) {\n        var h = r(u);\n        return h && h.id != \"grid\" ? l(u, h, \"scrollX\") : null;\n      }\n      function l(u, h, g) {\n        var f = h.$config[g];\n        return u.$ui.getView(f);\n      }\n      var d = \"DEFAULT_VALUE\";\n      function c(u, h, g, f) {\n        var y = u(this);\n        return y && y.isVisible() ? y[h].apply(y, g) : f ? f() : d;\n      }\n      return {\n        getColumnIndex: function (u) {\n          var h = c.call(this, a, \"getColumnIndex\", [u]);\n          return h === d ? 0 : h;\n        },\n        dateFromPos: function (u) {\n          var h = c.call(this, i, \"dateFromPos\", Array.prototype.slice.call(arguments));\n          return h === d ? this.getState().min_date : h;\n        },\n        posFromDate: function (u) {\n          var h = c.call(this, i, \"posFromDate\", [u]);\n          return h === d ? 0 : h;\n        },\n        getRowTop: function (u) {\n          var h = this,\n            g = c.call(h, i, \"getRowTop\", [u], function () {\n              return c.call(h, a, \"getRowTop\", [u]);\n            });\n          return g === d ? 0 : g;\n        },\n        getTaskTop: function (u) {\n          var h = this,\n            g = c.call(h, i, \"getItemTop\", [u], function () {\n              return c.call(h, a, \"getItemTop\", [u]);\n            });\n          return g === d ? 0 : g;\n        },\n        getTaskPosition: function (u, h, g) {\n          var f = c.call(this, i, \"getItemPosition\", [u, h, g]);\n          return f === d ? {\n            left: 0,\n            top: this.getTaskTop(u.id),\n            height: this.getTaskBarHeight(u.id),\n            width: 0\n          } : f;\n        },\n        getTaskBarHeight: function (u, h) {\n          var g = this,\n            f = c.call(g, i, \"getBarHeight\", [u, h], function () {\n              return c.call(g, a, \"getItemHeight\", [u]);\n            });\n          return f === d ? 0 : f;\n        },\n        getTaskHeight: function (u) {\n          var h = this,\n            g = c.call(h, i, \"getItemHeight\", [u], function () {\n              return c.call(h, a, \"getItemHeight\", [u]);\n            });\n          return g === d ? 0 : g;\n        },\n        columnIndexByDate: function (u) {\n          var h = c.call(this, i, \"columnIndexByDate\", [u]);\n          return h === d ? 0 : h;\n        },\n        roundTaskDates: function () {\n          c.call(this, i, \"roundTaskDates\", []);\n        },\n        getScale: function () {\n          var u = c.call(this, i, \"getScale\", []);\n          return u === d ? null : u;\n        },\n        getTaskNode: function (u) {\n          var h = i(this);\n          if (h && h.isVisible()) {\n            var g = h._taskRenderer.rendered[u];\n            if (!g) {\n              var f = h.$config.item_attribute;\n              g = h.$task_bars.querySelector(\"[\" + f + \"='\" + u + \"']\");\n            }\n            return g || null;\n          }\n          return null;\n        },\n        getLinkNode: function (u) {\n          var h = i(this);\n          return h.isVisible() ? h._linkRenderer.rendered[u] : null;\n        },\n        scrollTo: function (u, h) {\n          var g = s(this),\n            f = o(this),\n            y = {\n              position: 0\n            },\n            v = {\n              position: 0\n            };\n          g && (v = g.getScrollState()), f && (y = f.getScrollState());\n          var b = f && 1 * u == u,\n            _ = g && 1 * h == h;\n          if (b && _) for (var m = g._getLinkedViews(), p = f._getLinkedViews(), k = [], x = 0; x < m.length; x++) for (var $ = 0; $ < p.length; $++) m[x].$config.id && p[$].$config.id && m[x].$config.id === p[$].$config.id && k.push(m[x].$config.id);\n          b && (k && k.forEach(function (T) {\n            this.$ui.getView(T).$config.$skipSmartRenderOnScroll = !0;\n          }.bind(this)), f.scroll(u), k && k.forEach(function (T) {\n            this.$ui.getView(T).$config.$skipSmartRenderOnScroll = !1;\n          }.bind(this))), _ && g.scroll(h);\n          var w = {\n              position: 0\n            },\n            S = {\n              position: 0\n            };\n          g && (w = g.getScrollState()), f && (S = f.getScrollState()), this.callEvent(\"onGanttScroll\", [y.position, v.position, S.position, w.position]);\n        },\n        showDate: function (u) {\n          var h = this.posFromDate(u),\n            g = Math.max(h - this.config.task_scroll_offset, 0);\n          this.scrollTo(g);\n        },\n        showTask: function (u) {\n          var h = this.getTaskPosition(this.getTask(u)),\n            g = h.left;\n          this.config.rtl && (g = h.left + h.width);\n          var f,\n            y = Math.max(g - this.config.task_scroll_offset, 0),\n            v = this._scroll_state().y;\n          f = v ? h.top - (v - this.getTaskBarHeight(u)) / 2 : h.top, this.scrollTo(y, f);\n          var b = a(this),\n            _ = i(this);\n          b && _ && b.$config.scrollY != _.$config.scrollY && l(this, b, \"scrollY\").scrollTo(null, f);\n        },\n        _scroll_state: function () {\n          var u = {\n              x: !1,\n              y: !1,\n              x_pos: 0,\n              y_pos: 0,\n              scroll_size: this.config.scroll_size + 1,\n              x_inner: 0,\n              y_inner: 0\n            },\n            h = s(this),\n            g = o(this);\n          if (g) {\n            var f = g.getScrollState();\n            f.visible && (u.x = f.size, u.x_inner = f.scrollSize), u.x_pos = f.position || 0;\n          }\n          if (h) {\n            var y = h.getScrollState();\n            y.visible && (u.y = y.size, u.y_inner = y.scrollSize), u.y_pos = y.position || 0;\n          }\n          return u;\n        },\n        getScrollState: function () {\n          var u = this._scroll_state();\n          return {\n            x: u.x_pos,\n            y: u.y_pos,\n            inner_width: u.x,\n            inner_height: u.y,\n            width: u.x_inner,\n            height: u.y_inner\n          };\n        },\n        getLayoutView: function (u) {\n          return this.$ui.getView(u);\n        },\n        scrollLayoutCell: function (u, h, g) {\n          const f = this.$ui.getView(u);\n          if (!f) return !1;\n          if (h !== null) {\n            const y = this.$ui.getView(f.$config.scrollX);\n            y && y.scrollTo(h, null);\n          }\n          if (g !== null) {\n            const y = this.$ui.getView(f.$config.scrollY);\n            y && y.scrollTo(null, g);\n          }\n        }\n      };\n    }()), function (i) {\n      i.resetSkin || (i.resetSkin = function () {\n        this.skin = \"\", ce(!0, this);\n      }, i.skins = {}, i.attachEvent(\"onGanttLayoutReady\", function () {\n        ce(!1, this), r();\n      })), i._addThemeClass = function () {\n        document.documentElement.setAttribute(\"data-gantt-theme\", i.skin);\n      }, i.setSkin = function (s) {\n        this.skin = s, i._addThemeClass(), r(), i.$root && (ce(!0, i), this.render());\n      };\n      let a = null;\n      function r() {\n        const s = i.$root;\n        a && clearInterval(a), s && (a = setInterval(() => {\n          const o = getComputedStyle(s).getPropertyValue(\"--dhx-gantt-theme\");\n          o && o !== i.skin && i.setSkin(o);\n        }, 100));\n      }\n      i.attachEvent(\"onDestroy\", function () {\n        clearInterval(a);\n      });\n    }(t), function (i) {\n      i.skins.skyblue = {\n        config: {\n          grid_width: 370,\n          row_height: 27,\n          bar_height_padding: 4,\n          scale_height: 27,\n          link_line_width: 1,\n          link_arrow_size: 8,\n          link_radius: 2,\n          lightbox_additional_height: 75\n        },\n        _second_column_width: 95,\n        _third_column_width: 80\n      };\n    }(t), function (i) {\n      i.skins.dark = {\n        config: {\n          grid_width: 390,\n          row_height: 36,\n          scale_height: 36,\n          link_line_width: 2,\n          link_arrow_size: 12,\n          bar_height_padding: 9,\n          lightbox_additional_height: 75\n        },\n        _second_column_width: 100,\n        _third_column_width: 70\n      };\n    }(t), function (i) {\n      i.skins.meadow = {\n        config: {\n          grid_width: 380,\n          row_height: 27,\n          scale_height: 30,\n          link_line_width: 2,\n          link_arrow_size: 10,\n          bar_height_padding: 4,\n          lightbox_additional_height: 72\n        },\n        _second_column_width: 95,\n        _third_column_width: 80\n      };\n    }(t), function (i) {\n      i.skins.terrace = {\n        config: {\n          grid_width: 390,\n          row_height: 36,\n          scale_height: 36,\n          link_line_width: 2,\n          link_arrow_size: 12,\n          bar_height_padding: 9,\n          lightbox_additional_height: 75\n        },\n        _second_column_width: 100,\n        _third_column_width: 70\n      };\n    }(t), function (i) {\n      i.skins.broadway = {\n        config: {\n          grid_width: 390,\n          row_height: 35,\n          scale_height: 35,\n          link_line_width: 1,\n          link_arrow_size: 9,\n          bar_height_padding: 4,\n          lightbox_additional_height: 86\n        },\n        _second_column_width: 100,\n        _third_column_width: 80,\n        _lightbox_template: \"<div class='gantt_cal_ltitle'><span class='gantt_mark'>&nbsp;</span><span class='gantt_time'></span><span class='gantt_title'></span><div class='gantt_cancel_btn'></div></div><div class='gantt_cal_larea'></div>\",\n        _config_buttons_left: {},\n        _config_buttons_right: {\n          gantt_delete_btn: \"icon_delete\",\n          gantt_save_btn: \"icon_save\"\n        }\n      };\n    }(t), function (i) {\n      i.skins.material = {\n        config: {\n          grid_width: 411,\n          row_height: 34,\n          scale_height: 36,\n          link_line_width: 2,\n          link_arrow_size: 12,\n          bar_height_padding: 9,\n          lightbox_additional_height: 80\n        },\n        _second_column_width: 110,\n        _third_column_width: 75,\n        _redefine_lightbox_buttons: {\n          buttons_left: [\"dhx_delete_btn\"],\n          buttons_right: [\"dhx_cancel_btn\", \"dhx_save_btn\"]\n        }\n      }, i.attachEvent(\"onAfterTaskDrag\", function (a) {\n        var r = i.getTaskNode(a);\n        r && (r.className += \" gantt_drag_animation\", setTimeout(function () {\n          var s = r.className.indexOf(\" gantt_drag_animation\");\n          s > -1 && (r.className = r.className.slice(0, s));\n        }, 200));\n      });\n    }(t), function (i) {\n      i.skins.contrast_black = {\n        config: {\n          grid_width: 390,\n          row_height: 35,\n          scale_height: 35,\n          link_line_width: 2,\n          link_arrow_size: 12,\n          lightbox_additional_height: 75\n        },\n        _second_column_width: 100,\n        _third_column_width: 80\n      };\n    }(t), function (i) {\n      i.skins.contrast_white = {\n        config: {\n          grid_width: 390,\n          row_height: 35,\n          scale_height: 35,\n          link_line_width: 2,\n          link_arrow_size: 12,\n          lightbox_additional_height: 75\n        },\n        _second_column_width: 100,\n        _third_column_width: 80\n      };\n    }(t), function (i) {\n      i.ext || (i.ext = {});\n      for (var a = [Ga, Ya, Ja], r = 0; r < a.length; r++) a[r] && a[r](i);\n      i.ext.zoom = new Za(i);\n    }(t), Qa(t), er(t), function (i) {\n      i._extend_to_optional = function (a) {\n        var r = a,\n          s = {\n            render: r.render,\n            focus: r.focus,\n            set_value: function (o, l, d, c) {\n              var u = i._resolve_default_mapping(c);\n              if (!d[u.start_date] || u.start_date == \"start_date\" && this._isAllowedUnscheduledTask(d)) {\n                s.disable(o, c);\n                var h = {};\n                for (var g in u) h[u[g]] = d[g];\n                return r.set_value.call(i, o, l, h, c);\n              }\n              return s.enable(o, c), r.set_value.call(i, o, l, d, c);\n            },\n            get_value: function (o, l, d) {\n              return d.disabled ? {\n                start_date: null\n              } : r.get_value.call(i, o, l, d);\n            },\n            update_block: function (o, l) {\n              if (i.callEvent(\"onSectionToggle\", [i._lightbox_id, l]), o.style.display = l.disabled ? \"none\" : \"\", l.button) {\n                var d = o.previousSibling.querySelector(\".gantt_custom_button_label\"),\n                  c = i.locale.labels,\n                  u = l.disabled ? c[l.name + \"_enable_button\"] : c[l.name + \"_disable_button\"];\n                d.innerHTML = u;\n              }\n            },\n            disable: function (o, l) {\n              l.disabled = !0, s.update_block(o, l);\n            },\n            enable: function (o, l) {\n              l.disabled = !1, s.update_block(o, l);\n            },\n            button_click: function (o, l, d, c) {\n              if (i.callEvent(\"onSectionButton\", [i._lightbox_id, d]) !== !1) {\n                var u = i._get_typed_lightbox_config()[o];\n                u.disabled ? s.enable(c, u) : s.disable(c, u);\n              }\n            }\n          };\n        return s;\n      }, i.form_blocks.duration_optional = i._extend_to_optional(i.form_blocks.duration), i.form_blocks.time_optional = i._extend_to_optional(i.form_blocks.time);\n    }(t), function (i) {\n      var a = new RegExp(`<(?:.|\n)*?>`, \"gm\"),\n        r = new RegExp(\" +\", \"gm\");\n      function s(c) {\n        return (c + \"\").replace(a, \" \").replace(r, \" \");\n      }\n      var o = new RegExp(\"'\", \"gm\");\n      function l(c) {\n        return (c + \"\").replace(o, \"&#39;\");\n      }\n      for (var d in i._waiAria = {\n        getAttributeString: function (c) {\n          var u = [\" \"];\n          for (var h in c) {\n            var g = l(s(c[h]));\n            u.push(h + \"='\" + g + \"'\");\n          }\n          return u.push(\" \"), u.join(\" \");\n        },\n        getTimelineCellAttr: function (c) {\n          return i._waiAria.getAttributeString({\n            \"aria-label\": c\n          });\n        },\n        _taskCommonAttr: function (c, u) {\n          c.start_date && c.end_date && (u.setAttribute(\"aria-label\", s(i.templates.tooltip_text(c.start_date, c.end_date, c))), c.$dataprocessor_class && u.setAttribute(\"aria-busy\", !0));\n        },\n        setTaskBarAttr: function (c, u) {\n          this._taskCommonAttr(c, u), u.setAttribute(\"role\", \"img\"), !i.isReadonly(c) && i.config.drag_move && (c.id != i.getState(\"tasksDnd\").drag_id ? u.setAttribute(\"aria-grabbed\", !1) : u.setAttribute(\"aria-grabbed\", !0));\n        },\n        taskRowAttr: function (c, u) {\n          this._taskCommonAttr(c, u), !i.isReadonly(c) && i.config.order_branch && u.setAttribute(\"aria-grabbed\", !1), u.setAttribute(\"role\", \"row\"), u.setAttribute(\"aria-selected\", i.isSelectedTask(c.id) ? \"true\" : \"false\"), u.setAttribute(\"aria-level\", c.$level + 1 || 1), i.hasChild(c.id) && u.setAttribute(\"aria-expanded\", c.$open ? \"true\" : \"false\");\n        },\n        linkAttr: function (c, u) {\n          var h = i.config.links,\n            g = c.type == h.finish_to_start || c.type == h.start_to_start,\n            f = c.type == h.start_to_start || c.type == h.start_to_finish,\n            y = i.locale.labels.link + \" \" + i.templates.drag_link(c.source, f, c.target, g);\n          u.setAttribute(\"role\", \"img\"), u.setAttribute(\"aria-label\", s(y)), i.isReadonly(c) && u.setAttribute(\"aria-readonly\", !0);\n        },\n        gridSeparatorAttr: function (c) {\n          c.setAttribute(\"role\", \"columnheader\");\n        },\n        rowResizerAttr: function (c) {\n          c.setAttribute(\"role\", \"row\");\n        },\n        lightboxHiddenAttr: function (c) {\n          c.setAttribute(\"aria-hidden\", \"true\");\n        },\n        lightboxVisibleAttr: function (c) {\n          c.setAttribute(\"aria-hidden\", \"false\");\n        },\n        lightboxAttr: function (c) {\n          c.setAttribute(\"role\", \"dialog\"), c.setAttribute(\"aria-hidden\", \"true\"), c.firstChild.setAttribute(\"role\", \"heading\"), c.firstChild.setAttribute(\"aria-level\", \"1\");\n        },\n        lightboxButtonAttrString: function (c) {\n          return this.getAttributeString({\n            role: \"button\",\n            \"aria-label\": i.locale.labels[c],\n            tabindex: \"0\"\n          });\n        },\n        lightboxHeader: function (c, u) {\n          c.setAttribute(\"aria-label\", u);\n        },\n        lightboxSelectAttrString: function (c) {\n          var u = \"\";\n          switch (c) {\n            case \"%Y\":\n              u = i.locale.labels.years;\n              break;\n            case \"%m\":\n              u = i.locale.labels.months;\n              break;\n            case \"%d\":\n              u = i.locale.labels.days;\n              break;\n            case \"%H:%i\":\n              u = i.locale.labels.hours + i.locale.labels.minutes;\n          }\n          return i._waiAria.getAttributeString({\n            \"aria-label\": u\n          });\n        },\n        lightboxDurationInputAttrString: function (c) {\n          return this.getAttributeString({\n            \"aria-label\": i.locale.labels.column_duration,\n            \"aria-valuemin\": \"0\",\n            role: \"spinbutton\"\n          });\n        },\n        inlineEditorAttr: function (c) {\n          c.setAttribute(\"role\", \"row\");\n        },\n        gridAttrString: function () {\n          return [\" role='treegrid'\", i.config.multiselect ? \"aria-multiselectable='true'\" : \"aria-multiselectable='false'\", \" \"].join(\" \");\n        },\n        gridScaleRowAttrString: function () {\n          return \"role='row'\";\n        },\n        gridScaleCellAttrString: function (c, u) {\n          var h = \"\";\n          if (c.name == \"add\") h = this.getAttributeString({\n            role: \"columnheader\",\n            \"aria-label\": i.locale.labels.new_task\n          });else {\n            var g = {\n              role: \"columnheader\",\n              \"aria-label\": u\n            };\n            i._sort && i._sort.name == c.name && (i._sort.direction == \"asc\" ? g[\"aria-sort\"] = \"ascending\" : g[\"aria-sort\"] = \"descending\"), h = this.getAttributeString(g);\n          }\n          return h;\n        },\n        gridDataAttrString: function () {\n          return \"role='rowgroup'\";\n        },\n        reorderMarkerAttr: function (c) {\n          c.setAttribute(\"role\", \"grid\"), c.firstChild.removeAttribute(\"aria-level\"), c.firstChild.setAttribute(\"aria-grabbed\", \"true\");\n        },\n        gridCellAttrString: function (c, u, h) {\n          var g = {\n            role: \"gridcell\",\n            \"aria-label\": u\n          };\n          return c.editor && !i.isReadonly(h) || (g[\"aria-readonly\"] = !0), this.getAttributeString(g);\n        },\n        gridAddButtonAttrString: function (c) {\n          return this.getAttributeString({\n            role: \"button\",\n            \"aria-label\": i.locale.labels.new_task\n          });\n        },\n        messageButtonAttrString: function (c) {\n          return \"tabindex='0' role='button' aria-label='\" + c + \"'\";\n        },\n        messageInfoAttr: function (c) {\n          c.setAttribute(\"role\", \"alert\");\n        },\n        messageModalAttr: function (c, u) {\n          c.setAttribute(\"role\", \"dialog\"), u && c.setAttribute(\"aria-labelledby\", u);\n        },\n        quickInfoAttr: function (c) {\n          c.setAttribute(\"role\", \"dialog\");\n        },\n        quickInfoHeaderAttrString: function () {\n          return \" role='heading' aria-level='1' \";\n        },\n        quickInfoHeader: function (c, u) {\n          c.setAttribute(\"aria-label\", u);\n        },\n        quickInfoButtonAttrString: function (c) {\n          return i._waiAria.getAttributeString({\n            role: \"button\",\n            \"aria-label\": c,\n            tabindex: \"0\"\n          });\n        },\n        tooltipAttr: function (c) {\n          c.setAttribute(\"role\", \"tooltip\");\n        },\n        tooltipVisibleAttr: function (c) {\n          c.setAttribute(\"aria-hidden\", \"false\");\n        },\n        tooltipHiddenAttr: function (c) {\n          c.setAttribute(\"aria-hidden\", \"true\");\n        }\n      }, i._waiAria) i._waiAria[d] = /* @__PURE__ */function (c) {\n        return function () {\n          return i.config.wai_aria_attributes ? c.apply(this, arguments) : \"\";\n        };\n      }(i._waiAria[d]);\n    }(t), t.locate = function (i) {\n      var a = yt(i);\n      if (ct(a, \".gantt_task_row\")) return null;\n      var r = arguments[1] || this.config.task_attribute,\n        s = et(a, r);\n      return s ? s.getAttribute(r) : null;\n    }, t._locate_css = function (i, a, r) {\n      return pt(i, a, r);\n    }, t._locateHTML = function (i, a) {\n      return et(i, a || this.config.task_attribute);\n    };\n  }\n  t.attachEvent(\"onParse\", function () {\n    V(t) || t.attachEvent(\"onGanttRender\", function () {\n      if (t.config.initial_scroll) {\n        var i = t.getTaskByIndex(0),\n          a = i ? i.id : t.config.root_id;\n        t.isTaskExists(a) && t.$task && t.utils.dom.isChildOf(t.$task, t.$container) && t.showTask(a);\n      }\n    }, {\n      once: !0\n    });\n  }), t.attachEvent(\"onBeforeGanttReady\", function () {\n    this.config.scroll_size || (this.config.scroll_size = Qe() || 15), V(t) || (this._eventRemoveAll(), this.$mouseEvents.reset(), this.resetLightbox());\n  }), t.attachEvent(\"onGanttReady\", function () {\n    !V(t) && t.config.rtl && t.$layout.getCellsByType(\"viewCell\").forEach(function (i) {\n      var a = i.$config.scrollX;\n      if (a) {\n        var r = t.$ui.getView(a);\n        r && r.scrollTo(r.$config.scrollSize, 0);\n      }\n    });\n  }), t.attachEvent(\"onGanttReady\", function () {\n    if (!V(t)) {\n      var i = t.plugins(),\n        a = {\n          auto_scheduling: t.autoSchedule,\n          click_drag: t.ext.clickDrag,\n          critical_path: t.isCriticalTask,\n          drag_timeline: t.ext.dragTimeline,\n          export_api: t.exportToPDF,\n          fullscreen: t.ext.fullscreen,\n          grouping: t.groupBy,\n          keyboard_navigation: t.ext.keyboardNavigation,\n          marker: t.addMarker,\n          multiselect: t.eachSelectedTask,\n          overlay: t.ext.overlay,\n          quick_info: t.templates.quick_info_content,\n          tooltip: t.ext.tooltips,\n          undo: t.undo\n        };\n      for (let r in a) a[r] && !i[r] && console.warn(`You connected the '${r}' extension via an obsolete file. \nTo fix it, you need to remove the obsolete file and connect the extension via the plugins method: https://docs.dhtmlx.com/gantt/api__gantt_plugins.html`);\n    }\n  });\n}\nconst ir = dt.gantt = function (t) {\n  var e = da(t);\n  return e.env.isNode || (nr(e), function (n) {\n    n.load = function (i, a, r) {\n      this._load_url = i, this.assert(arguments.length, \"Invalid load arguments\");\n      var s = \"json\",\n        o = null;\n      return arguments.length >= 3 ? (s = a, o = r) : typeof arguments[1] == \"string\" ? s = arguments[1] : typeof arguments[1] == \"function\" && (o = arguments[1]), this._load_type = s, this.callEvent(\"onLoadStart\", [i, s]), this.ajax.get(i, n.bind(function (l) {\n        this.on_load(l, s), this.callEvent(\"onLoadEnd\", [i, s]), typeof o == \"function\" && o.call(this);\n      }, this));\n    };\n  }(e)), e;\n}(qn);\nexport { ir as default, ir as gantt };\n//# sourceMappingURL=dhtmlxgantt.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}