{"ast":null,"code":"import { __spreadArray } from 'tslib';\nimport { onSnapshot, refEqual } from 'firebase/firestore';\nimport { Observable, pipe } from 'rxjs';\nimport { map, startWith, pairwise, filter, scan, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEFAULT_OPTIONS = {\n  includeMetadataChanges: false\n};\nfunction fromRef(ref, options) {\n  if (options === void 0) {\n    options = DEFAULT_OPTIONS;\n  }\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n  return new Observable(function (subscriber) {\n    var unsubscribe = onSnapshot(ref, options, {\n      next: subscriber.next.bind(subscriber),\n      error: subscriber.error.bind(subscriber),\n      complete: subscriber.complete.bind(subscriber)\n    });\n    return {\n      unsubscribe: unsubscribe\n    };\n  });\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction doc(ref) {\n  return fromRef(ref, {\n    includeMetadataChanges: true\n  });\n}\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\nfunction docData(ref, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return doc(ref).pipe(map(function (snap) {\n    return snapToData(snap, options);\n  }));\n}\nfunction snapToData(snapshot, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  // TODO clean up the typings\n  var data = snapshot.data();\n  // match the behavior of the JS SDK when the snapshot doesn't exist\n  // it's possible with data converters too that the user didn't return an object\n  if (!snapshot.exists() || typeof data !== 'object' || data === null) {\n    return data;\n  }\n  if (options.idField) {\n    data[options.idField] = snapshot.id;\n  }\n  return data;\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\nvar filterEvents = function (events) {\n  return filter(function (changes) {\n    var hasChange = false;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      if (events && events.indexOf(change.type) >= 0) {\n        hasChange = true;\n        break;\n      }\n    }\n    return hasChange;\n  });\n};\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice(original, start, deleteCount) {\n  var args = [];\n  for (var _i = 3; _i < arguments.length; _i++) {\n    args[_i - 3] = arguments[_i];\n  }\n  var returnArray = original.slice();\n  returnArray.splice.apply(returnArray, __spreadArray([start, deleteCount], args));\n  return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\nfunction processIndividualChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && refEqual(combined[change.newIndex].doc.ref, change.doc.ref)) ;else {\n        return sliceAndSplice(combined, change.newIndex, 0, change);\n      }\n      break;\n    case 'modified':\n      if (combined[change.oldIndex] == null || refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n        // When an item changes position we first remove it\n        // and then add it's new position\n        if (change.oldIndex !== change.newIndex) {\n          var copiedArray = combined.slice();\n          copiedArray.splice(change.oldIndex, 1);\n          copiedArray.splice(change.newIndex, 0, change);\n          return copiedArray;\n        } else {\n          return sliceAndSplice(combined, change.newIndex, 1, change);\n        }\n      }\n      break;\n    case 'removed':\n      if (combined[change.oldIndex] && refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n        return sliceAndSplice(combined, change.oldIndex, 1);\n      }\n      break;\n  }\n  return combined;\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\nfunction processDocumentChanges(current, changes, events) {\n  if (events === void 0) {\n    events = ALL_EVENTS;\n  }\n  changes.forEach(function (change) {\n    // skip unwanted change types\n    if (events.indexOf(change.type) > -1) {\n      current = processIndividualChange(current, change);\n    }\n  });\n  return current;\n}\n/**\n * Create an operator that allows you to compare the current emission with\n * the prior, even on first emission (where prior is undefined).\n */\nvar windowwise = function () {\n  return pipe(startWith(undefined), pairwise());\n};\n/**\n * Given two snapshots does their metadata match?\n * @param a\n * @param b\n */\nvar metaDataEquals = function (a, b) {\n  return JSON.stringify(a.metadata) === JSON.stringify(b.metadata);\n};\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\nvar filterEmptyUnlessFirst = function () {\n  return pipe(windowwise(), filter(function (_a) {\n    var prior = _a[0],\n      current = _a[1];\n    return current.length > 0 || prior === undefined;\n  }), map(function (_a) {\n    _a[0];\n    var current = _a[1];\n    return current;\n  }));\n};\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\nfunction collectionChanges(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return fromRef(query, {\n    includeMetadataChanges: true\n  }).pipe(windowwise(), map(function (_a) {\n    var priorSnapshot = _a[0],\n      currentSnapshot = _a[1];\n    var docChanges = currentSnapshot.docChanges();\n    if (priorSnapshot && !metaDataEquals(priorSnapshot, currentSnapshot)) {\n      // the metadata has changed, docChanges() doesn't return metadata events, so let's\n      // do it ourselves by scanning over all the docs and seeing if the metadata has changed\n      // since either this docChanges() emission or the prior snapshot\n      currentSnapshot.docs.forEach(function (currentDocSnapshot, currentIndex) {\n        var currentDocChange = docChanges.find(function (c) {\n          return refEqual(c.doc.ref, currentDocSnapshot.ref);\n        });\n        if (currentDocChange) {\n          // if the doc is in the current changes and the metadata hasn't changed this doc\n          if (metaDataEquals(currentDocChange.doc, currentDocSnapshot)) {\n            return;\n          }\n        } else {\n          // if there is a prior doc and the metadata hasn't changed skip this doc\n          var priorDocSnapshot = priorSnapshot === null || priorSnapshot === void 0 ? void 0 : priorSnapshot.docs.find(function (d) {\n            return refEqual(d.ref, currentDocSnapshot.ref);\n          });\n          if (priorDocSnapshot && metaDataEquals(priorDocSnapshot, currentDocSnapshot)) {\n            return;\n          }\n        }\n        docChanges.push({\n          oldIndex: currentIndex,\n          newIndex: currentIndex,\n          type: 'modified',\n          doc: currentDocSnapshot\n        });\n      });\n    }\n    return docChanges;\n  }), filterEvents(options.events || ALL_EVENTS), filterEmptyUnlessFirst());\n}\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\nfunction collection(query) {\n  return fromRef(query, {\n    includeMetadataChanges: true\n  }).pipe(map(function (changes) {\n    return changes.docs;\n  }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\nfunction sortedChanges(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return collectionChanges(query, options).pipe(scan(function (current, changes) {\n    return processDocumentChanges(current, changes, options.events);\n  }, []), distinctUntilChanged());\n}\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\nfunction auditTrail(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return collectionChanges(query, options).pipe(scan(function (current, action) {\n    return __spreadArray(__spreadArray([], current), action);\n  }, []));\n}\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\nfunction collectionData(query, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return collection(query).pipe(map(function (arr) {\n    return arr.map(function (snap) {\n      return snapToData(snap, options);\n    });\n  }));\n}\nexport { auditTrail, collection, collectionChanges, collectionData, doc, docData, fromRef, snapToData, sortedChanges };","map":{"version":3,"names":["__spreadArray","onSnapshot","refEqual","Observable","pipe","map","startWith","pairwise","filter","scan","distinctUntilChanged","DEFAULT_OPTIONS","includeMetadataChanges","fromRef","ref","options","subscriber","unsubscribe","next","bind","error","complete","doc","docData","snap","snapToData","snapshot","data","exists","idField","id","ALL_EVENTS","filterEvents","events","changes","hasChange","i","length","change","indexOf","type","sliceAndSplice","original","start","deleteCount","args","_i","arguments","returnArray","slice","splice","apply","processIndividualChange","combined","newIndex","oldIndex","copiedArray","processDocumentChanges","current","forEach","windowwise","undefined","metaDataEquals","a","b","JSON","stringify","metadata","filterEmptyUnlessFirst","_a","prior","collectionChanges","query","priorSnapshot","currentSnapshot","docChanges","docs","currentDocSnapshot","currentIndex","currentDocChange","find","c","priorDocSnapshot","d","push","collection","sortedChanges","auditTrail","action","collectionData","arr"],"sources":["/Users/vinithyareddy/node_modules/rxfire/firestore/index.esm.js"],"sourcesContent":["import { __spreadArray } from 'tslib';\nimport { onSnapshot, refEqual } from 'firebase/firestore';\nimport { Observable, pipe } from 'rxjs';\nimport { map, startWith, pairwise, filter, scan, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEFAULT_OPTIONS = { includeMetadataChanges: false };\nfunction fromRef(ref, options) {\n    if (options === void 0) { options = DEFAULT_OPTIONS; }\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n    return new Observable(function (subscriber) {\n        var unsubscribe = onSnapshot(ref, options, {\n            next: subscriber.next.bind(subscriber),\n            error: subscriber.error.bind(subscriber),\n            complete: subscriber.complete.bind(subscriber),\n        });\n        return { unsubscribe: unsubscribe };\n    });\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction doc(ref) {\n    return fromRef(ref, { includeMetadataChanges: true });\n}\n/**\n * Returns a stream of a document, mapped to its data payload and optionally the document ID\n * @param query\n */\nfunction docData(ref, options) {\n    if (options === void 0) { options = {}; }\n    return doc(ref).pipe(map(function (snap) { return snapToData(snap, options); }));\n}\nfunction snapToData(snapshot, options) {\n    if (options === void 0) { options = {}; }\n    // TODO clean up the typings\n    var data = snapshot.data();\n    // match the behavior of the JS SDK when the snapshot doesn't exist\n    // it's possible with data converters too that the user didn't return an object\n    if (!snapshot.exists() || typeof data !== 'object' || data === null) {\n        return data;\n    }\n    if (options.idField) {\n        data[options.idField] = snapshot.id;\n    }\n    return data;\n}\n\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ALL_EVENTS = ['added', 'modified', 'removed'];\n/**\n * Create an operator that determines if a the stream of document changes\n * are specified by the event filter. If the document change type is not\n * in specified events array, it will not be emitted.\n */\nvar filterEvents = function (events) {\n    return filter(function (changes) {\n        var hasChange = false;\n        for (var i = 0; i < changes.length; i++) {\n            var change = changes[i];\n            if (events && events.indexOf(change.type) >= 0) {\n                hasChange = true;\n                break;\n            }\n        }\n        return hasChange;\n    });\n};\n/**\n * Splice arguments on top of a sliced array, to break top-level ===\n * this is useful for change-detection\n */\nfunction sliceAndSplice(original, start, deleteCount) {\n    var args = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n        args[_i - 3] = arguments[_i];\n    }\n    var returnArray = original.slice();\n    returnArray.splice.apply(returnArray, __spreadArray([start, deleteCount], args));\n    return returnArray;\n}\n/**\n * Creates a new sorted array from a new change.\n * @param combined\n * @param change\n */\nfunction processIndividualChange(combined, change) {\n    switch (change.type) {\n        case 'added':\n            if (combined[change.newIndex] &&\n                refEqual(combined[change.newIndex].doc.ref, change.doc.ref)) ;\n            else {\n                return sliceAndSplice(combined, change.newIndex, 0, change);\n            }\n            break;\n        case 'modified':\n            if (combined[change.oldIndex] == null ||\n                refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n                // When an item changes position we first remove it\n                // and then add it's new position\n                if (change.oldIndex !== change.newIndex) {\n                    var copiedArray = combined.slice();\n                    copiedArray.splice(change.oldIndex, 1);\n                    copiedArray.splice(change.newIndex, 0, change);\n                    return copiedArray;\n                }\n                else {\n                    return sliceAndSplice(combined, change.newIndex, 1, change);\n                }\n            }\n            break;\n        case 'removed':\n            if (combined[change.oldIndex] &&\n                refEqual(combined[change.oldIndex].doc.ref, change.doc.ref)) {\n                return sliceAndSplice(combined, change.oldIndex, 1);\n            }\n            break;\n    }\n    return combined;\n}\n/**\n * Combines the total result set from the current set of changes from an incoming set\n * of changes.\n * @param current\n * @param changes\n * @param events\n */\nfunction processDocumentChanges(current, changes, events) {\n    if (events === void 0) { events = ALL_EVENTS; }\n    changes.forEach(function (change) {\n        // skip unwanted change types\n        if (events.indexOf(change.type) > -1) {\n            current = processIndividualChange(current, change);\n        }\n    });\n    return current;\n}\n/**\n * Create an operator that allows you to compare the current emission with\n * the prior, even on first emission (where prior is undefined).\n */\nvar windowwise = function () {\n    return pipe(startWith(undefined), pairwise());\n};\n/**\n * Given two snapshots does their metadata match?\n * @param a\n * @param b\n */\nvar metaDataEquals = function (a, b) { return JSON.stringify(a.metadata) === JSON.stringify(b.metadata); };\n/**\n * Create an operator that filters out empty changes. We provide the\n * ability to filter on events, which means all changes can be filtered out.\n * This creates an empty array and would be incorrect to emit.\n */\nvar filterEmptyUnlessFirst = function () {\n    return pipe(windowwise(), filter(function (_a) {\n        var prior = _a[0], current = _a[1];\n        return current.length > 0 || prior === undefined;\n    }), map(function (_a) {\n        _a[0]; var current = _a[1];\n        return current;\n    }));\n};\n/**\n * Return a stream of document changes on a query. These results are not in sort order but in\n * order of occurence.\n * @param query\n */\nfunction collectionChanges(query, options) {\n    if (options === void 0) { options = {}; }\n    return fromRef(query, { includeMetadataChanges: true }).pipe(windowwise(), map(function (_a) {\n        var priorSnapshot = _a[0], currentSnapshot = _a[1];\n        var docChanges = currentSnapshot.docChanges();\n        if (priorSnapshot && !metaDataEquals(priorSnapshot, currentSnapshot)) {\n            // the metadata has changed, docChanges() doesn't return metadata events, so let's\n            // do it ourselves by scanning over all the docs and seeing if the metadata has changed\n            // since either this docChanges() emission or the prior snapshot\n            currentSnapshot.docs.forEach(function (currentDocSnapshot, currentIndex) {\n                var currentDocChange = docChanges.find(function (c) {\n                    return refEqual(c.doc.ref, currentDocSnapshot.ref);\n                });\n                if (currentDocChange) {\n                    // if the doc is in the current changes and the metadata hasn't changed this doc\n                    if (metaDataEquals(currentDocChange.doc, currentDocSnapshot)) {\n                        return;\n                    }\n                }\n                else {\n                    // if there is a prior doc and the metadata hasn't changed skip this doc\n                    var priorDocSnapshot = priorSnapshot === null || priorSnapshot === void 0 ? void 0 : priorSnapshot.docs.find(function (d) {\n                        return refEqual(d.ref, currentDocSnapshot.ref);\n                    });\n                    if (priorDocSnapshot &&\n                        metaDataEquals(priorDocSnapshot, currentDocSnapshot)) {\n                        return;\n                    }\n                }\n                docChanges.push({\n                    oldIndex: currentIndex,\n                    newIndex: currentIndex,\n                    type: 'modified',\n                    doc: currentDocSnapshot\n                });\n            });\n        }\n        return docChanges;\n    }), filterEvents(options.events || ALL_EVENTS), filterEmptyUnlessFirst());\n}\n/**\n * Return a stream of document snapshots on a query. These results are in sort order.\n * @param query\n */\nfunction collection(query) {\n    return fromRef(query, { includeMetadataChanges: true }).pipe(map(function (changes) { return changes.docs; }));\n}\n/**\n * Return a stream of document changes on a query. These results are in sort order.\n * @param query\n */\nfunction sortedChanges(query, options) {\n    if (options === void 0) { options = {}; }\n    return collectionChanges(query, options).pipe(scan(function (current, changes) {\n        return processDocumentChanges(current, changes, options.events);\n    }, []), distinctUntilChanged());\n}\n/**\n * Create a stream of changes as they occur it time. This method is similar\n * to docChanges() but it collects each event in an array over time.\n */\nfunction auditTrail(query, options) {\n    if (options === void 0) { options = {}; }\n    return collectionChanges(query, options).pipe(scan(function (current, action) { return __spreadArray(__spreadArray([], current), action); }, []));\n}\n/**\n * Returns a stream of documents mapped to their data payload, and optionally the document ID\n * @param query\n */\nfunction collectionData(query, options) {\n    if (options === void 0) { options = {}; }\n    return collection(query).pipe(map(function (arr) {\n        return arr.map(function (snap) { return snapToData(snap, options); });\n    }));\n}\n\nexport { auditTrail, collection, collectionChanges, collectionData, doc, docData, fromRef, snapToData, sortedChanges };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}