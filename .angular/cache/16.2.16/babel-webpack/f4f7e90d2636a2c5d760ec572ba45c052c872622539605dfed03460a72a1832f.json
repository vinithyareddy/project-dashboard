{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Version, isDevMode, inject, NgZone, Injectable, runInInjectionContext, PendingTasks, EnvironmentInjector } from '@angular/core';\nimport { getApps } from 'firebase/app';\nimport { pendingUntilEvent } from '@angular/core/rxjs-interop';\nimport { queueScheduler, asyncScheduler, Observable } from 'rxjs';\nimport { subscribeOn, observeOn } from 'rxjs/operators';\nconst VERSION = new Version('ANGULARFIRE2_VERSION');\nconst ɵisSupportedError = module => `The APP_INITIALIZER that is \"making\" isSupported() sync for the sake of convenient DI has not resolved in this\ncontext. Rather than injecting ${module} in the constructor, first ensure that ${module} is supported by calling\n\\`await isSupported()\\`, then retrieve the instance from the injector manually \\`injector.get(${module})\\`.`;\nfunction ɵgetDefaultInstanceOf(identifier, provided, defaultApp) {\n  if (provided) {\n    // Was provide* only called once? If so grab that\n    if (provided.length === 1) {\n      return provided[0];\n    }\n    const providedUsingDefaultApp = provided.filter(it => it.app === defaultApp);\n    // Was provide* only called once, using the default app? If so use that\n    if (providedUsingDefaultApp.length === 1) {\n      return providedUsingDefaultApp[0];\n    }\n  }\n  // Grab the default instance from the defaultApp\n  const defaultAppWithContainer = defaultApp;\n  const provider = defaultAppWithContainer.container.getProvider(identifier);\n  return provider.getImmediate({\n    optional: true\n  });\n}\nconst ɵgetAllInstancesOf = (identifier, app) => {\n  const apps = app ? [app] : getApps();\n  const instances = [];\n  apps.forEach(app => {\n    const provider = app.container.getProvider(identifier);\n    provider.instances.forEach(instance => {\n      if (!instances.includes(instance)) {\n        instances.push(instance);\n      }\n    });\n  });\n  return instances;\n};\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nvar LogLevel;\n(function (LogLevel) {\n  LogLevel[LogLevel[\"SILENT\"] = 0] = \"SILENT\";\n  LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n  LogLevel[LogLevel[\"VERBOSE\"] = 2] = \"VERBOSE\";\n})(LogLevel || (LogLevel = {}));\nvar currentLogLevel = isDevMode() && typeof Zone !== \"undefined\" ? LogLevel.WARN : LogLevel.SILENT;\nconst setLogLevel = logLevel => currentLogLevel = logLevel;\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\nclass ɵZoneScheduler {\n  zone;\n  delegate;\n  constructor(zone, delegate = queueScheduler) {\n    this.zone = zone;\n    this.delegate = delegate;\n  }\n  now() {\n    return this.delegate.now();\n  }\n  schedule(work, delay, state) {\n    const targetZone = this.zone;\n    // Wrap the specified work function to make sure that if nested scheduling takes place the\n    // work is executed in the correct zone\n    const workInZone = function (state) {\n      if (targetZone) {\n        targetZone.runGuarded(() => {\n          work.apply(this, [state]);\n        });\n      } else {\n        work.apply(this, [state]);\n      }\n    };\n    // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n    return this.delegate.schedule(workInZone, delay, state);\n  }\n}\nclass ɵAngularFireSchedulers {\n  outsideAngular;\n  insideAngular;\n  constructor() {\n    const ngZone = inject(NgZone);\n    this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(typeof Zone === 'undefined' ? undefined : Zone.current));\n    this.insideAngular = ngZone.run(() => new ɵZoneScheduler(typeof Zone === 'undefined' ? undefined : Zone.current, asyncScheduler));\n  }\n  static ɵfac = function ɵAngularFireSchedulers_Factory(t) {\n    return new (t || ɵAngularFireSchedulers)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ɵAngularFireSchedulers,\n    factory: ɵAngularFireSchedulers.ɵfac,\n    providedIn: 'root'\n  });\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ɵAngularFireSchedulers, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\nvar alreadyWarned = false;\nfunction warnOutsideInjectionContext(original, logLevel) {\n  if (!alreadyWarned && (currentLogLevel > LogLevel.SILENT || isDevMode())) {\n    alreadyWarned = true;\n    console.warn(\"Calling Firebase APIs outside of an Injection context may destabilize your application leading to subtle change-detection and hydration bugs. Find more at https://github.com/angular/angularfire/blob/main/docs/zones.md\");\n  }\n  if (currentLogLevel >= logLevel) {\n    console.warn(`Firebase API called outside injection context: ${original.name}`);\n  }\n}\nfunction runOutsideAngular(fn) {\n  const ngZone = inject(NgZone, {\n    optional: true\n  });\n  if (!ngZone) {\n    return fn();\n  }\n  return ngZone.runOutsideAngular(() => fn());\n}\nfunction run(fn) {\n  const ngZone = inject(NgZone, {\n    optional: true\n  });\n  if (!ngZone) {\n    return fn();\n  }\n  return ngZone.run(() => fn());\n}\nconst zoneWrapFn = (it, taskDone, injector) => {\n  return (...args) => {\n    if (taskDone) {\n      setTimeout(taskDone, 0);\n    }\n    return runInInjectionContext(injector, () => run(() => it.apply(this, args)));\n  };\n};\nconst ɵzoneWrap = (it, blockUntilFirst, logLevel) => {\n  logLevel ||= blockUntilFirst ? LogLevel.WARN : LogLevel.VERBOSE;\n  // function() is needed for the arguments object\n  return function () {\n    let taskDone;\n    const _arguments = arguments;\n    let schedulers;\n    let pendingTasks;\n    let injector;\n    try {\n      schedulers = inject(ɵAngularFireSchedulers);\n      pendingTasks = inject(PendingTasks);\n      injector = inject(EnvironmentInjector);\n    } catch (e) {\n      warnOutsideInjectionContext(it, logLevel);\n      return it.apply(this, _arguments);\n    }\n    // if this is a callback function, e.g, onSnapshot, we should create a pending task and complete it\n    // only once one of the callback functions is tripped.\n    for (let i = 0; i < arguments.length; i++) {\n      if (typeof _arguments[i] === 'function') {\n        if (blockUntilFirst) {\n          taskDone ||= run(() => pendingTasks.add());\n        }\n        // TODO create a microtask to track callback functions\n        _arguments[i] = zoneWrapFn(_arguments[i], taskDone, injector);\n      }\n    }\n    const ret = runOutsideAngular(() => it.apply(this, _arguments));\n    if (!blockUntilFirst) {\n      if (ret instanceof Observable) {\n        return ret.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      } else {\n        return run(() => ret);\n      }\n    }\n    if (ret instanceof Observable) {\n      return ret.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), pendingUntilEvent(injector));\n    } else if (ret instanceof Promise) {\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      return run(() => new Promise((resolve, reject) => {\n        pendingTasks.run(() => ret).then(it => runInInjectionContext(injector, () => run(() => resolve(it))), reason => runInInjectionContext(injector, () => run(() => reject(reason))));\n      }));\n    } else if (typeof ret === 'function' && taskDone) {\n      // Handle unsubscribe\n      // function() is needed for the arguments object\n      return function () {\n        setTimeout(taskDone, 0);\n        return ret.apply(this, arguments);\n      };\n    } else {\n      // TODO how do we handle storage uploads in Zone? and other stuff with cancel() etc?\n      return run(() => ret);\n    }\n  };\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LogLevel, VERSION, setLogLevel, ɵAngularFireSchedulers, ɵZoneScheduler, ɵgetAllInstancesOf, ɵgetDefaultInstanceOf, ɵisSupportedError, ɵzoneWrap };","map":{"version":3,"names":["i0","Version","isDevMode","inject","NgZone","Injectable","runInInjectionContext","PendingTasks","EnvironmentInjector","getApps","pendingUntilEvent","queueScheduler","asyncScheduler","Observable","subscribeOn","observeOn","VERSION","ɵisSupportedError","module","ɵgetDefaultInstanceOf","identifier","provided","defaultApp","length","providedUsingDefaultApp","filter","it","app","defaultAppWithContainer","provider","container","getProvider","getImmediate","optional","ɵgetAllInstancesOf","apps","instances","forEach","instance","includes","push","LogLevel","currentLogLevel","Zone","WARN","SILENT","setLogLevel","logLevel","ɵZoneScheduler","zone","delegate","constructor","now","schedule","work","delay","state","targetZone","workInZone","runGuarded","apply","ɵAngularFireSchedulers","outsideAngular","insideAngular","ngZone","runOutsideAngular","undefined","current","run","ɵfac","ɵAngularFireSchedulers_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","providedIn","ngDevMode","ɵsetClassMetadata","type","args","alreadyWarned","warnOutsideInjectionContext","original","console","warn","name","fn","zoneWrapFn","taskDone","injector","setTimeout","ɵzoneWrap","blockUntilFirst","VERBOSE","_arguments","arguments","schedulers","pendingTasks","e","i","add","ret","pipe","Promise","resolve","reject","then","reason"],"sources":["/Users/vinithyareddy/Desktop/projects/my github projects/project-dashboard/node_modules/@angular/fire/fesm2022/angular-fire.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Version, isDevMode, inject, NgZone, Injectable, runInInjectionContext, PendingTasks, EnvironmentInjector } from '@angular/core';\nimport { getApps } from 'firebase/app';\nimport { pendingUntilEvent } from '@angular/core/rxjs-interop';\nimport { queueScheduler, asyncScheduler, Observable } from 'rxjs';\nimport { subscribeOn, observeOn } from 'rxjs/operators';\n\nconst VERSION = new Version('ANGULARFIRE2_VERSION');\nconst ɵisSupportedError = (module) => `The APP_INITIALIZER that is \"making\" isSupported() sync for the sake of convenient DI has not resolved in this\ncontext. Rather than injecting ${module} in the constructor, first ensure that ${module} is supported by calling\n\\`await isSupported()\\`, then retrieve the instance from the injector manually \\`injector.get(${module})\\`.`;\nfunction ɵgetDefaultInstanceOf(identifier, provided, defaultApp) {\n    if (provided) {\n        // Was provide* only called once? If so grab that\n        if (provided.length === 1) {\n            return provided[0];\n        }\n        const providedUsingDefaultApp = provided.filter((it) => it.app === defaultApp);\n        // Was provide* only called once, using the default app? If so use that\n        if (providedUsingDefaultApp.length === 1) {\n            return providedUsingDefaultApp[0];\n        }\n    }\n    // Grab the default instance from the defaultApp\n    const defaultAppWithContainer = defaultApp;\n    const provider = defaultAppWithContainer.container.getProvider(identifier);\n    return provider.getImmediate({ optional: true });\n}\nconst ɵgetAllInstancesOf = (identifier, app) => {\n    const apps = app ? [app] : getApps();\n    const instances = [];\n    apps.forEach((app) => {\n        const provider = app.container.getProvider(identifier);\n        provider.instances.forEach((instance) => {\n            if (!instances.includes(instance)) {\n                instances.push(instance);\n            }\n        });\n    });\n    return instances;\n};\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"SILENT\"] = 0] = \"SILENT\";\n    LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n    LogLevel[LogLevel[\"VERBOSE\"] = 2] = \"VERBOSE\";\n})(LogLevel || (LogLevel = {}));\nvar currentLogLevel = (isDevMode() && typeof Zone !== \"undefined\") ? LogLevel.WARN : LogLevel.SILENT;\nconst setLogLevel = (logLevel) => currentLogLevel = logLevel;\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\nclass ɵZoneScheduler {\n    zone;\n    delegate;\n    constructor(zone, delegate = queueScheduler) {\n        this.zone = zone;\n        this.delegate = delegate;\n    }\n    now() {\n        return this.delegate.now();\n    }\n    schedule(work, delay, state) {\n        const targetZone = this.zone;\n        // Wrap the specified work function to make sure that if nested scheduling takes place the\n        // work is executed in the correct zone\n        const workInZone = function (state) {\n            if (targetZone) {\n                targetZone.runGuarded(() => {\n                    work.apply(this, [state]);\n                });\n            }\n            else {\n                work.apply(this, [state]);\n            }\n        };\n        // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n        // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n        // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n        return this.delegate.schedule(workInZone, delay, state);\n    }\n}\nclass ɵAngularFireSchedulers {\n    outsideAngular;\n    insideAngular;\n    constructor() {\n        const ngZone = inject(NgZone);\n        this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(typeof Zone === 'undefined' ? undefined : Zone.current));\n        this.insideAngular = ngZone.run(() => new ɵZoneScheduler(typeof Zone === 'undefined' ? undefined : Zone.current, asyncScheduler));\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.0.0\", ngImport: i0, type: ɵAngularFireSchedulers, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"19.0.0\", ngImport: i0, type: ɵAngularFireSchedulers, providedIn: 'root' });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.0.0\", ngImport: i0, type: ɵAngularFireSchedulers, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root',\n                }]\n        }], ctorParameters: () => [] });\nvar alreadyWarned = false;\nfunction warnOutsideInjectionContext(original, logLevel) {\n    if (!alreadyWarned && (currentLogLevel > LogLevel.SILENT || isDevMode())) {\n        alreadyWarned = true;\n        console.warn(\"Calling Firebase APIs outside of an Injection context may destabilize your application leading to subtle change-detection and hydration bugs. Find more at https://github.com/angular/angularfire/blob/main/docs/zones.md\");\n    }\n    if (currentLogLevel >= logLevel) {\n        console.warn(`Firebase API called outside injection context: ${original.name}`);\n    }\n}\nfunction runOutsideAngular(fn) {\n    const ngZone = inject(NgZone, { optional: true });\n    if (!ngZone) {\n        return fn();\n    }\n    return ngZone.runOutsideAngular(() => fn());\n}\nfunction run(fn) {\n    const ngZone = inject(NgZone, { optional: true });\n    if (!ngZone) {\n        return fn();\n    }\n    return ngZone.run(() => fn());\n}\nconst zoneWrapFn = (it, taskDone, injector) => {\n    return (...args) => {\n        if (taskDone) {\n            setTimeout(taskDone, 0);\n        }\n        return runInInjectionContext(injector, () => run(() => it.apply(this, args)));\n    };\n};\nconst ɵzoneWrap = (it, blockUntilFirst, logLevel) => {\n    logLevel ||= blockUntilFirst ? LogLevel.WARN : LogLevel.VERBOSE;\n    // function() is needed for the arguments object\n    return function () {\n        let taskDone;\n        const _arguments = arguments;\n        let schedulers;\n        let pendingTasks;\n        let injector;\n        try {\n            schedulers = inject(ɵAngularFireSchedulers);\n            pendingTasks = inject(PendingTasks);\n            injector = inject(EnvironmentInjector);\n        }\n        catch (e) {\n            warnOutsideInjectionContext(it, logLevel);\n            return it.apply(this, _arguments);\n        }\n        // if this is a callback function, e.g, onSnapshot, we should create a pending task and complete it\n        // only once one of the callback functions is tripped.\n        for (let i = 0; i < arguments.length; i++) {\n            if (typeof _arguments[i] === 'function') {\n                if (blockUntilFirst) {\n                    taskDone ||= run(() => pendingTasks.add());\n                }\n                // TODO create a microtask to track callback functions\n                _arguments[i] = zoneWrapFn(_arguments[i], taskDone, injector);\n            }\n        }\n        const ret = runOutsideAngular(() => it.apply(this, _arguments));\n        if (!blockUntilFirst) {\n            if (ret instanceof Observable) {\n                return ret.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n            }\n            else {\n                return run(() => ret);\n            }\n        }\n        if (ret instanceof Observable) {\n            return ret.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), pendingUntilEvent(injector));\n        }\n        else if (ret instanceof Promise) {\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            return run(() => new Promise((resolve, reject) => {\n                pendingTasks.run(() => ret).then((it) => runInInjectionContext(injector, () => run(() => resolve(it))), (reason) => runInInjectionContext(injector, () => run(() => reject(reason))));\n            }));\n        }\n        else if (typeof ret === 'function' && taskDone) {\n            // Handle unsubscribe\n            // function() is needed for the arguments object\n            return function () {\n                setTimeout(taskDone, 0);\n                return ret.apply(this, arguments);\n            };\n        }\n        else {\n            // TODO how do we handle storage uploads in Zone? and other stuff with cancel() etc?\n            return run(() => ret);\n        }\n    };\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LogLevel, VERSION, setLogLevel, ɵAngularFireSchedulers, ɵZoneScheduler, ɵgetAllInstancesOf, ɵgetDefaultInstanceOf, ɵisSupportedError, ɵzoneWrap };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}