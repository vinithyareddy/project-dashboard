{"ast":null,"code":"import _asyncToGenerator from \"/Users/vinithyareddy/Desktop/projects/my github projects/project-dashboard/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Component } from '@firebase/component';\nimport { Deferred, ErrorFactory, isIndexedDBAvailable, getGlobal, base64, issuedAtTime, calculateBackoffMillis, getModularInstance } from '@firebase/util';\nimport { Logger } from '@firebase/logger';\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst APP_CHECK_STATES = new Map();\nconst DEFAULT_STATE = {\n  activated: false,\n  tokenObservers: []\n};\nconst DEBUG_STATE = {\n  initialized: false,\n  enabled: false\n};\n/**\n * Gets a reference to the state object.\n */\nfunction getStateReference(app) {\n  return APP_CHECK_STATES.get(app) || Object.assign({}, DEFAULT_STATE);\n}\n/**\n * Set once on initialization. The map should hold the same reference to the\n * same object until this entry is deleted.\n */\nfunction setInitialState(app, state) {\n  APP_CHECK_STATES.set(app, state);\n  return APP_CHECK_STATES.get(app);\n}\nfunction getDebugState() {\n  return DEBUG_STATE;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst BASE_ENDPOINT = 'https://content-firebaseappcheck.googleapis.com/v1';\nconst EXCHANGE_RECAPTCHA_TOKEN_METHOD = 'exchangeRecaptchaV3Token';\nconst EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD = 'exchangeRecaptchaEnterpriseToken';\nconst EXCHANGE_DEBUG_TOKEN_METHOD = 'exchangeDebugToken';\nconst TOKEN_REFRESH_TIME = {\n  /**\n   * The offset time before token natural expiration to run the refresh.\n   * This is currently 5 minutes.\n   */\n  OFFSET_DURATION: 5 * 60 * 1000,\n  /**\n   * This is the first retrial wait after an error. This is currently\n   * 30 seconds.\n   */\n  RETRIAL_MIN_WAIT: 30 * 1000,\n  /**\n   * This is the maximum retrial wait, currently 16 minutes.\n   */\n  RETRIAL_MAX_WAIT: 16 * 60 * 1000\n};\n/**\n * One day in millis, for certain error code backoffs.\n */\nconst ONE_DAY = 24 * 60 * 60 * 1000;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Port from auth proactiverefresh.js\n *\n */\n// TODO: move it to @firebase/util?\n// TODO: allow to config whether refresh should happen in the background\nclass Refresher {\n  constructor(operation, retryPolicy, getWaitDuration, lowerBound, upperBound) {\n    this.operation = operation;\n    this.retryPolicy = retryPolicy;\n    this.getWaitDuration = getWaitDuration;\n    this.lowerBound = lowerBound;\n    this.upperBound = upperBound;\n    this.pending = null;\n    this.nextErrorWaitInterval = lowerBound;\n    if (lowerBound > upperBound) {\n      throw new Error('Proactive refresh lower bound greater than upper bound!');\n    }\n  }\n  start() {\n    this.nextErrorWaitInterval = this.lowerBound;\n    this.process(true).catch(() => {\n      /* we don't care about the result */\n    });\n  }\n  stop() {\n    if (this.pending) {\n      this.pending.reject('cancelled');\n      this.pending = null;\n    }\n  }\n  isRunning() {\n    return !!this.pending;\n  }\n  process(hasSucceeded) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.stop();\n      try {\n        _this.pending = new Deferred();\n        _this.pending.promise.catch(_e => {\n          /* ignore */\n        });\n        yield sleep(_this.getNextRun(hasSucceeded));\n        // Why do we resolve a promise, then immediate wait for it?\n        // We do it to make the promise chain cancellable.\n        // We can call stop() which rejects the promise before the following line execute, which makes\n        // the code jump to the catch block.\n        // TODO: unit test this\n        _this.pending.resolve();\n        yield _this.pending.promise;\n        _this.pending = new Deferred();\n        _this.pending.promise.catch(_e => {\n          /* ignore */\n        });\n        yield _this.operation();\n        _this.pending.resolve();\n        yield _this.pending.promise;\n        _this.process(true).catch(() => {\n          /* we don't care about the result */\n        });\n      } catch (error) {\n        if (_this.retryPolicy(error)) {\n          _this.process(false).catch(() => {\n            /* we don't care about the result */\n          });\n        } else {\n          _this.stop();\n        }\n      }\n    })();\n  }\n  getNextRun(hasSucceeded) {\n    if (hasSucceeded) {\n      // If last operation succeeded, reset next error wait interval and return\n      // the default wait duration.\n      this.nextErrorWaitInterval = this.lowerBound;\n      // Return typical wait duration interval after a successful operation.\n      return this.getWaitDuration();\n    } else {\n      // Get next error wait interval.\n      const currentErrorWaitInterval = this.nextErrorWaitInterval;\n      // Double interval for next consecutive error.\n      this.nextErrorWaitInterval *= 2;\n      // Make sure next wait interval does not exceed the maximum upper bound.\n      if (this.nextErrorWaitInterval > this.upperBound) {\n        this.nextErrorWaitInterval = this.upperBound;\n      }\n      return currentErrorWaitInterval;\n    }\n  }\n}\nfunction sleep(ms) {\n  return new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst ERRORS = {\n  [\"already-initialized\" /* AppCheckError.ALREADY_INITIALIZED */]: 'You have already called initializeAppCheck() for FirebaseApp {$appName} with ' + 'different options. To avoid this error, call initializeAppCheck() with the ' + 'same options as when it was originally called. This will return the ' + 'already initialized instance.',\n  [\"use-before-activation\" /* AppCheckError.USE_BEFORE_ACTIVATION */]: 'App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. ' + 'Call initializeAppCheck() before instantiating other Firebase services.',\n  [\"fetch-network-error\" /* AppCheckError.FETCH_NETWORK_ERROR */]: 'Fetch failed to connect to a network. Check Internet connection. ' + 'Original error: {$originalErrorMessage}.',\n  [\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */]: 'Fetch client could not parse response.' + ' Original error: {$originalErrorMessage}.',\n  [\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */]: 'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',\n  [\"storage-open\" /* AppCheckError.STORAGE_OPEN */]: 'Error thrown when opening storage. Original error: {$originalErrorMessage}.',\n  [\"storage-get\" /* AppCheckError.STORAGE_GET */]: 'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',\n  [\"storage-set\" /* AppCheckError.STORAGE_WRITE */]: 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',\n  [\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */]: 'ReCAPTCHA error.',\n  [\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */]: `{$httpStatus} error. Attempts allowed again after {$time}`,\n  [\"throttled\" /* AppCheckError.THROTTLED */]: `Requests throttled due to previous {$httpStatus} error. Attempts allowed again after {$time}`\n};\nconst ERROR_FACTORY = new ErrorFactory('appCheck', 'AppCheck', ERRORS);\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getRecaptcha(isEnterprise = false) {\n  var _a;\n  if (isEnterprise) {\n    return (_a = self.grecaptcha) === null || _a === void 0 ? void 0 : _a.enterprise;\n  }\n  return self.grecaptcha;\n}\nfunction ensureActivated(app) {\n  if (!getStateReference(app).activated) {\n    throw ERROR_FACTORY.create(\"use-before-activation\" /* AppCheckError.USE_BEFORE_ACTIVATION */, {\n      appName: app.name\n    });\n  }\n}\nfunction getDurationString(durationInMillis) {\n  const totalSeconds = Math.round(durationInMillis / 1000);\n  const days = Math.floor(totalSeconds / (3600 * 24));\n  const hours = Math.floor((totalSeconds - days * 3600 * 24) / 3600);\n  const minutes = Math.floor((totalSeconds - days * 3600 * 24 - hours * 3600) / 60);\n  const seconds = totalSeconds - days * 3600 * 24 - hours * 3600 - minutes * 60;\n  let result = '';\n  if (days) {\n    result += pad(days) + 'd:';\n  }\n  if (hours) {\n    result += pad(hours) + 'h:';\n  }\n  result += pad(minutes) + 'm:' + pad(seconds) + 's';\n  return result;\n}\nfunction pad(value) {\n  if (value === 0) {\n    return '00';\n  }\n  return value >= 10 ? value.toString() : '0' + value;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction exchangeToken(_x, _x2) {\n  return _exchangeToken.apply(this, arguments);\n}\nfunction _exchangeToken() {\n  _exchangeToken = _asyncToGenerator(function* ({\n    url,\n    body\n  }, heartbeatServiceProvider) {\n    const headers = {\n      'Content-Type': 'application/json'\n    };\n    // If heartbeat service exists, add heartbeat header string to the header.\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\n      optional: true\n    });\n    if (heartbeatService) {\n      const heartbeatsHeader = yield heartbeatService.getHeartbeatsHeader();\n      if (heartbeatsHeader) {\n        headers['X-Firebase-Client'] = heartbeatsHeader;\n      }\n    }\n    const options = {\n      method: 'POST',\n      body: JSON.stringify(body),\n      headers\n    };\n    let response;\n    try {\n      response = yield fetch(url, options);\n    } catch (originalError) {\n      throw ERROR_FACTORY.create(\"fetch-network-error\" /* AppCheckError.FETCH_NETWORK_ERROR */, {\n        originalErrorMessage: originalError === null || originalError === void 0 ? void 0 : originalError.message\n      });\n    }\n    if (response.status !== 200) {\n      throw ERROR_FACTORY.create(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */, {\n        httpStatus: response.status\n      });\n    }\n    let responseBody;\n    try {\n      // JSON parsing throws SyntaxError if the response body isn't a JSON string.\n      responseBody = yield response.json();\n    } catch (originalError) {\n      throw ERROR_FACTORY.create(\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */, {\n        originalErrorMessage: originalError === null || originalError === void 0 ? void 0 : originalError.message\n      });\n    }\n    // Protobuf duration format.\n    // https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Duration\n    const match = responseBody.ttl.match(/^([\\d.]+)(s)$/);\n    if (!match || !match[2] || isNaN(Number(match[1]))) {\n      throw ERROR_FACTORY.create(\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */, {\n        originalErrorMessage: `ttl field (timeToLive) is not in standard Protobuf Duration ` + `format: ${responseBody.ttl}`\n      });\n    }\n    const timeToLiveAsNumber = Number(match[1]) * 1000;\n    const now = Date.now();\n    return {\n      token: responseBody.token,\n      expireTimeMillis: now + timeToLiveAsNumber,\n      issuedAtTimeMillis: now\n    };\n  });\n  return _exchangeToken.apply(this, arguments);\n}\nfunction getExchangeRecaptchaV3TokenRequest(app, reCAPTCHAToken) {\n  const {\n    projectId,\n    appId,\n    apiKey\n  } = app.options;\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      'recaptcha_v3_token': reCAPTCHAToken\n    }\n  };\n}\nfunction getExchangeRecaptchaEnterpriseTokenRequest(app, reCAPTCHAToken) {\n  const {\n    projectId,\n    appId,\n    apiKey\n  } = app.options;\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      'recaptcha_enterprise_token': reCAPTCHAToken\n    }\n  };\n}\nfunction getExchangeDebugTokenRequest(app, debugToken) {\n  const {\n    projectId,\n    appId,\n    apiKey\n  } = app.options;\n  return {\n    url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_DEBUG_TOKEN_METHOD}?key=${apiKey}`,\n    body: {\n      // eslint-disable-next-line\n      debug_token: debugToken\n    }\n  };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DB_NAME = 'firebase-app-check-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-app-check-store';\nconst DEBUG_TOKEN_KEY = 'debug-token';\nlet dbPromise = null;\nfunction getDBPromise() {\n  if (dbPromise) {\n    return dbPromise;\n  }\n  dbPromise = new Promise((resolve, reject) => {\n    try {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      request.onsuccess = event => {\n        resolve(event.target.result);\n      };\n      request.onerror = event => {\n        var _a;\n        reject(ERROR_FACTORY.create(\"storage-open\" /* AppCheckError.STORAGE_OPEN */, {\n          originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n        }));\n      };\n      request.onupgradeneeded = event => {\n        const db = event.target.result;\n        // We don't use 'break' in this switch statement, the fall-through\n        // behavior is what we want, because if there are multiple versions between\n        // the old version and the current version, we want ALL the migrations\n        // that correspond to those versions to run, not only the last one.\n        // eslint-disable-next-line default-case\n        switch (event.oldVersion) {\n          case 0:\n            db.createObjectStore(STORE_NAME, {\n              keyPath: 'compositeKey'\n            });\n        }\n      };\n    } catch (e) {\n      reject(ERROR_FACTORY.create(\"storage-open\" /* AppCheckError.STORAGE_OPEN */, {\n        originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n      }));\n    }\n  });\n  return dbPromise;\n}\nfunction readTokenFromIndexedDB(app) {\n  return read(computeKey(app));\n}\nfunction writeTokenToIndexedDB(app, token) {\n  return write(computeKey(app), token);\n}\nfunction writeDebugTokenToIndexedDB(token) {\n  return write(DEBUG_TOKEN_KEY, token);\n}\nfunction readDebugTokenFromIndexedDB() {\n  return read(DEBUG_TOKEN_KEY);\n}\nfunction write(_x3, _x4) {\n  return _write.apply(this, arguments);\n}\nfunction _write() {\n  _write = _asyncToGenerator(function* (key, value) {\n    const db = yield getDBPromise();\n    const transaction = db.transaction(STORE_NAME, 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.put({\n      compositeKey: key,\n      value\n    });\n    return new Promise((resolve, reject) => {\n      request.onsuccess = _event => {\n        resolve();\n      };\n      transaction.onerror = event => {\n        var _a;\n        reject(ERROR_FACTORY.create(\"storage-set\" /* AppCheckError.STORAGE_WRITE */, {\n          originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n        }));\n      };\n    });\n  });\n  return _write.apply(this, arguments);\n}\nfunction read(_x5) {\n  return _read.apply(this, arguments);\n}\nfunction _read() {\n  _read = _asyncToGenerator(function* (key) {\n    const db = yield getDBPromise();\n    const transaction = db.transaction(STORE_NAME, 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.get(key);\n    return new Promise((resolve, reject) => {\n      request.onsuccess = event => {\n        const result = event.target.result;\n        if (result) {\n          resolve(result.value);\n        } else {\n          resolve(undefined);\n        }\n      };\n      transaction.onerror = event => {\n        var _a;\n        reject(ERROR_FACTORY.create(\"storage-get\" /* AppCheckError.STORAGE_GET */, {\n          originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n        }));\n      };\n    });\n  });\n  return _read.apply(this, arguments);\n}\nfunction computeKey(app) {\n  return `${app.options.appId}-${app.name}`;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logger = new Logger('@firebase/app-check');\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Always resolves. In case of an error reading from indexeddb, resolve with undefined\n */\nfunction readTokenFromStorage(_x6) {\n  return _readTokenFromStorage.apply(this, arguments);\n}\n/**\n * Always resolves. In case of an error writing to indexeddb, print a warning and resolve the promise\n */\nfunction _readTokenFromStorage() {\n  _readTokenFromStorage = _asyncToGenerator(function* (app) {\n    if (isIndexedDBAvailable()) {\n      let token = undefined;\n      try {\n        token = yield readTokenFromIndexedDB(app);\n      } catch (e) {\n        // swallow the error and return undefined\n        logger.warn(`Failed to read token from IndexedDB. Error: ${e}`);\n      }\n      return token;\n    }\n    return undefined;\n  });\n  return _readTokenFromStorage.apply(this, arguments);\n}\nfunction writeTokenToStorage(app, token) {\n  if (isIndexedDBAvailable()) {\n    return writeTokenToIndexedDB(app, token).catch(e => {\n      // swallow the error and resolve the promise\n      logger.warn(`Failed to write token to IndexedDB. Error: ${e}`);\n    });\n  }\n  return Promise.resolve();\n}\nfunction readOrCreateDebugTokenFromStorage() {\n  return _readOrCreateDebugTokenFromStorage.apply(this, arguments);\n}\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction _readOrCreateDebugTokenFromStorage() {\n  _readOrCreateDebugTokenFromStorage = _asyncToGenerator(function* () {\n    /**\n     * Theoretically race condition can happen if we read, then write in 2 separate transactions.\n     * But it won't happen here, because this function will be called exactly once.\n     */\n    let existingDebugToken = undefined;\n    try {\n      existingDebugToken = yield readDebugTokenFromIndexedDB();\n    } catch (_e) {\n      // failed to read from indexeddb. We assume there is no existing debug token, and generate a new one.\n    }\n    if (!existingDebugToken) {\n      // create a new debug token\n      // This function is only available in secure contexts. See https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts\n      const newToken = crypto.randomUUID();\n      // We don't need to block on writing to indexeddb\n      // In case persistence failed, a new debug token will be generated every time the page is refreshed.\n      // It renders the debug token useless because you have to manually register(whitelist) the new token in the firebase console again and again.\n      // If you see this error trying to use debug token, it probably means you are using a browser that doesn't support indexeddb.\n      // You should switch to a different browser that supports indexeddb\n      writeDebugTokenToIndexedDB(newToken).catch(e => logger.warn(`Failed to persist debug token to IndexedDB. Error: ${e}`));\n      return newToken;\n    } else {\n      return existingDebugToken;\n    }\n  });\n  return _readOrCreateDebugTokenFromStorage.apply(this, arguments);\n}\nfunction isDebugMode() {\n  const debugState = getDebugState();\n  return debugState.enabled;\n}\nfunction getDebugToken() {\n  return _getDebugToken.apply(this, arguments);\n}\nfunction _getDebugToken() {\n  _getDebugToken = _asyncToGenerator(function* () {\n    const state = getDebugState();\n    if (state.enabled && state.token) {\n      return state.token.promise;\n    } else {\n      // should not happen!\n      throw Error(`\n            Can't get debug token in production mode.\n        `);\n    }\n  });\n  return _getDebugToken.apply(this, arguments);\n}\nfunction initializeDebugMode() {\n  const globals = getGlobal();\n  const debugState = getDebugState();\n  // Set to true if this function has been called, whether or not\n  // it enabled debug mode.\n  debugState.initialized = true;\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== 'string' && globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true) {\n    return;\n  }\n  debugState.enabled = true;\n  const deferredToken = new Deferred();\n  debugState.token = deferredToken;\n  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === 'string') {\n    deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);\n  } else {\n    deferredToken.resolve(readOrCreateDebugTokenFromStorage());\n  }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Initial hardcoded value agreed upon across platforms for initial launch.\n// Format left open for possible dynamic error values and other fields in the future.\nconst defaultTokenErrorData = {\n  error: 'UNKNOWN_ERROR'\n};\n/**\n * Stringify and base64 encode token error data.\n *\n * @param tokenError Error data, currently hardcoded.\n */\nfunction formatDummyToken(tokenErrorData) {\n  return base64.encodeString(JSON.stringify(tokenErrorData), /* webSafe= */false);\n}\n/**\n * This function always resolves.\n * The result will contain an error field if there is any error.\n * In case there is an error, the token field in the result will be populated with a dummy value\n */\nfunction getToken$2(_x7) {\n  return _getToken$.apply(this, arguments);\n}\n/**\n * Internal API for limited use tokens. Skips all FAC state and simply calls\n * the underlying provider.\n */\nfunction _getToken$() {\n  _getToken$ = _asyncToGenerator(function* (appCheck, forceRefresh = false, shouldLogErrors = false) {\n    const app = appCheck.app;\n    ensureActivated(app);\n    const state = getStateReference(app);\n    /**\n     * First check if there is a token in memory from a previous `getToken()` call.\n     */\n    let token = state.token;\n    let error = undefined;\n    /**\n     * If an invalid token was found in memory, clear token from\n     * memory and unset the local variable `token`.\n     */\n    if (token && !isValid(token)) {\n      state.token = undefined;\n      token = undefined;\n    }\n    /**\n     * If there is no valid token in memory, try to load token from indexedDB.\n     */\n    if (!token) {\n      // cachedTokenPromise contains the token found in IndexedDB or undefined if not found.\n      const cachedToken = yield state.cachedTokenPromise;\n      if (cachedToken) {\n        if (isValid(cachedToken)) {\n          token = cachedToken;\n        } else {\n          // If there was an invalid token in the indexedDB cache, clear it.\n          yield writeTokenToStorage(app, undefined);\n        }\n      }\n    }\n    // Return the cached token (from either memory or indexedDB) if it's valid\n    if (!forceRefresh && token && isValid(token)) {\n      return {\n        token: token.token\n      };\n    }\n    // Only set to true if this `getToken()` call is making the actual\n    // REST call to the exchange endpoint, versus waiting for an already\n    // in-flight call (see debug and regular exchange endpoint paths below)\n    let shouldCallListeners = false;\n    /**\n     * DEBUG MODE\n     * If debug mode is set, and there is no cached token, fetch a new App\n     * Check token using the debug token, and return it directly.\n     */\n    if (isDebugMode()) {\n      try {\n        // Avoid making another call to the exchange endpoint if one is in flight.\n        if (!state.exchangeTokenPromise) {\n          state.exchangeTokenPromise = exchangeToken(getExchangeDebugTokenRequest(app, yield getDebugToken()), appCheck.heartbeatServiceProvider).finally(() => {\n            // Clear promise when settled - either resolved or rejected.\n            state.exchangeTokenPromise = undefined;\n          });\n          shouldCallListeners = true;\n        }\n        const tokenFromDebugExchange = yield state.exchangeTokenPromise;\n        // Write debug token to indexedDB.\n        yield writeTokenToStorage(app, tokenFromDebugExchange);\n        // Write debug token to state.\n        state.token = tokenFromDebugExchange;\n        return {\n          token: tokenFromDebugExchange.token\n        };\n      } catch (e) {\n        if (e.code === `appCheck/${\"throttled\" /* AppCheckError.THROTTLED */}` || e.code === `appCheck/${\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */}`) {\n          // Warn if throttled, but do not treat it as an error.\n          logger.warn(e.message);\n        } else if (shouldLogErrors) {\n          logger.error(e);\n        }\n        // Return dummy token and error\n        return makeDummyTokenResult(e);\n      }\n    }\n    /**\n     * There are no valid tokens in memory or indexedDB and we are not in\n     * debug mode.\n     * Request a new token from the exchange endpoint.\n     */\n    try {\n      // Avoid making another call to the exchange endpoint if one is in flight.\n      if (!state.exchangeTokenPromise) {\n        // state.provider is populated in initializeAppCheck()\n        // ensureActivated() at the top of this function checks that\n        // initializeAppCheck() has been called.\n        state.exchangeTokenPromise = state.provider.getToken().finally(() => {\n          // Clear promise when settled - either resolved or rejected.\n          state.exchangeTokenPromise = undefined;\n        });\n        shouldCallListeners = true;\n      }\n      token = yield getStateReference(app).exchangeTokenPromise;\n    } catch (e) {\n      if (e.code === `appCheck/${\"throttled\" /* AppCheckError.THROTTLED */}` || e.code === `appCheck/${\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */}`) {\n        // Warn if throttled, but do not treat it as an error.\n        logger.warn(e.message);\n      } else if (shouldLogErrors) {\n        logger.error(e);\n      }\n      // Always save error to be added to dummy token.\n      error = e;\n    }\n    let interopTokenResult;\n    if (!token) {\n      // If token is undefined, there must be an error.\n      // Return a dummy token along with the error.\n      interopTokenResult = makeDummyTokenResult(error);\n    } else if (error) {\n      if (isValid(token)) {\n        // It's also possible a valid token exists, but there's also an error.\n        // (Such as if the token is almost expired, tries to refresh, and\n        // the exchange request fails.)\n        // We add a special error property here so that the refresher will\n        // count this as a failed attempt and use the backoff instead of\n        // retrying repeatedly with no delay, but any 3P listeners will not\n        // be hindered in getting the still-valid token.\n        interopTokenResult = {\n          token: token.token,\n          internalError: error\n        };\n      } else {\n        // No invalid tokens should make it to this step. Memory and cached tokens\n        // are checked. Other tokens are from fresh exchanges. But just in case.\n        interopTokenResult = makeDummyTokenResult(error);\n      }\n    } else {\n      interopTokenResult = {\n        token: token.token\n      };\n      // write the new token to the memory state as well as the persistent storage.\n      // Only do it if we got a valid new token\n      state.token = token;\n      yield writeTokenToStorage(app, token);\n    }\n    if (shouldCallListeners) {\n      notifyTokenListeners(app, interopTokenResult);\n    }\n    return interopTokenResult;\n  });\n  return _getToken$.apply(this, arguments);\n}\nfunction getLimitedUseToken$1(_x8) {\n  return _getLimitedUseToken$.apply(this, arguments);\n}\nfunction _getLimitedUseToken$() {\n  _getLimitedUseToken$ = _asyncToGenerator(function* (appCheck) {\n    const app = appCheck.app;\n    ensureActivated(app);\n    const {\n      provider\n    } = getStateReference(app);\n    if (isDebugMode()) {\n      const debugToken = yield getDebugToken();\n      const {\n        token\n      } = yield exchangeToken(getExchangeDebugTokenRequest(app, debugToken), appCheck.heartbeatServiceProvider);\n      return {\n        token\n      };\n    } else {\n      // provider is definitely valid since we ensure AppCheck was activated\n      const {\n        token\n      } = yield provider.getToken();\n      return {\n        token\n      };\n    }\n  });\n  return _getLimitedUseToken$.apply(this, arguments);\n}\nfunction addTokenListener(appCheck, type, listener, onError) {\n  const {\n    app\n  } = appCheck;\n  const state = getStateReference(app);\n  const tokenObserver = {\n    next: listener,\n    error: onError,\n    type\n  };\n  state.tokenObservers = [...state.tokenObservers, tokenObserver];\n  // Invoke the listener async immediately if there is a valid token\n  // in memory.\n  if (state.token && isValid(state.token)) {\n    const validToken = state.token;\n    Promise.resolve().then(() => {\n      listener({\n        token: validToken.token\n      });\n      initTokenRefresher(appCheck);\n    }).catch(() => {\n      /* we don't care about exceptions thrown in listeners */\n    });\n  }\n  /**\n   * Wait for any cached token promise to resolve before starting the token\n   * refresher. The refresher checks to see if there is an existing token\n   * in state and calls the exchange endpoint if not. We should first let the\n   * IndexedDB check have a chance to populate state if it can.\n   *\n   * Listener call isn't needed here because cachedTokenPromise will call any\n   * listeners that exist when it resolves.\n   */\n  // state.cachedTokenPromise is always populated in `activate()`.\n  void state.cachedTokenPromise.then(() => initTokenRefresher(appCheck));\n}\nfunction removeTokenListener(app, listener) {\n  const state = getStateReference(app);\n  const newObservers = state.tokenObservers.filter(tokenObserver => tokenObserver.next !== listener);\n  if (newObservers.length === 0 && state.tokenRefresher && state.tokenRefresher.isRunning()) {\n    state.tokenRefresher.stop();\n  }\n  state.tokenObservers = newObservers;\n}\n/**\n * Logic to create and start refresher as needed.\n */\nfunction initTokenRefresher(appCheck) {\n  const {\n    app\n  } = appCheck;\n  const state = getStateReference(app);\n  // Create the refresher but don't start it if `isTokenAutoRefreshEnabled`\n  // is not true.\n  let refresher = state.tokenRefresher;\n  if (!refresher) {\n    refresher = createTokenRefresher(appCheck);\n    state.tokenRefresher = refresher;\n  }\n  if (!refresher.isRunning() && state.isTokenAutoRefreshEnabled) {\n    refresher.start();\n  }\n}\nfunction createTokenRefresher(appCheck) {\n  const {\n    app\n  } = appCheck;\n  return new Refresher(\n  /*#__PURE__*/\n  // Keep in mind when this fails for any reason other than the ones\n  // for which we should retry, it will effectively stop the proactive refresh.\n  _asyncToGenerator(function* () {\n    const state = getStateReference(app);\n    // If there is no token, we will try to load it from storage and use it\n    // If there is a token, we force refresh it because we know it's going to expire soon\n    let result;\n    if (!state.token) {\n      result = yield getToken$2(appCheck);\n    } else {\n      result = yield getToken$2(appCheck, true);\n    }\n    /**\n     * getToken() always resolves. In case the result has an error field defined, it means\n     * the operation failed, and we should retry.\n     */\n    if (result.error) {\n      throw result.error;\n    }\n    /**\n     * A special `internalError` field reflects that there was an error\n     * getting a new token from the exchange endpoint, but there's still a\n     * previous token that's valid for now and this should be passed to 2P/3P\n     * requests for a token. But we want this callback (`this.operation` in\n     * `Refresher`) to throw in order to kick off the Refresher's retry\n     * backoff. (Setting `hasSucceeded` to false.)\n     */\n    if (result.internalError) {\n      throw result.internalError;\n    }\n  }), () => {\n    return true;\n  }, () => {\n    const state = getStateReference(app);\n    if (state.token) {\n      // issuedAtTime + (50% * total TTL) + 5 minutes\n      let nextRefreshTimeMillis = state.token.issuedAtTimeMillis + (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) * 0.5 + 5 * 60 * 1000;\n      // Do not allow refresh time to be past (expireTime - 5 minutes)\n      const latestAllowableRefresh = state.token.expireTimeMillis - 5 * 60 * 1000;\n      nextRefreshTimeMillis = Math.min(nextRefreshTimeMillis, latestAllowableRefresh);\n      return Math.max(0, nextRefreshTimeMillis - Date.now());\n    } else {\n      return 0;\n    }\n  }, TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT, TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT);\n}\nfunction notifyTokenListeners(app, token) {\n  const observers = getStateReference(app).tokenObservers;\n  for (const observer of observers) {\n    try {\n      if (observer.type === \"EXTERNAL\" /* ListenerType.EXTERNAL */ && token.error != null) {\n        // If this listener was added by a 3P call, send any token error to\n        // the supplied error handler. A 3P observer always has an error\n        // handler.\n        observer.error(token.error);\n      } else {\n        // If the token has no error field, always return the token.\n        // If this is a 2P listener, return the token, whether or not it\n        // has an error field.\n        observer.next(token);\n      }\n    } catch (e) {\n      // Errors in the listener function itself are always ignored.\n    }\n  }\n}\nfunction isValid(token) {\n  return token.expireTimeMillis - Date.now() > 0;\n}\nfunction makeDummyTokenResult(error) {\n  return {\n    token: formatDummyToken(defaultTokenErrorData),\n    error\n  };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * AppCheck Service class.\n */\nclass AppCheckService {\n  constructor(app, heartbeatServiceProvider) {\n    this.app = app;\n    this.heartbeatServiceProvider = heartbeatServiceProvider;\n  }\n  _delete() {\n    const {\n      tokenObservers\n    } = getStateReference(this.app);\n    for (const tokenObserver of tokenObservers) {\n      removeTokenListener(this.app, tokenObserver.next);\n    }\n    return Promise.resolve();\n  }\n}\nfunction factory(app, heartbeatServiceProvider) {\n  return new AppCheckService(app, heartbeatServiceProvider);\n}\nfunction internalFactory(appCheck) {\n  return {\n    getToken: forceRefresh => getToken$2(appCheck, forceRefresh),\n    getLimitedUseToken: () => getLimitedUseToken$1(appCheck),\n    addTokenListener: listener => addTokenListener(appCheck, \"INTERNAL\" /* ListenerType.INTERNAL */, listener),\n    removeTokenListener: listener => removeTokenListener(appCheck.app, listener)\n  };\n}\nconst name = \"@firebase/app-check\";\nconst version = \"0.8.13\";\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst RECAPTCHA_URL = 'https://www.google.com/recaptcha/api.js';\nconst RECAPTCHA_ENTERPRISE_URL = 'https://www.google.com/recaptcha/enterprise.js';\nfunction initializeV3(app, siteKey) {\n  const initialized = new Deferred();\n  const state = getStateReference(app);\n  state.reCAPTCHAState = {\n    initialized\n  };\n  const divId = makeDiv(app);\n  const grecaptcha = getRecaptcha(false);\n  if (!grecaptcha) {\n    loadReCAPTCHAV3Script(() => {\n      const grecaptcha = getRecaptcha(false);\n      if (!grecaptcha) {\n        // it shouldn't happen.\n        throw new Error('no recaptcha');\n      }\n      queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n    });\n  } else {\n    queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n  }\n  return initialized.promise;\n}\nfunction initializeEnterprise(app, siteKey) {\n  const initialized = new Deferred();\n  const state = getStateReference(app);\n  state.reCAPTCHAState = {\n    initialized\n  };\n  const divId = makeDiv(app);\n  const grecaptcha = getRecaptcha(true);\n  if (!grecaptcha) {\n    loadReCAPTCHAEnterpriseScript(() => {\n      const grecaptcha = getRecaptcha(true);\n      if (!grecaptcha) {\n        // it shouldn't happen.\n        throw new Error('no recaptcha');\n      }\n      queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n    });\n  } else {\n    queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n  }\n  return initialized.promise;\n}\n/**\n * Add listener to render the widget and resolve the promise when\n * the grecaptcha.ready() event fires.\n */\nfunction queueWidgetRender(app, siteKey, grecaptcha, container, initialized) {\n  grecaptcha.ready(() => {\n    // Invisible widgets allow us to set a different siteKey for each widget,\n    // so we use them to support multiple apps\n    renderInvisibleWidget(app, siteKey, grecaptcha, container);\n    initialized.resolve(grecaptcha);\n  });\n}\n/**\n * Add invisible div to page.\n */\nfunction makeDiv(app) {\n  const divId = `fire_app_check_${app.name}`;\n  const invisibleDiv = document.createElement('div');\n  invisibleDiv.id = divId;\n  invisibleDiv.style.display = 'none';\n  document.body.appendChild(invisibleDiv);\n  return divId;\n}\nfunction getToken$1(_x9) {\n  return _getToken$2.apply(this, arguments);\n}\n/**\n *\n * @param app\n * @param container - Id of a HTML element.\n */\nfunction _getToken$2() {\n  _getToken$2 = _asyncToGenerator(function* (app) {\n    ensureActivated(app);\n    // ensureActivated() guarantees that reCAPTCHAState is set\n    const reCAPTCHAState = getStateReference(app).reCAPTCHAState;\n    const recaptcha = yield reCAPTCHAState.initialized.promise;\n    return new Promise((resolve, _reject) => {\n      // Updated after initialization is complete.\n      const reCAPTCHAState = getStateReference(app).reCAPTCHAState;\n      recaptcha.ready(() => {\n        resolve(\n        // widgetId is guaranteed to be available if reCAPTCHAState.initialized.promise resolved.\n        recaptcha.execute(reCAPTCHAState.widgetId, {\n          action: 'fire_app_check'\n        }));\n      });\n    });\n  });\n  return _getToken$2.apply(this, arguments);\n}\nfunction renderInvisibleWidget(app, siteKey, grecaptcha, container) {\n  const widgetId = grecaptcha.render(container, {\n    sitekey: siteKey,\n    size: 'invisible',\n    // Success callback - set state\n    callback: () => {\n      getStateReference(app).reCAPTCHAState.succeeded = true;\n    },\n    // Failure callback - set state\n    'error-callback': () => {\n      getStateReference(app).reCAPTCHAState.succeeded = false;\n    }\n  });\n  const state = getStateReference(app);\n  state.reCAPTCHAState = Object.assign(Object.assign({}, state.reCAPTCHAState), {\n    // state.reCAPTCHAState is set in the initialize()\n    widgetId\n  });\n}\nfunction loadReCAPTCHAV3Script(onload) {\n  const script = document.createElement('script');\n  script.src = RECAPTCHA_URL;\n  script.onload = onload;\n  document.head.appendChild(script);\n}\nfunction loadReCAPTCHAEnterpriseScript(onload) {\n  const script = document.createElement('script');\n  script.src = RECAPTCHA_ENTERPRISE_URL;\n  script.onload = onload;\n  document.head.appendChild(script);\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * App Check provider that can obtain a reCAPTCHA V3 token and exchange it\n * for an App Check token.\n *\n * @public\n */\nclass ReCaptchaV3Provider {\n  /**\n   * Create a ReCaptchaV3Provider instance.\n   * @param siteKey - ReCAPTCHA V3 siteKey.\n   */\n  constructor(_siteKey) {\n    this._siteKey = _siteKey;\n    /**\n     * Throttle requests on certain error codes to prevent too many retries\n     * in a short time.\n     */\n    this._throttleData = null;\n  }\n  /**\n   * Returns an App Check token.\n   * @internal\n   */\n  getToken() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n      throwIfThrottled(_this2._throttleData);\n      // Top-level `getToken()` has already checked that App Check is initialized\n      // and therefore this._app and this._heartbeatServiceProvider are available.\n      const attestedClaimsToken = yield getToken$1(_this2._app).catch(_e => {\n        // reCaptcha.execute() throws null which is not very descriptive.\n        throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n      });\n      // Check if a failure state was set by the recaptcha \"error-callback\".\n      if (!((_a = getStateReference(_this2._app).reCAPTCHAState) === null || _a === void 0 ? void 0 : _a.succeeded)) {\n        throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n      }\n\n      let result;\n      try {\n        result = yield exchangeToken(getExchangeRecaptchaV3TokenRequest(_this2._app, attestedClaimsToken), _this2._heartbeatServiceProvider);\n      } catch (e) {\n        if ((_b = e.code) === null || _b === void 0 ? void 0 : _b.includes(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */)) {\n          _this2._throttleData = setBackoff(Number((_c = e.customData) === null || _c === void 0 ? void 0 : _c.httpStatus), _this2._throttleData);\n          throw ERROR_FACTORY.create(\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */, {\n            time: getDurationString(_this2._throttleData.allowRequestsAfter - Date.now()),\n            httpStatus: _this2._throttleData.httpStatus\n          });\n        } else {\n          throw e;\n        }\n      }\n      // If successful, clear throttle data.\n      _this2._throttleData = null;\n      return result;\n    })();\n  }\n  /**\n   * @internal\n   */\n  initialize(app) {\n    this._app = app;\n    this._heartbeatServiceProvider = _getProvider(app, 'heartbeat');\n    initializeV3(app, this._siteKey).catch(() => {\n      /* we don't care about the initialization result */\n    });\n  }\n  /**\n   * @internal\n   */\n  isEqual(otherProvider) {\n    if (otherProvider instanceof ReCaptchaV3Provider) {\n      return this._siteKey === otherProvider._siteKey;\n    } else {\n      return false;\n    }\n  }\n}\n/**\n * App Check provider that can obtain a reCAPTCHA Enterprise token and exchange it\n * for an App Check token.\n *\n * @public\n */\nclass ReCaptchaEnterpriseProvider {\n  /**\n   * Create a ReCaptchaEnterpriseProvider instance.\n   * @param siteKey - reCAPTCHA Enterprise score-based site key.\n   */\n  constructor(_siteKey) {\n    this._siteKey = _siteKey;\n    /**\n     * Throttle requests on certain error codes to prevent too many retries\n     * in a short time.\n     */\n    this._throttleData = null;\n  }\n  /**\n   * Returns an App Check token.\n   * @internal\n   */\n  getToken() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      var _a, _b, _c;\n      throwIfThrottled(_this3._throttleData);\n      // Top-level `getToken()` has already checked that App Check is initialized\n      // and therefore this._app and this._heartbeatServiceProvider are available.\n      const attestedClaimsToken = yield getToken$1(_this3._app).catch(_e => {\n        // reCaptcha.execute() throws null which is not very descriptive.\n        throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n      });\n      // Check if a failure state was set by the recaptcha \"error-callback\".\n      if (!((_a = getStateReference(_this3._app).reCAPTCHAState) === null || _a === void 0 ? void 0 : _a.succeeded)) {\n        throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n      }\n\n      let result;\n      try {\n        result = yield exchangeToken(getExchangeRecaptchaEnterpriseTokenRequest(_this3._app, attestedClaimsToken), _this3._heartbeatServiceProvider);\n      } catch (e) {\n        if ((_b = e.code) === null || _b === void 0 ? void 0 : _b.includes(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */)) {\n          _this3._throttleData = setBackoff(Number((_c = e.customData) === null || _c === void 0 ? void 0 : _c.httpStatus), _this3._throttleData);\n          throw ERROR_FACTORY.create(\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */, {\n            time: getDurationString(_this3._throttleData.allowRequestsAfter - Date.now()),\n            httpStatus: _this3._throttleData.httpStatus\n          });\n        } else {\n          throw e;\n        }\n      }\n      // If successful, clear throttle data.\n      _this3._throttleData = null;\n      return result;\n    })();\n  }\n  /**\n   * @internal\n   */\n  initialize(app) {\n    this._app = app;\n    this._heartbeatServiceProvider = _getProvider(app, 'heartbeat');\n    initializeEnterprise(app, this._siteKey).catch(() => {\n      /* we don't care about the initialization result */\n    });\n  }\n  /**\n   * @internal\n   */\n  isEqual(otherProvider) {\n    if (otherProvider instanceof ReCaptchaEnterpriseProvider) {\n      return this._siteKey === otherProvider._siteKey;\n    } else {\n      return false;\n    }\n  }\n}\n/**\n * Custom provider class.\n * @public\n */\nclass CustomProvider {\n  constructor(_customProviderOptions) {\n    this._customProviderOptions = _customProviderOptions;\n  }\n  /**\n   * @internal\n   */\n  getToken() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // custom provider\n      const customToken = yield _this4._customProviderOptions.getToken();\n      // Try to extract IAT from custom token, in case this token is not\n      // being newly issued. JWT timestamps are in seconds since epoch.\n      const issuedAtTimeSeconds = issuedAtTime(customToken.token);\n      // Very basic validation, use current timestamp as IAT if JWT\n      // has no `iat` field or value is out of bounds.\n      const issuedAtTimeMillis = issuedAtTimeSeconds !== null && issuedAtTimeSeconds < Date.now() && issuedAtTimeSeconds > 0 ? issuedAtTimeSeconds * 1000 : Date.now();\n      return Object.assign(Object.assign({}, customToken), {\n        issuedAtTimeMillis\n      });\n    })();\n  }\n  /**\n   * @internal\n   */\n  initialize(app) {\n    this._app = app;\n  }\n  /**\n   * @internal\n   */\n  isEqual(otherProvider) {\n    if (otherProvider instanceof CustomProvider) {\n      return this._customProviderOptions.getToken.toString() === otherProvider._customProviderOptions.getToken.toString();\n    } else {\n      return false;\n    }\n  }\n}\n/**\n * Set throttle data to block requests until after a certain time\n * depending on the failed request's status code.\n * @param httpStatus - Status code of failed request.\n * @param throttleData - `ThrottleData` object containing previous throttle\n * data state.\n * @returns Data about current throttle state and expiration time.\n */\nfunction setBackoff(httpStatus, throttleData) {\n  /**\n   * Block retries for 1 day for the following error codes:\n   *\n   * 404: Likely malformed URL.\n   *\n   * 403:\n   * - Attestation failed\n   * - Wrong API key\n   * - Project deleted\n   */\n  if (httpStatus === 404 || httpStatus === 403) {\n    return {\n      backoffCount: 1,\n      allowRequestsAfter: Date.now() + ONE_DAY,\n      httpStatus\n    };\n  } else {\n    /**\n     * For all other error codes, the time when it is ok to retry again\n     * is based on exponential backoff.\n     */\n    const backoffCount = throttleData ? throttleData.backoffCount : 0;\n    const backoffMillis = calculateBackoffMillis(backoffCount, 1000, 2);\n    return {\n      backoffCount: backoffCount + 1,\n      allowRequestsAfter: Date.now() + backoffMillis,\n      httpStatus\n    };\n  }\n}\nfunction throwIfThrottled(throttleData) {\n  if (throttleData) {\n    if (Date.now() - throttleData.allowRequestsAfter <= 0) {\n      // If before, throw.\n      throw ERROR_FACTORY.create(\"throttled\" /* AppCheckError.THROTTLED */, {\n        time: getDurationString(throttleData.allowRequestsAfter - Date.now()),\n        httpStatus: throttleData.httpStatus\n      });\n    }\n  }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Activate App Check for the given app. Can be called only once per app.\n * @param app - the {@link @firebase/app#FirebaseApp} to activate App Check for\n * @param options - App Check initialization options\n * @public\n */\nfunction initializeAppCheck(app = getApp(), options) {\n  app = getModularInstance(app);\n  const provider = _getProvider(app, 'app-check');\n  // Ensure initializeDebugMode() is only called once.\n  if (!getDebugState().initialized) {\n    initializeDebugMode();\n  }\n  // Log a message containing the debug token when `initializeAppCheck()`\n  // is called in debug mode.\n  if (isDebugMode()) {\n    // Do not block initialization to get the token for the message.\n    void getDebugToken().then(token =>\n    // Not using logger because I don't think we ever want this accidentally hidden.\n    console.log(`App Check debug token: ${token}. You will need to add it to your app's App Check settings in the Firebase console for it to work.`));\n  }\n  if (provider.isInitialized()) {\n    const existingInstance = provider.getImmediate();\n    const initialOptions = provider.getOptions();\n    if (initialOptions.isTokenAutoRefreshEnabled === options.isTokenAutoRefreshEnabled && initialOptions.provider.isEqual(options.provider)) {\n      return existingInstance;\n    } else {\n      throw ERROR_FACTORY.create(\"already-initialized\" /* AppCheckError.ALREADY_INITIALIZED */, {\n        appName: app.name\n      });\n    }\n  }\n  const appCheck = provider.initialize({\n    options\n  });\n  _activate(app, options.provider, options.isTokenAutoRefreshEnabled);\n  // If isTokenAutoRefreshEnabled is false, do not send any requests to the\n  // exchange endpoint without an explicit call from the user either directly\n  // or through another Firebase library (storage, functions, etc.)\n  if (getStateReference(app).isTokenAutoRefreshEnabled) {\n    // Adding a listener will start the refresher and fetch a token if needed.\n    // This gets a token ready and prevents a delay when an internal library\n    // requests the token.\n    // Listener function does not need to do anything, its base functionality\n    // of calling getToken() already fetches token and writes it to memory/storage.\n    addTokenListener(appCheck, \"INTERNAL\" /* ListenerType.INTERNAL */, () => {});\n  }\n  return appCheck;\n}\n/**\n * Activate App Check\n * @param app - Firebase app to activate App Check for.\n * @param provider - reCAPTCHA v3 provider or\n * custom token provider.\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\n * refreshes App Check tokens as needed. If undefined, defaults to the\n * value of `app.automaticDataCollectionEnabled`, which defaults to\n * false and can be set in the app config.\n */\nfunction _activate(app, provider, isTokenAutoRefreshEnabled) {\n  // Create an entry in the APP_CHECK_STATES map. Further changes should\n  // directly mutate this object.\n  const state = setInitialState(app, Object.assign({}, DEFAULT_STATE));\n  state.activated = true;\n  state.provider = provider; // Read cached token from storage if it exists and store it in memory.\n  state.cachedTokenPromise = readTokenFromStorage(app).then(cachedToken => {\n    if (cachedToken && isValid(cachedToken)) {\n      state.token = cachedToken;\n      // notify all listeners with the cached token\n      notifyTokenListeners(app, {\n        token: cachedToken.token\n      });\n    }\n    return cachedToken;\n  });\n  // Use value of global `automaticDataCollectionEnabled` (which\n  // itself defaults to false if not specified in config) if\n  // `isTokenAutoRefreshEnabled` param was not provided by user.\n  state.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled === undefined ? app.automaticDataCollectionEnabled : isTokenAutoRefreshEnabled;\n  state.provider.initialize(app);\n}\n/**\n * Set whether App Check will automatically refresh tokens as needed.\n *\n * @param appCheckInstance - The App Check service instance.\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\n * refreshes App Check tokens as needed. This overrides any value set\n * during `initializeAppCheck()`.\n * @public\n */\nfunction setTokenAutoRefreshEnabled(appCheckInstance, isTokenAutoRefreshEnabled) {\n  const app = appCheckInstance.app;\n  const state = getStateReference(app);\n  // This will exist if any product libraries have called\n  // `addTokenListener()`\n  if (state.tokenRefresher) {\n    if (isTokenAutoRefreshEnabled === true) {\n      state.tokenRefresher.start();\n    } else {\n      state.tokenRefresher.stop();\n    }\n  }\n  state.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled;\n}\n/**\n * Get the current App Check token. If `forceRefresh` is false, this function first\n * checks for a valid token in memory, then local persistence (IndexedDB).\n * If not found, or if `forceRefresh` is true, it makes a request to the\n * App Check endpoint for a fresh token. That request attaches\n * to the most recent in-flight request if one is present.\n *\n * @param appCheckInstance - The App Check service instance.\n * @param forceRefresh - If true, will always try to fetch a fresh token.\n * If false, will use a cached token if found in storage.\n * @public\n */\nfunction getToken(_x10, _x11) {\n  return _getToken.apply(this, arguments);\n}\n/**\n * Requests a Firebase App Check token. This method should be used\n * only if you need to authorize requests to a non-Firebase backend.\n *\n * Returns limited-use tokens that are intended for use with your\n * non-Firebase backend endpoints that are protected with\n * <a href=\"https://firebase.google.com/docs/app-check/custom-resource-backend#replay-protection\">\n * Replay Protection</a>. This method\n * does not affect the token generation behavior of the\n * #getAppCheckToken() method.\n *\n * @param appCheckInstance - The App Check service instance.\n * @returns The limited use token.\n * @public\n */\nfunction _getToken() {\n  _getToken = _asyncToGenerator(function* (appCheckInstance, forceRefresh) {\n    const result = yield getToken$2(appCheckInstance, forceRefresh);\n    if (result.error) {\n      throw result.error;\n    }\n    if (result.internalError) {\n      throw result.internalError;\n    }\n    return {\n      token: result.token\n    };\n  });\n  return _getToken.apply(this, arguments);\n}\nfunction getLimitedUseToken(appCheckInstance) {\n  return getLimitedUseToken$1(appCheckInstance);\n}\n/**\n * Wraps `addTokenListener`/`removeTokenListener` methods in an `Observer`\n * pattern for public use.\n */\nfunction onTokenChanged(appCheckInstance, onNextOrObserver, onError,\n/**\n * NOTE: Although an `onCompletion` callback can be provided, it will\n * never be called because the token stream is never-ending.\n * It is added only for API consistency with the observer pattern, which\n * we follow in JS APIs.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nonCompletion) {\n  let nextFn = () => {};\n  let errorFn = () => {};\n  if (onNextOrObserver.next != null) {\n    nextFn = onNextOrObserver.next.bind(onNextOrObserver);\n  } else {\n    nextFn = onNextOrObserver;\n  }\n  if (onNextOrObserver.error != null) {\n    errorFn = onNextOrObserver.error.bind(onNextOrObserver);\n  } else if (onError) {\n    errorFn = onError;\n  }\n  addTokenListener(appCheckInstance, \"EXTERNAL\" /* ListenerType.EXTERNAL */, nextFn, errorFn);\n  return () => removeTokenListener(appCheckInstance.app, nextFn);\n}\n\n/**\n * The Firebase App Check Web SDK.\n *\n * @remarks\n * Firebase App Check does not work in a Node.js environment using `ReCaptchaV3Provider` or\n * `ReCaptchaEnterpriseProvider`, but can be used in Node.js if you use\n * `CustomProvider` and write your own attestation method.\n *\n * @packageDocumentation\n */\nconst APP_CHECK_NAME = 'app-check';\nconst APP_CHECK_NAME_INTERNAL = 'app-check-internal';\nfunction registerAppCheck() {\n  // The public interface\n  _registerComponent(new Component(APP_CHECK_NAME, container => {\n    // getImmediate for FirebaseApp will always succeed\n    const app = container.getProvider('app').getImmediate();\n    const heartbeatServiceProvider = container.getProvider('heartbeat');\n    return factory(app, heartbeatServiceProvider);\n  }, \"PUBLIC\" /* ComponentType.PUBLIC */).setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */)\n  /**\n   * Initialize app-check-internal after app-check is initialized to make AppCheck available to\n   * other Firebase SDKs\n   */.setInstanceCreatedCallback((container, _identifier, _appcheckService) => {\n    container.getProvider(APP_CHECK_NAME_INTERNAL).initialize();\n  }));\n  // The internal interface used by other Firebase products\n  _registerComponent(new Component(APP_CHECK_NAME_INTERNAL, container => {\n    const appCheck = container.getProvider('app-check').getImmediate();\n    return internalFactory(appCheck);\n  }, \"PUBLIC\" /* ComponentType.PUBLIC */).setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */));\n  registerVersion(name, version);\n}\nregisterAppCheck();\nexport { CustomProvider, ReCaptchaEnterpriseProvider, ReCaptchaV3Provider, getLimitedUseToken, getToken, initializeAppCheck, onTokenChanged, setTokenAutoRefreshEnabled };","map":{"version":3,"names":["_getProvider","getApp","_registerComponent","registerVersion","Component","Deferred","ErrorFactory","isIndexedDBAvailable","getGlobal","base64","issuedAtTime","calculateBackoffMillis","getModularInstance","Logger","APP_CHECK_STATES","Map","DEFAULT_STATE","activated","tokenObservers","DEBUG_STATE","initialized","enabled","getStateReference","app","get","Object","assign","setInitialState","state","set","getDebugState","BASE_ENDPOINT","EXCHANGE_RECAPTCHA_TOKEN_METHOD","EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD","EXCHANGE_DEBUG_TOKEN_METHOD","TOKEN_REFRESH_TIME","OFFSET_DURATION","RETRIAL_MIN_WAIT","RETRIAL_MAX_WAIT","ONE_DAY","Refresher","constructor","operation","retryPolicy","getWaitDuration","lowerBound","upperBound","pending","nextErrorWaitInterval","Error","start","process","catch","stop","reject","isRunning","hasSucceeded","_this","_asyncToGenerator","promise","_e","sleep","getNextRun","resolve","error","currentErrorWaitInterval","ms","Promise","setTimeout","ERRORS","ERROR_FACTORY","getRecaptcha","isEnterprise","_a","self","grecaptcha","enterprise","ensureActivated","create","appName","name","getDurationString","durationInMillis","totalSeconds","Math","round","days","floor","hours","minutes","seconds","result","pad","value","toString","exchangeToken","_x","_x2","_exchangeToken","apply","arguments","url","body","heartbeatServiceProvider","headers","heartbeatService","getImmediate","optional","heartbeatsHeader","getHeartbeatsHeader","options","method","JSON","stringify","response","fetch","originalError","originalErrorMessage","message","status","httpStatus","responseBody","json","match","ttl","isNaN","Number","timeToLiveAsNumber","now","Date","token","expireTimeMillis","issuedAtTimeMillis","getExchangeRecaptchaV3TokenRequest","reCAPTCHAToken","projectId","appId","apiKey","getExchangeRecaptchaEnterpriseTokenRequest","getExchangeDebugTokenRequest","debugToken","debug_token","DB_NAME","DB_VERSION","STORE_NAME","DEBUG_TOKEN_KEY","dbPromise","getDBPromise","request","indexedDB","open","onsuccess","event","target","onerror","onupgradeneeded","db","oldVersion","createObjectStore","keyPath","e","readTokenFromIndexedDB","read","computeKey","writeTokenToIndexedDB","write","writeDebugTokenToIndexedDB","readDebugTokenFromIndexedDB","_x3","_x4","_write","key","transaction","store","objectStore","put","compositeKey","_event","_x5","_read","undefined","logger","readTokenFromStorage","_x6","_readTokenFromStorage","warn","writeTokenToStorage","readOrCreateDebugTokenFromStorage","_readOrCreateDebugTokenFromStorage","existingDebugToken","newToken","crypto","randomUUID","isDebugMode","debugState","getDebugToken","_getDebugToken","initializeDebugMode","globals","FIREBASE_APPCHECK_DEBUG_TOKEN","deferredToken","defaultTokenErrorData","formatDummyToken","tokenErrorData","encodeString","getToken$2","_x7","_getToken$","appCheck","forceRefresh","shouldLogErrors","isValid","cachedToken","cachedTokenPromise","shouldCallListeners","exchangeTokenPromise","finally","tokenFromDebugExchange","code","makeDummyTokenResult","provider","getToken","interopTokenResult","internalError","notifyTokenListeners","getLimitedUseToken$1","_x8","_getLimitedUseToken$","addTokenListener","type","listener","onError","tokenObserver","next","validToken","then","initTokenRefresher","removeTokenListener","newObservers","filter","length","tokenRefresher","refresher","createTokenRefresher","isTokenAutoRefreshEnabled","nextRefreshTimeMillis","latestAllowableRefresh","min","max","observers","observer","AppCheckService","_delete","factory","internalFactory","getLimitedUseToken","version","RECAPTCHA_URL","RECAPTCHA_ENTERPRISE_URL","initializeV3","siteKey","reCAPTCHAState","divId","makeDiv","loadReCAPTCHAV3Script","queueWidgetRender","initializeEnterprise","loadReCAPTCHAEnterpriseScript","container","ready","renderInvisibleWidget","invisibleDiv","document","createElement","id","style","display","appendChild","getToken$1","_x9","_getToken$2","recaptcha","_reject","execute","widgetId","action","render","sitekey","size","callback","succeeded","error-callback","onload","script","src","head","ReCaptchaV3Provider","_siteKey","_throttleData","_this2","_b","_c","throwIfThrottled","attestedClaimsToken","_app","_heartbeatServiceProvider","includes","setBackoff","customData","time","allowRequestsAfter","initialize","isEqual","otherProvider","ReCaptchaEnterpriseProvider","_this3","CustomProvider","_customProviderOptions","_this4","customToken","issuedAtTimeSeconds","throttleData","backoffCount","backoffMillis","initializeAppCheck","console","log","isInitialized","existingInstance","initialOptions","getOptions","_activate","automaticDataCollectionEnabled","setTokenAutoRefreshEnabled","appCheckInstance","_x10","_x11","_getToken","onTokenChanged","onNextOrObserver","onCompletion","nextFn","errorFn","bind","APP_CHECK_NAME","APP_CHECK_NAME_INTERNAL","registerAppCheck","getProvider","setInstantiationMode","setInstanceCreatedCallback","_identifier","_appcheckService"],"sources":["/Users/vinithyareddy/Desktop/projects/my github projects/project-dashboard/node_modules/@firebase/app-check/dist/esm/index.esm2017.js"],"sourcesContent":["import { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Component } from '@firebase/component';\nimport { Deferred, ErrorFactory, isIndexedDBAvailable, getGlobal, base64, issuedAtTime, calculateBackoffMillis, getModularInstance } from '@firebase/util';\nimport { Logger } from '@firebase/logger';\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst APP_CHECK_STATES = new Map();\nconst DEFAULT_STATE = {\n    activated: false,\n    tokenObservers: []\n};\nconst DEBUG_STATE = {\n    initialized: false,\n    enabled: false\n};\n/**\n * Gets a reference to the state object.\n */\nfunction getStateReference(app) {\n    return APP_CHECK_STATES.get(app) || Object.assign({}, DEFAULT_STATE);\n}\n/**\n * Set once on initialization. The map should hold the same reference to the\n * same object until this entry is deleted.\n */\nfunction setInitialState(app, state) {\n    APP_CHECK_STATES.set(app, state);\n    return APP_CHECK_STATES.get(app);\n}\nfunction getDebugState() {\n    return DEBUG_STATE;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst BASE_ENDPOINT = 'https://content-firebaseappcheck.googleapis.com/v1';\nconst EXCHANGE_RECAPTCHA_TOKEN_METHOD = 'exchangeRecaptchaV3Token';\nconst EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD = 'exchangeRecaptchaEnterpriseToken';\nconst EXCHANGE_DEBUG_TOKEN_METHOD = 'exchangeDebugToken';\nconst TOKEN_REFRESH_TIME = {\n    /**\n     * The offset time before token natural expiration to run the refresh.\n     * This is currently 5 minutes.\n     */\n    OFFSET_DURATION: 5 * 60 * 1000,\n    /**\n     * This is the first retrial wait after an error. This is currently\n     * 30 seconds.\n     */\n    RETRIAL_MIN_WAIT: 30 * 1000,\n    /**\n     * This is the maximum retrial wait, currently 16 minutes.\n     */\n    RETRIAL_MAX_WAIT: 16 * 60 * 1000\n};\n/**\n * One day in millis, for certain error code backoffs.\n */\nconst ONE_DAY = 24 * 60 * 60 * 1000;\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Port from auth proactiverefresh.js\n *\n */\n// TODO: move it to @firebase/util?\n// TODO: allow to config whether refresh should happen in the background\nclass Refresher {\n    constructor(operation, retryPolicy, getWaitDuration, lowerBound, upperBound) {\n        this.operation = operation;\n        this.retryPolicy = retryPolicy;\n        this.getWaitDuration = getWaitDuration;\n        this.lowerBound = lowerBound;\n        this.upperBound = upperBound;\n        this.pending = null;\n        this.nextErrorWaitInterval = lowerBound;\n        if (lowerBound > upperBound) {\n            throw new Error('Proactive refresh lower bound greater than upper bound!');\n        }\n    }\n    start() {\n        this.nextErrorWaitInterval = this.lowerBound;\n        this.process(true).catch(() => {\n            /* we don't care about the result */\n        });\n    }\n    stop() {\n        if (this.pending) {\n            this.pending.reject('cancelled');\n            this.pending = null;\n        }\n    }\n    isRunning() {\n        return !!this.pending;\n    }\n    async process(hasSucceeded) {\n        this.stop();\n        try {\n            this.pending = new Deferred();\n            this.pending.promise.catch(_e => {\n                /* ignore */\n            });\n            await sleep(this.getNextRun(hasSucceeded));\n            // Why do we resolve a promise, then immediate wait for it?\n            // We do it to make the promise chain cancellable.\n            // We can call stop() which rejects the promise before the following line execute, which makes\n            // the code jump to the catch block.\n            // TODO: unit test this\n            this.pending.resolve();\n            await this.pending.promise;\n            this.pending = new Deferred();\n            this.pending.promise.catch(_e => {\n                /* ignore */\n            });\n            await this.operation();\n            this.pending.resolve();\n            await this.pending.promise;\n            this.process(true).catch(() => {\n                /* we don't care about the result */\n            });\n        }\n        catch (error) {\n            if (this.retryPolicy(error)) {\n                this.process(false).catch(() => {\n                    /* we don't care about the result */\n                });\n            }\n            else {\n                this.stop();\n            }\n        }\n    }\n    getNextRun(hasSucceeded) {\n        if (hasSucceeded) {\n            // If last operation succeeded, reset next error wait interval and return\n            // the default wait duration.\n            this.nextErrorWaitInterval = this.lowerBound;\n            // Return typical wait duration interval after a successful operation.\n            return this.getWaitDuration();\n        }\n        else {\n            // Get next error wait interval.\n            const currentErrorWaitInterval = this.nextErrorWaitInterval;\n            // Double interval for next consecutive error.\n            this.nextErrorWaitInterval *= 2;\n            // Make sure next wait interval does not exceed the maximum upper bound.\n            if (this.nextErrorWaitInterval > this.upperBound) {\n                this.nextErrorWaitInterval = this.upperBound;\n            }\n            return currentErrorWaitInterval;\n        }\n    }\n}\nfunction sleep(ms) {\n    return new Promise(resolve => {\n        setTimeout(resolve, ms);\n    });\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst ERRORS = {\n    [\"already-initialized\" /* AppCheckError.ALREADY_INITIALIZED */]: 'You have already called initializeAppCheck() for FirebaseApp {$appName} with ' +\n        'different options. To avoid this error, call initializeAppCheck() with the ' +\n        'same options as when it was originally called. This will return the ' +\n        'already initialized instance.',\n    [\"use-before-activation\" /* AppCheckError.USE_BEFORE_ACTIVATION */]: 'App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. ' +\n        'Call initializeAppCheck() before instantiating other Firebase services.',\n    [\"fetch-network-error\" /* AppCheckError.FETCH_NETWORK_ERROR */]: 'Fetch failed to connect to a network. Check Internet connection. ' +\n        'Original error: {$originalErrorMessage}.',\n    [\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */]: 'Fetch client could not parse response.' +\n        ' Original error: {$originalErrorMessage}.',\n    [\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */]: 'Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.',\n    [\"storage-open\" /* AppCheckError.STORAGE_OPEN */]: 'Error thrown when opening storage. Original error: {$originalErrorMessage}.',\n    [\"storage-get\" /* AppCheckError.STORAGE_GET */]: 'Error thrown when reading from storage. Original error: {$originalErrorMessage}.',\n    [\"storage-set\" /* AppCheckError.STORAGE_WRITE */]: 'Error thrown when writing to storage. Original error: {$originalErrorMessage}.',\n    [\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */]: 'ReCAPTCHA error.',\n    [\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */]: `{$httpStatus} error. Attempts allowed again after {$time}`,\n    [\"throttled\" /* AppCheckError.THROTTLED */]: `Requests throttled due to previous {$httpStatus} error. Attempts allowed again after {$time}`\n};\nconst ERROR_FACTORY = new ErrorFactory('appCheck', 'AppCheck', ERRORS);\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction getRecaptcha(isEnterprise = false) {\n    var _a;\n    if (isEnterprise) {\n        return (_a = self.grecaptcha) === null || _a === void 0 ? void 0 : _a.enterprise;\n    }\n    return self.grecaptcha;\n}\nfunction ensureActivated(app) {\n    if (!getStateReference(app).activated) {\n        throw ERROR_FACTORY.create(\"use-before-activation\" /* AppCheckError.USE_BEFORE_ACTIVATION */, {\n            appName: app.name\n        });\n    }\n}\nfunction getDurationString(durationInMillis) {\n    const totalSeconds = Math.round(durationInMillis / 1000);\n    const days = Math.floor(totalSeconds / (3600 * 24));\n    const hours = Math.floor((totalSeconds - days * 3600 * 24) / 3600);\n    const minutes = Math.floor((totalSeconds - days * 3600 * 24 - hours * 3600) / 60);\n    const seconds = totalSeconds - days * 3600 * 24 - hours * 3600 - minutes * 60;\n    let result = '';\n    if (days) {\n        result += pad(days) + 'd:';\n    }\n    if (hours) {\n        result += pad(hours) + 'h:';\n    }\n    result += pad(minutes) + 'm:' + pad(seconds) + 's';\n    return result;\n}\nfunction pad(value) {\n    if (value === 0) {\n        return '00';\n    }\n    return value >= 10 ? value.toString() : '0' + value;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nasync function exchangeToken({ url, body }, heartbeatServiceProvider) {\n    const headers = {\n        'Content-Type': 'application/json'\n    };\n    // If heartbeat service exists, add heartbeat header string to the header.\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\n        optional: true\n    });\n    if (heartbeatService) {\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\n        if (heartbeatsHeader) {\n            headers['X-Firebase-Client'] = heartbeatsHeader;\n        }\n    }\n    const options = {\n        method: 'POST',\n        body: JSON.stringify(body),\n        headers\n    };\n    let response;\n    try {\n        response = await fetch(url, options);\n    }\n    catch (originalError) {\n        throw ERROR_FACTORY.create(\"fetch-network-error\" /* AppCheckError.FETCH_NETWORK_ERROR */, {\n            originalErrorMessage: originalError === null || originalError === void 0 ? void 0 : originalError.message\n        });\n    }\n    if (response.status !== 200) {\n        throw ERROR_FACTORY.create(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */, {\n            httpStatus: response.status\n        });\n    }\n    let responseBody;\n    try {\n        // JSON parsing throws SyntaxError if the response body isn't a JSON string.\n        responseBody = await response.json();\n    }\n    catch (originalError) {\n        throw ERROR_FACTORY.create(\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */, {\n            originalErrorMessage: originalError === null || originalError === void 0 ? void 0 : originalError.message\n        });\n    }\n    // Protobuf duration format.\n    // https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/Duration\n    const match = responseBody.ttl.match(/^([\\d.]+)(s)$/);\n    if (!match || !match[2] || isNaN(Number(match[1]))) {\n        throw ERROR_FACTORY.create(\"fetch-parse-error\" /* AppCheckError.FETCH_PARSE_ERROR */, {\n            originalErrorMessage: `ttl field (timeToLive) is not in standard Protobuf Duration ` +\n                `format: ${responseBody.ttl}`\n        });\n    }\n    const timeToLiveAsNumber = Number(match[1]) * 1000;\n    const now = Date.now();\n    return {\n        token: responseBody.token,\n        expireTimeMillis: now + timeToLiveAsNumber,\n        issuedAtTimeMillis: now\n    };\n}\nfunction getExchangeRecaptchaV3TokenRequest(app, reCAPTCHAToken) {\n    const { projectId, appId, apiKey } = app.options;\n    return {\n        url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_TOKEN_METHOD}?key=${apiKey}`,\n        body: {\n            'recaptcha_v3_token': reCAPTCHAToken\n        }\n    };\n}\nfunction getExchangeRecaptchaEnterpriseTokenRequest(app, reCAPTCHAToken) {\n    const { projectId, appId, apiKey } = app.options;\n    return {\n        url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_RECAPTCHA_ENTERPRISE_TOKEN_METHOD}?key=${apiKey}`,\n        body: {\n            'recaptcha_enterprise_token': reCAPTCHAToken\n        }\n    };\n}\nfunction getExchangeDebugTokenRequest(app, debugToken) {\n    const { projectId, appId, apiKey } = app.options;\n    return {\n        url: `${BASE_ENDPOINT}/projects/${projectId}/apps/${appId}:${EXCHANGE_DEBUG_TOKEN_METHOD}?key=${apiKey}`,\n        body: {\n            // eslint-disable-next-line\n            debug_token: debugToken\n        }\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DB_NAME = 'firebase-app-check-database';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'firebase-app-check-store';\nconst DEBUG_TOKEN_KEY = 'debug-token';\nlet dbPromise = null;\nfunction getDBPromise() {\n    if (dbPromise) {\n        return dbPromise;\n    }\n    dbPromise = new Promise((resolve, reject) => {\n        try {\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\n            request.onsuccess = event => {\n                resolve(event.target.result);\n            };\n            request.onerror = event => {\n                var _a;\n                reject(ERROR_FACTORY.create(\"storage-open\" /* AppCheckError.STORAGE_OPEN */, {\n                    originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n                }));\n            };\n            request.onupgradeneeded = event => {\n                const db = event.target.result;\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch (event.oldVersion) {\n                    case 0:\n                        db.createObjectStore(STORE_NAME, {\n                            keyPath: 'compositeKey'\n                        });\n                }\n            };\n        }\n        catch (e) {\n            reject(ERROR_FACTORY.create(\"storage-open\" /* AppCheckError.STORAGE_OPEN */, {\n                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message\n            }));\n        }\n    });\n    return dbPromise;\n}\nfunction readTokenFromIndexedDB(app) {\n    return read(computeKey(app));\n}\nfunction writeTokenToIndexedDB(app, token) {\n    return write(computeKey(app), token);\n}\nfunction writeDebugTokenToIndexedDB(token) {\n    return write(DEBUG_TOKEN_KEY, token);\n}\nfunction readDebugTokenFromIndexedDB() {\n    return read(DEBUG_TOKEN_KEY);\n}\nasync function write(key, value) {\n    const db = await getDBPromise();\n    const transaction = db.transaction(STORE_NAME, 'readwrite');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.put({\n        compositeKey: key,\n        value\n    });\n    return new Promise((resolve, reject) => {\n        request.onsuccess = _event => {\n            resolve();\n        };\n        transaction.onerror = event => {\n            var _a;\n            reject(ERROR_FACTORY.create(\"storage-set\" /* AppCheckError.STORAGE_WRITE */, {\n                originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n            }));\n        };\n    });\n}\nasync function read(key) {\n    const db = await getDBPromise();\n    const transaction = db.transaction(STORE_NAME, 'readonly');\n    const store = transaction.objectStore(STORE_NAME);\n    const request = store.get(key);\n    return new Promise((resolve, reject) => {\n        request.onsuccess = event => {\n            const result = event.target.result;\n            if (result) {\n                resolve(result.value);\n            }\n            else {\n                resolve(undefined);\n            }\n        };\n        transaction.onerror = event => {\n            var _a;\n            reject(ERROR_FACTORY.create(\"storage-get\" /* AppCheckError.STORAGE_GET */, {\n                originalErrorMessage: (_a = event.target.error) === null || _a === void 0 ? void 0 : _a.message\n            }));\n        };\n    });\n}\nfunction computeKey(app) {\n    return `${app.options.appId}-${app.name}`;\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst logger = new Logger('@firebase/app-check');\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Always resolves. In case of an error reading from indexeddb, resolve with undefined\n */\nasync function readTokenFromStorage(app) {\n    if (isIndexedDBAvailable()) {\n        let token = undefined;\n        try {\n            token = await readTokenFromIndexedDB(app);\n        }\n        catch (e) {\n            // swallow the error and return undefined\n            logger.warn(`Failed to read token from IndexedDB. Error: ${e}`);\n        }\n        return token;\n    }\n    return undefined;\n}\n/**\n * Always resolves. In case of an error writing to indexeddb, print a warning and resolve the promise\n */\nfunction writeTokenToStorage(app, token) {\n    if (isIndexedDBAvailable()) {\n        return writeTokenToIndexedDB(app, token).catch(e => {\n            // swallow the error and resolve the promise\n            logger.warn(`Failed to write token to IndexedDB. Error: ${e}`);\n        });\n    }\n    return Promise.resolve();\n}\nasync function readOrCreateDebugTokenFromStorage() {\n    /**\n     * Theoretically race condition can happen if we read, then write in 2 separate transactions.\n     * But it won't happen here, because this function will be called exactly once.\n     */\n    let existingDebugToken = undefined;\n    try {\n        existingDebugToken = await readDebugTokenFromIndexedDB();\n    }\n    catch (_e) {\n        // failed to read from indexeddb. We assume there is no existing debug token, and generate a new one.\n    }\n    if (!existingDebugToken) {\n        // create a new debug token\n        // This function is only available in secure contexts. See https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts\n        const newToken = crypto.randomUUID();\n        // We don't need to block on writing to indexeddb\n        // In case persistence failed, a new debug token will be generated every time the page is refreshed.\n        // It renders the debug token useless because you have to manually register(whitelist) the new token in the firebase console again and again.\n        // If you see this error trying to use debug token, it probably means you are using a browser that doesn't support indexeddb.\n        // You should switch to a different browser that supports indexeddb\n        writeDebugTokenToIndexedDB(newToken).catch(e => logger.warn(`Failed to persist debug token to IndexedDB. Error: ${e}`));\n        return newToken;\n    }\n    else {\n        return existingDebugToken;\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isDebugMode() {\n    const debugState = getDebugState();\n    return debugState.enabled;\n}\nasync function getDebugToken() {\n    const state = getDebugState();\n    if (state.enabled && state.token) {\n        return state.token.promise;\n    }\n    else {\n        // should not happen!\n        throw Error(`\n            Can't get debug token in production mode.\n        `);\n    }\n}\nfunction initializeDebugMode() {\n    const globals = getGlobal();\n    const debugState = getDebugState();\n    // Set to true if this function has been called, whether or not\n    // it enabled debug mode.\n    debugState.initialized = true;\n    if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== 'string' &&\n        globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true) {\n        return;\n    }\n    debugState.enabled = true;\n    const deferredToken = new Deferred();\n    debugState.token = deferredToken;\n    if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === 'string') {\n        deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);\n    }\n    else {\n        deferredToken.resolve(readOrCreateDebugTokenFromStorage());\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Initial hardcoded value agreed upon across platforms for initial launch.\n// Format left open for possible dynamic error values and other fields in the future.\nconst defaultTokenErrorData = { error: 'UNKNOWN_ERROR' };\n/**\n * Stringify and base64 encode token error data.\n *\n * @param tokenError Error data, currently hardcoded.\n */\nfunction formatDummyToken(tokenErrorData) {\n    return base64.encodeString(JSON.stringify(tokenErrorData), \n    /* webSafe= */ false);\n}\n/**\n * This function always resolves.\n * The result will contain an error field if there is any error.\n * In case there is an error, the token field in the result will be populated with a dummy value\n */\nasync function getToken$2(appCheck, forceRefresh = false, shouldLogErrors = false) {\n    const app = appCheck.app;\n    ensureActivated(app);\n    const state = getStateReference(app);\n    /**\n     * First check if there is a token in memory from a previous `getToken()` call.\n     */\n    let token = state.token;\n    let error = undefined;\n    /**\n     * If an invalid token was found in memory, clear token from\n     * memory and unset the local variable `token`.\n     */\n    if (token && !isValid(token)) {\n        state.token = undefined;\n        token = undefined;\n    }\n    /**\n     * If there is no valid token in memory, try to load token from indexedDB.\n     */\n    if (!token) {\n        // cachedTokenPromise contains the token found in IndexedDB or undefined if not found.\n        const cachedToken = await state.cachedTokenPromise;\n        if (cachedToken) {\n            if (isValid(cachedToken)) {\n                token = cachedToken;\n            }\n            else {\n                // If there was an invalid token in the indexedDB cache, clear it.\n                await writeTokenToStorage(app, undefined);\n            }\n        }\n    }\n    // Return the cached token (from either memory or indexedDB) if it's valid\n    if (!forceRefresh && token && isValid(token)) {\n        return {\n            token: token.token\n        };\n    }\n    // Only set to true if this `getToken()` call is making the actual\n    // REST call to the exchange endpoint, versus waiting for an already\n    // in-flight call (see debug and regular exchange endpoint paths below)\n    let shouldCallListeners = false;\n    /**\n     * DEBUG MODE\n     * If debug mode is set, and there is no cached token, fetch a new App\n     * Check token using the debug token, and return it directly.\n     */\n    if (isDebugMode()) {\n        try {\n            // Avoid making another call to the exchange endpoint if one is in flight.\n            if (!state.exchangeTokenPromise) {\n                state.exchangeTokenPromise = exchangeToken(getExchangeDebugTokenRequest(app, await getDebugToken()), appCheck.heartbeatServiceProvider).finally(() => {\n                    // Clear promise when settled - either resolved or rejected.\n                    state.exchangeTokenPromise = undefined;\n                });\n                shouldCallListeners = true;\n            }\n            const tokenFromDebugExchange = await state.exchangeTokenPromise;\n            // Write debug token to indexedDB.\n            await writeTokenToStorage(app, tokenFromDebugExchange);\n            // Write debug token to state.\n            state.token = tokenFromDebugExchange;\n            return { token: tokenFromDebugExchange.token };\n        }\n        catch (e) {\n            if (e.code === `appCheck/${\"throttled\" /* AppCheckError.THROTTLED */}` ||\n                e.code ===\n                    `appCheck/${\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */}`) {\n                // Warn if throttled, but do not treat it as an error.\n                logger.warn(e.message);\n            }\n            else if (shouldLogErrors) {\n                logger.error(e);\n            }\n            // Return dummy token and error\n            return makeDummyTokenResult(e);\n        }\n    }\n    /**\n     * There are no valid tokens in memory or indexedDB and we are not in\n     * debug mode.\n     * Request a new token from the exchange endpoint.\n     */\n    try {\n        // Avoid making another call to the exchange endpoint if one is in flight.\n        if (!state.exchangeTokenPromise) {\n            // state.provider is populated in initializeAppCheck()\n            // ensureActivated() at the top of this function checks that\n            // initializeAppCheck() has been called.\n            state.exchangeTokenPromise = state.provider.getToken().finally(() => {\n                // Clear promise when settled - either resolved or rejected.\n                state.exchangeTokenPromise = undefined;\n            });\n            shouldCallListeners = true;\n        }\n        token = await getStateReference(app).exchangeTokenPromise;\n    }\n    catch (e) {\n        if (e.code === `appCheck/${\"throttled\" /* AppCheckError.THROTTLED */}` ||\n            e.code === `appCheck/${\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */}`) {\n            // Warn if throttled, but do not treat it as an error.\n            logger.warn(e.message);\n        }\n        else if (shouldLogErrors) {\n            logger.error(e);\n        }\n        // Always save error to be added to dummy token.\n        error = e;\n    }\n    let interopTokenResult;\n    if (!token) {\n        // If token is undefined, there must be an error.\n        // Return a dummy token along with the error.\n        interopTokenResult = makeDummyTokenResult(error);\n    }\n    else if (error) {\n        if (isValid(token)) {\n            // It's also possible a valid token exists, but there's also an error.\n            // (Such as if the token is almost expired, tries to refresh, and\n            // the exchange request fails.)\n            // We add a special error property here so that the refresher will\n            // count this as a failed attempt and use the backoff instead of\n            // retrying repeatedly with no delay, but any 3P listeners will not\n            // be hindered in getting the still-valid token.\n            interopTokenResult = {\n                token: token.token,\n                internalError: error\n            };\n        }\n        else {\n            // No invalid tokens should make it to this step. Memory and cached tokens\n            // are checked. Other tokens are from fresh exchanges. But just in case.\n            interopTokenResult = makeDummyTokenResult(error);\n        }\n    }\n    else {\n        interopTokenResult = {\n            token: token.token\n        };\n        // write the new token to the memory state as well as the persistent storage.\n        // Only do it if we got a valid new token\n        state.token = token;\n        await writeTokenToStorage(app, token);\n    }\n    if (shouldCallListeners) {\n        notifyTokenListeners(app, interopTokenResult);\n    }\n    return interopTokenResult;\n}\n/**\n * Internal API for limited use tokens. Skips all FAC state and simply calls\n * the underlying provider.\n */\nasync function getLimitedUseToken$1(appCheck) {\n    const app = appCheck.app;\n    ensureActivated(app);\n    const { provider } = getStateReference(app);\n    if (isDebugMode()) {\n        const debugToken = await getDebugToken();\n        const { token } = await exchangeToken(getExchangeDebugTokenRequest(app, debugToken), appCheck.heartbeatServiceProvider);\n        return { token };\n    }\n    else {\n        // provider is definitely valid since we ensure AppCheck was activated\n        const { token } = await provider.getToken();\n        return { token };\n    }\n}\nfunction addTokenListener(appCheck, type, listener, onError) {\n    const { app } = appCheck;\n    const state = getStateReference(app);\n    const tokenObserver = {\n        next: listener,\n        error: onError,\n        type\n    };\n    state.tokenObservers = [...state.tokenObservers, tokenObserver];\n    // Invoke the listener async immediately if there is a valid token\n    // in memory.\n    if (state.token && isValid(state.token)) {\n        const validToken = state.token;\n        Promise.resolve()\n            .then(() => {\n            listener({ token: validToken.token });\n            initTokenRefresher(appCheck);\n        })\n            .catch(() => {\n            /* we don't care about exceptions thrown in listeners */\n        });\n    }\n    /**\n     * Wait for any cached token promise to resolve before starting the token\n     * refresher. The refresher checks to see if there is an existing token\n     * in state and calls the exchange endpoint if not. We should first let the\n     * IndexedDB check have a chance to populate state if it can.\n     *\n     * Listener call isn't needed here because cachedTokenPromise will call any\n     * listeners that exist when it resolves.\n     */\n    // state.cachedTokenPromise is always populated in `activate()`.\n    void state.cachedTokenPromise.then(() => initTokenRefresher(appCheck));\n}\nfunction removeTokenListener(app, listener) {\n    const state = getStateReference(app);\n    const newObservers = state.tokenObservers.filter(tokenObserver => tokenObserver.next !== listener);\n    if (newObservers.length === 0 &&\n        state.tokenRefresher &&\n        state.tokenRefresher.isRunning()) {\n        state.tokenRefresher.stop();\n    }\n    state.tokenObservers = newObservers;\n}\n/**\n * Logic to create and start refresher as needed.\n */\nfunction initTokenRefresher(appCheck) {\n    const { app } = appCheck;\n    const state = getStateReference(app);\n    // Create the refresher but don't start it if `isTokenAutoRefreshEnabled`\n    // is not true.\n    let refresher = state.tokenRefresher;\n    if (!refresher) {\n        refresher = createTokenRefresher(appCheck);\n        state.tokenRefresher = refresher;\n    }\n    if (!refresher.isRunning() && state.isTokenAutoRefreshEnabled) {\n        refresher.start();\n    }\n}\nfunction createTokenRefresher(appCheck) {\n    const { app } = appCheck;\n    return new Refresher(\n    // Keep in mind when this fails for any reason other than the ones\n    // for which we should retry, it will effectively stop the proactive refresh.\n    async () => {\n        const state = getStateReference(app);\n        // If there is no token, we will try to load it from storage and use it\n        // If there is a token, we force refresh it because we know it's going to expire soon\n        let result;\n        if (!state.token) {\n            result = await getToken$2(appCheck);\n        }\n        else {\n            result = await getToken$2(appCheck, true);\n        }\n        /**\n         * getToken() always resolves. In case the result has an error field defined, it means\n         * the operation failed, and we should retry.\n         */\n        if (result.error) {\n            throw result.error;\n        }\n        /**\n         * A special `internalError` field reflects that there was an error\n         * getting a new token from the exchange endpoint, but there's still a\n         * previous token that's valid for now and this should be passed to 2P/3P\n         * requests for a token. But we want this callback (`this.operation` in\n         * `Refresher`) to throw in order to kick off the Refresher's retry\n         * backoff. (Setting `hasSucceeded` to false.)\n         */\n        if (result.internalError) {\n            throw result.internalError;\n        }\n    }, () => {\n        return true;\n    }, () => {\n        const state = getStateReference(app);\n        if (state.token) {\n            // issuedAtTime + (50% * total TTL) + 5 minutes\n            let nextRefreshTimeMillis = state.token.issuedAtTimeMillis +\n                (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) *\n                    0.5 +\n                5 * 60 * 1000;\n            // Do not allow refresh time to be past (expireTime - 5 minutes)\n            const latestAllowableRefresh = state.token.expireTimeMillis - 5 * 60 * 1000;\n            nextRefreshTimeMillis = Math.min(nextRefreshTimeMillis, latestAllowableRefresh);\n            return Math.max(0, nextRefreshTimeMillis - Date.now());\n        }\n        else {\n            return 0;\n        }\n    }, TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT, TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT);\n}\nfunction notifyTokenListeners(app, token) {\n    const observers = getStateReference(app).tokenObservers;\n    for (const observer of observers) {\n        try {\n            if (observer.type === \"EXTERNAL\" /* ListenerType.EXTERNAL */ && token.error != null) {\n                // If this listener was added by a 3P call, send any token error to\n                // the supplied error handler. A 3P observer always has an error\n                // handler.\n                observer.error(token.error);\n            }\n            else {\n                // If the token has no error field, always return the token.\n                // If this is a 2P listener, return the token, whether or not it\n                // has an error field.\n                observer.next(token);\n            }\n        }\n        catch (e) {\n            // Errors in the listener function itself are always ignored.\n        }\n    }\n}\nfunction isValid(token) {\n    return token.expireTimeMillis - Date.now() > 0;\n}\nfunction makeDummyTokenResult(error) {\n    return {\n        token: formatDummyToken(defaultTokenErrorData),\n        error\n    };\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * AppCheck Service class.\n */\nclass AppCheckService {\n    constructor(app, heartbeatServiceProvider) {\n        this.app = app;\n        this.heartbeatServiceProvider = heartbeatServiceProvider;\n    }\n    _delete() {\n        const { tokenObservers } = getStateReference(this.app);\n        for (const tokenObserver of tokenObservers) {\n            removeTokenListener(this.app, tokenObserver.next);\n        }\n        return Promise.resolve();\n    }\n}\nfunction factory(app, heartbeatServiceProvider) {\n    return new AppCheckService(app, heartbeatServiceProvider);\n}\nfunction internalFactory(appCheck) {\n    return {\n        getToken: forceRefresh => getToken$2(appCheck, forceRefresh),\n        getLimitedUseToken: () => getLimitedUseToken$1(appCheck),\n        addTokenListener: listener => addTokenListener(appCheck, \"INTERNAL\" /* ListenerType.INTERNAL */, listener),\n        removeTokenListener: listener => removeTokenListener(appCheck.app, listener)\n    };\n}\n\nconst name = \"@firebase/app-check\";\nconst version = \"0.8.13\";\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst RECAPTCHA_URL = 'https://www.google.com/recaptcha/api.js';\nconst RECAPTCHA_ENTERPRISE_URL = 'https://www.google.com/recaptcha/enterprise.js';\nfunction initializeV3(app, siteKey) {\n    const initialized = new Deferred();\n    const state = getStateReference(app);\n    state.reCAPTCHAState = { initialized };\n    const divId = makeDiv(app);\n    const grecaptcha = getRecaptcha(false);\n    if (!grecaptcha) {\n        loadReCAPTCHAV3Script(() => {\n            const grecaptcha = getRecaptcha(false);\n            if (!grecaptcha) {\n                // it shouldn't happen.\n                throw new Error('no recaptcha');\n            }\n            queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n        });\n    }\n    else {\n        queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n    }\n    return initialized.promise;\n}\nfunction initializeEnterprise(app, siteKey) {\n    const initialized = new Deferred();\n    const state = getStateReference(app);\n    state.reCAPTCHAState = { initialized };\n    const divId = makeDiv(app);\n    const grecaptcha = getRecaptcha(true);\n    if (!grecaptcha) {\n        loadReCAPTCHAEnterpriseScript(() => {\n            const grecaptcha = getRecaptcha(true);\n            if (!grecaptcha) {\n                // it shouldn't happen.\n                throw new Error('no recaptcha');\n            }\n            queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n        });\n    }\n    else {\n        queueWidgetRender(app, siteKey, grecaptcha, divId, initialized);\n    }\n    return initialized.promise;\n}\n/**\n * Add listener to render the widget and resolve the promise when\n * the grecaptcha.ready() event fires.\n */\nfunction queueWidgetRender(app, siteKey, grecaptcha, container, initialized) {\n    grecaptcha.ready(() => {\n        // Invisible widgets allow us to set a different siteKey for each widget,\n        // so we use them to support multiple apps\n        renderInvisibleWidget(app, siteKey, grecaptcha, container);\n        initialized.resolve(grecaptcha);\n    });\n}\n/**\n * Add invisible div to page.\n */\nfunction makeDiv(app) {\n    const divId = `fire_app_check_${app.name}`;\n    const invisibleDiv = document.createElement('div');\n    invisibleDiv.id = divId;\n    invisibleDiv.style.display = 'none';\n    document.body.appendChild(invisibleDiv);\n    return divId;\n}\nasync function getToken$1(app) {\n    ensureActivated(app);\n    // ensureActivated() guarantees that reCAPTCHAState is set\n    const reCAPTCHAState = getStateReference(app).reCAPTCHAState;\n    const recaptcha = await reCAPTCHAState.initialized.promise;\n    return new Promise((resolve, _reject) => {\n        // Updated after initialization is complete.\n        const reCAPTCHAState = getStateReference(app).reCAPTCHAState;\n        recaptcha.ready(() => {\n            resolve(\n            // widgetId is guaranteed to be available if reCAPTCHAState.initialized.promise resolved.\n            recaptcha.execute(reCAPTCHAState.widgetId, {\n                action: 'fire_app_check'\n            }));\n        });\n    });\n}\n/**\n *\n * @param app\n * @param container - Id of a HTML element.\n */\nfunction renderInvisibleWidget(app, siteKey, grecaptcha, container) {\n    const widgetId = grecaptcha.render(container, {\n        sitekey: siteKey,\n        size: 'invisible',\n        // Success callback - set state\n        callback: () => {\n            getStateReference(app).reCAPTCHAState.succeeded = true;\n        },\n        // Failure callback - set state\n        'error-callback': () => {\n            getStateReference(app).reCAPTCHAState.succeeded = false;\n        }\n    });\n    const state = getStateReference(app);\n    state.reCAPTCHAState = Object.assign(Object.assign({}, state.reCAPTCHAState), { // state.reCAPTCHAState is set in the initialize()\n        widgetId });\n}\nfunction loadReCAPTCHAV3Script(onload) {\n    const script = document.createElement('script');\n    script.src = RECAPTCHA_URL;\n    script.onload = onload;\n    document.head.appendChild(script);\n}\nfunction loadReCAPTCHAEnterpriseScript(onload) {\n    const script = document.createElement('script');\n    script.src = RECAPTCHA_ENTERPRISE_URL;\n    script.onload = onload;\n    document.head.appendChild(script);\n}\n\n/**\n * @license\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * App Check provider that can obtain a reCAPTCHA V3 token and exchange it\n * for an App Check token.\n *\n * @public\n */\nclass ReCaptchaV3Provider {\n    /**\n     * Create a ReCaptchaV3Provider instance.\n     * @param siteKey - ReCAPTCHA V3 siteKey.\n     */\n    constructor(_siteKey) {\n        this._siteKey = _siteKey;\n        /**\n         * Throttle requests on certain error codes to prevent too many retries\n         * in a short time.\n         */\n        this._throttleData = null;\n    }\n    /**\n     * Returns an App Check token.\n     * @internal\n     */\n    async getToken() {\n        var _a, _b, _c;\n        throwIfThrottled(this._throttleData);\n        // Top-level `getToken()` has already checked that App Check is initialized\n        // and therefore this._app and this._heartbeatServiceProvider are available.\n        const attestedClaimsToken = await getToken$1(this._app).catch(_e => {\n            // reCaptcha.execute() throws null which is not very descriptive.\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n        });\n        // Check if a failure state was set by the recaptcha \"error-callback\".\n        if (!((_a = getStateReference(this._app).reCAPTCHAState) === null || _a === void 0 ? void 0 : _a.succeeded)) {\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n        }\n        let result;\n        try {\n            result = await exchangeToken(getExchangeRecaptchaV3TokenRequest(this._app, attestedClaimsToken), this._heartbeatServiceProvider);\n        }\n        catch (e) {\n            if ((_b = e.code) === null || _b === void 0 ? void 0 : _b.includes(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */)) {\n                this._throttleData = setBackoff(Number((_c = e.customData) === null || _c === void 0 ? void 0 : _c.httpStatus), this._throttleData);\n                throw ERROR_FACTORY.create(\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */, {\n                    time: getDurationString(this._throttleData.allowRequestsAfter - Date.now()),\n                    httpStatus: this._throttleData.httpStatus\n                });\n            }\n            else {\n                throw e;\n            }\n        }\n        // If successful, clear throttle data.\n        this._throttleData = null;\n        return result;\n    }\n    /**\n     * @internal\n     */\n    initialize(app) {\n        this._app = app;\n        this._heartbeatServiceProvider = _getProvider(app, 'heartbeat');\n        initializeV3(app, this._siteKey).catch(() => {\n            /* we don't care about the initialization result */\n        });\n    }\n    /**\n     * @internal\n     */\n    isEqual(otherProvider) {\n        if (otherProvider instanceof ReCaptchaV3Provider) {\n            return this._siteKey === otherProvider._siteKey;\n        }\n        else {\n            return false;\n        }\n    }\n}\n/**\n * App Check provider that can obtain a reCAPTCHA Enterprise token and exchange it\n * for an App Check token.\n *\n * @public\n */\nclass ReCaptchaEnterpriseProvider {\n    /**\n     * Create a ReCaptchaEnterpriseProvider instance.\n     * @param siteKey - reCAPTCHA Enterprise score-based site key.\n     */\n    constructor(_siteKey) {\n        this._siteKey = _siteKey;\n        /**\n         * Throttle requests on certain error codes to prevent too many retries\n         * in a short time.\n         */\n        this._throttleData = null;\n    }\n    /**\n     * Returns an App Check token.\n     * @internal\n     */\n    async getToken() {\n        var _a, _b, _c;\n        throwIfThrottled(this._throttleData);\n        // Top-level `getToken()` has already checked that App Check is initialized\n        // and therefore this._app and this._heartbeatServiceProvider are available.\n        const attestedClaimsToken = await getToken$1(this._app).catch(_e => {\n            // reCaptcha.execute() throws null which is not very descriptive.\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n        });\n        // Check if a failure state was set by the recaptcha \"error-callback\".\n        if (!((_a = getStateReference(this._app).reCAPTCHAState) === null || _a === void 0 ? void 0 : _a.succeeded)) {\n            throw ERROR_FACTORY.create(\"recaptcha-error\" /* AppCheckError.RECAPTCHA_ERROR */);\n        }\n        let result;\n        try {\n            result = await exchangeToken(getExchangeRecaptchaEnterpriseTokenRequest(this._app, attestedClaimsToken), this._heartbeatServiceProvider);\n        }\n        catch (e) {\n            if ((_b = e.code) === null || _b === void 0 ? void 0 : _b.includes(\"fetch-status-error\" /* AppCheckError.FETCH_STATUS_ERROR */)) {\n                this._throttleData = setBackoff(Number((_c = e.customData) === null || _c === void 0 ? void 0 : _c.httpStatus), this._throttleData);\n                throw ERROR_FACTORY.create(\"initial-throttle\" /* AppCheckError.INITIAL_THROTTLE */, {\n                    time: getDurationString(this._throttleData.allowRequestsAfter - Date.now()),\n                    httpStatus: this._throttleData.httpStatus\n                });\n            }\n            else {\n                throw e;\n            }\n        }\n        // If successful, clear throttle data.\n        this._throttleData = null;\n        return result;\n    }\n    /**\n     * @internal\n     */\n    initialize(app) {\n        this._app = app;\n        this._heartbeatServiceProvider = _getProvider(app, 'heartbeat');\n        initializeEnterprise(app, this._siteKey).catch(() => {\n            /* we don't care about the initialization result */\n        });\n    }\n    /**\n     * @internal\n     */\n    isEqual(otherProvider) {\n        if (otherProvider instanceof ReCaptchaEnterpriseProvider) {\n            return this._siteKey === otherProvider._siteKey;\n        }\n        else {\n            return false;\n        }\n    }\n}\n/**\n * Custom provider class.\n * @public\n */\nclass CustomProvider {\n    constructor(_customProviderOptions) {\n        this._customProviderOptions = _customProviderOptions;\n    }\n    /**\n     * @internal\n     */\n    async getToken() {\n        // custom provider\n        const customToken = await this._customProviderOptions.getToken();\n        // Try to extract IAT from custom token, in case this token is not\n        // being newly issued. JWT timestamps are in seconds since epoch.\n        const issuedAtTimeSeconds = issuedAtTime(customToken.token);\n        // Very basic validation, use current timestamp as IAT if JWT\n        // has no `iat` field or value is out of bounds.\n        const issuedAtTimeMillis = issuedAtTimeSeconds !== null &&\n            issuedAtTimeSeconds < Date.now() &&\n            issuedAtTimeSeconds > 0\n            ? issuedAtTimeSeconds * 1000\n            : Date.now();\n        return Object.assign(Object.assign({}, customToken), { issuedAtTimeMillis });\n    }\n    /**\n     * @internal\n     */\n    initialize(app) {\n        this._app = app;\n    }\n    /**\n     * @internal\n     */\n    isEqual(otherProvider) {\n        if (otherProvider instanceof CustomProvider) {\n            return (this._customProviderOptions.getToken.toString() ===\n                otherProvider._customProviderOptions.getToken.toString());\n        }\n        else {\n            return false;\n        }\n    }\n}\n/**\n * Set throttle data to block requests until after a certain time\n * depending on the failed request's status code.\n * @param httpStatus - Status code of failed request.\n * @param throttleData - `ThrottleData` object containing previous throttle\n * data state.\n * @returns Data about current throttle state and expiration time.\n */\nfunction setBackoff(httpStatus, throttleData) {\n    /**\n     * Block retries for 1 day for the following error codes:\n     *\n     * 404: Likely malformed URL.\n     *\n     * 403:\n     * - Attestation failed\n     * - Wrong API key\n     * - Project deleted\n     */\n    if (httpStatus === 404 || httpStatus === 403) {\n        return {\n            backoffCount: 1,\n            allowRequestsAfter: Date.now() + ONE_DAY,\n            httpStatus\n        };\n    }\n    else {\n        /**\n         * For all other error codes, the time when it is ok to retry again\n         * is based on exponential backoff.\n         */\n        const backoffCount = throttleData ? throttleData.backoffCount : 0;\n        const backoffMillis = calculateBackoffMillis(backoffCount, 1000, 2);\n        return {\n            backoffCount: backoffCount + 1,\n            allowRequestsAfter: Date.now() + backoffMillis,\n            httpStatus\n        };\n    }\n}\nfunction throwIfThrottled(throttleData) {\n    if (throttleData) {\n        if (Date.now() - throttleData.allowRequestsAfter <= 0) {\n            // If before, throw.\n            throw ERROR_FACTORY.create(\"throttled\" /* AppCheckError.THROTTLED */, {\n                time: getDurationString(throttleData.allowRequestsAfter - Date.now()),\n                httpStatus: throttleData.httpStatus\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Activate App Check for the given app. Can be called only once per app.\n * @param app - the {@link @firebase/app#FirebaseApp} to activate App Check for\n * @param options - App Check initialization options\n * @public\n */\nfunction initializeAppCheck(app = getApp(), options) {\n    app = getModularInstance(app);\n    const provider = _getProvider(app, 'app-check');\n    // Ensure initializeDebugMode() is only called once.\n    if (!getDebugState().initialized) {\n        initializeDebugMode();\n    }\n    // Log a message containing the debug token when `initializeAppCheck()`\n    // is called in debug mode.\n    if (isDebugMode()) {\n        // Do not block initialization to get the token for the message.\n        void getDebugToken().then(token => \n        // Not using logger because I don't think we ever want this accidentally hidden.\n        console.log(`App Check debug token: ${token}. You will need to add it to your app's App Check settings in the Firebase console for it to work.`));\n    }\n    if (provider.isInitialized()) {\n        const existingInstance = provider.getImmediate();\n        const initialOptions = provider.getOptions();\n        if (initialOptions.isTokenAutoRefreshEnabled ===\n            options.isTokenAutoRefreshEnabled &&\n            initialOptions.provider.isEqual(options.provider)) {\n            return existingInstance;\n        }\n        else {\n            throw ERROR_FACTORY.create(\"already-initialized\" /* AppCheckError.ALREADY_INITIALIZED */, {\n                appName: app.name\n            });\n        }\n    }\n    const appCheck = provider.initialize({ options });\n    _activate(app, options.provider, options.isTokenAutoRefreshEnabled);\n    // If isTokenAutoRefreshEnabled is false, do not send any requests to the\n    // exchange endpoint without an explicit call from the user either directly\n    // or through another Firebase library (storage, functions, etc.)\n    if (getStateReference(app).isTokenAutoRefreshEnabled) {\n        // Adding a listener will start the refresher and fetch a token if needed.\n        // This gets a token ready and prevents a delay when an internal library\n        // requests the token.\n        // Listener function does not need to do anything, its base functionality\n        // of calling getToken() already fetches token and writes it to memory/storage.\n        addTokenListener(appCheck, \"INTERNAL\" /* ListenerType.INTERNAL */, () => { });\n    }\n    return appCheck;\n}\n/**\n * Activate App Check\n * @param app - Firebase app to activate App Check for.\n * @param provider - reCAPTCHA v3 provider or\n * custom token provider.\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\n * refreshes App Check tokens as needed. If undefined, defaults to the\n * value of `app.automaticDataCollectionEnabled`, which defaults to\n * false and can be set in the app config.\n */\nfunction _activate(app, provider, isTokenAutoRefreshEnabled) {\n    // Create an entry in the APP_CHECK_STATES map. Further changes should\n    // directly mutate this object.\n    const state = setInitialState(app, Object.assign({}, DEFAULT_STATE));\n    state.activated = true;\n    state.provider = provider; // Read cached token from storage if it exists and store it in memory.\n    state.cachedTokenPromise = readTokenFromStorage(app).then(cachedToken => {\n        if (cachedToken && isValid(cachedToken)) {\n            state.token = cachedToken;\n            // notify all listeners with the cached token\n            notifyTokenListeners(app, { token: cachedToken.token });\n        }\n        return cachedToken;\n    });\n    // Use value of global `automaticDataCollectionEnabled` (which\n    // itself defaults to false if not specified in config) if\n    // `isTokenAutoRefreshEnabled` param was not provided by user.\n    state.isTokenAutoRefreshEnabled =\n        isTokenAutoRefreshEnabled === undefined\n            ? app.automaticDataCollectionEnabled\n            : isTokenAutoRefreshEnabled;\n    state.provider.initialize(app);\n}\n/**\n * Set whether App Check will automatically refresh tokens as needed.\n *\n * @param appCheckInstance - The App Check service instance.\n * @param isTokenAutoRefreshEnabled - If true, the SDK automatically\n * refreshes App Check tokens as needed. This overrides any value set\n * during `initializeAppCheck()`.\n * @public\n */\nfunction setTokenAutoRefreshEnabled(appCheckInstance, isTokenAutoRefreshEnabled) {\n    const app = appCheckInstance.app;\n    const state = getStateReference(app);\n    // This will exist if any product libraries have called\n    // `addTokenListener()`\n    if (state.tokenRefresher) {\n        if (isTokenAutoRefreshEnabled === true) {\n            state.tokenRefresher.start();\n        }\n        else {\n            state.tokenRefresher.stop();\n        }\n    }\n    state.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled;\n}\n/**\n * Get the current App Check token. If `forceRefresh` is false, this function first\n * checks for a valid token in memory, then local persistence (IndexedDB).\n * If not found, or if `forceRefresh` is true, it makes a request to the\n * App Check endpoint for a fresh token. That request attaches\n * to the most recent in-flight request if one is present.\n *\n * @param appCheckInstance - The App Check service instance.\n * @param forceRefresh - If true, will always try to fetch a fresh token.\n * If false, will use a cached token if found in storage.\n * @public\n */\nasync function getToken(appCheckInstance, forceRefresh) {\n    const result = await getToken$2(appCheckInstance, forceRefresh);\n    if (result.error) {\n        throw result.error;\n    }\n    if (result.internalError) {\n        throw result.internalError;\n    }\n    return { token: result.token };\n}\n/**\n * Requests a Firebase App Check token. This method should be used\n * only if you need to authorize requests to a non-Firebase backend.\n *\n * Returns limited-use tokens that are intended for use with your\n * non-Firebase backend endpoints that are protected with\n * <a href=\"https://firebase.google.com/docs/app-check/custom-resource-backend#replay-protection\">\n * Replay Protection</a>. This method\n * does not affect the token generation behavior of the\n * #getAppCheckToken() method.\n *\n * @param appCheckInstance - The App Check service instance.\n * @returns The limited use token.\n * @public\n */\nfunction getLimitedUseToken(appCheckInstance) {\n    return getLimitedUseToken$1(appCheckInstance);\n}\n/**\n * Wraps `addTokenListener`/`removeTokenListener` methods in an `Observer`\n * pattern for public use.\n */\nfunction onTokenChanged(appCheckInstance, onNextOrObserver, onError, \n/**\n * NOTE: Although an `onCompletion` callback can be provided, it will\n * never be called because the token stream is never-ending.\n * It is added only for API consistency with the observer pattern, which\n * we follow in JS APIs.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nonCompletion) {\n    let nextFn = () => { };\n    let errorFn = () => { };\n    if (onNextOrObserver.next != null) {\n        nextFn = onNextOrObserver.next.bind(onNextOrObserver);\n    }\n    else {\n        nextFn = onNextOrObserver;\n    }\n    if (onNextOrObserver.error != null) {\n        errorFn = onNextOrObserver.error.bind(onNextOrObserver);\n    }\n    else if (onError) {\n        errorFn = onError;\n    }\n    addTokenListener(appCheckInstance, \"EXTERNAL\" /* ListenerType.EXTERNAL */, nextFn, errorFn);\n    return () => removeTokenListener(appCheckInstance.app, nextFn);\n}\n\n/**\n * The Firebase App Check Web SDK.\n *\n * @remarks\n * Firebase App Check does not work in a Node.js environment using `ReCaptchaV3Provider` or\n * `ReCaptchaEnterpriseProvider`, but can be used in Node.js if you use\n * `CustomProvider` and write your own attestation method.\n *\n * @packageDocumentation\n */\nconst APP_CHECK_NAME = 'app-check';\nconst APP_CHECK_NAME_INTERNAL = 'app-check-internal';\nfunction registerAppCheck() {\n    // The public interface\n    _registerComponent(new Component(APP_CHECK_NAME, container => {\n        // getImmediate for FirebaseApp will always succeed\n        const app = container.getProvider('app').getImmediate();\n        const heartbeatServiceProvider = container.getProvider('heartbeat');\n        return factory(app, heartbeatServiceProvider);\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */)\n        .setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */)\n        /**\n         * Initialize app-check-internal after app-check is initialized to make AppCheck available to\n         * other Firebase SDKs\n         */\n        .setInstanceCreatedCallback((container, _identifier, _appcheckService) => {\n        container.getProvider(APP_CHECK_NAME_INTERNAL).initialize();\n    }));\n    // The internal interface used by other Firebase products\n    _registerComponent(new Component(APP_CHECK_NAME_INTERNAL, container => {\n        const appCheck = container.getProvider('app-check').getImmediate();\n        return internalFactory(appCheck);\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */).setInstantiationMode(\"EXPLICIT\" /* InstantiationMode.EXPLICIT */));\n    registerVersion(name, version);\n}\nregisterAppCheck();\n\nexport { CustomProvider, ReCaptchaEnterpriseProvider, ReCaptchaV3Provider, getLimitedUseToken, getToken, initializeAppCheck, onTokenChanged, setTokenAutoRefreshEnabled };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}